/* automatically generated by rust-bindgen 0.69.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const TOOLCHAIN_HAS_PRAGMA_DIAG: u32 = 1;
pub const TOOLCHAIN_HAS_C_GENERIC: u32 = 1;
pub const TOOLCHAIN_HAS_C_AUTO_TYPE: u32 = 1;
pub const TOOLCHAIN_HAS_ZLA: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const HAS_BUILTIN___builtin_clz: u32 = 1;
pub const HAS_BUILTIN___builtin_clzl: u32 = 1;
pub const HAS_BUILTIN___builtin_clzll: u32 = 1;
pub const HAS_BUILTIN___builtin_ctz: u32 = 1;
pub const HAS_BUILTIN___builtin_ctzl: u32 = 1;
pub const HAS_BUILTIN___builtin_ctzll: u32 = 1;
pub const UTIL_COMPL_0: u32 = 1;
pub const UTIL_COMPL_1: u32 = 0;
pub const Z_UTIL_INC_0: u32 = 1;
pub const Z_UTIL_INC_1: u32 = 2;
pub const Z_UTIL_INC_2: u32 = 3;
pub const Z_UTIL_INC_3: u32 = 4;
pub const Z_UTIL_INC_4: u32 = 5;
pub const Z_UTIL_INC_5: u32 = 6;
pub const Z_UTIL_INC_6: u32 = 7;
pub const Z_UTIL_INC_7: u32 = 8;
pub const Z_UTIL_INC_8: u32 = 9;
pub const Z_UTIL_INC_9: u32 = 10;
pub const Z_UTIL_INC_10: u32 = 11;
pub const Z_UTIL_INC_11: u32 = 12;
pub const Z_UTIL_INC_12: u32 = 13;
pub const Z_UTIL_INC_13: u32 = 14;
pub const Z_UTIL_INC_14: u32 = 15;
pub const Z_UTIL_INC_15: u32 = 16;
pub const Z_UTIL_INC_16: u32 = 17;
pub const Z_UTIL_INC_17: u32 = 18;
pub const Z_UTIL_INC_18: u32 = 19;
pub const Z_UTIL_INC_19: u32 = 20;
pub const Z_UTIL_INC_20: u32 = 21;
pub const Z_UTIL_INC_21: u32 = 22;
pub const Z_UTIL_INC_22: u32 = 23;
pub const Z_UTIL_INC_23: u32 = 24;
pub const Z_UTIL_INC_24: u32 = 25;
pub const Z_UTIL_INC_25: u32 = 26;
pub const Z_UTIL_INC_26: u32 = 27;
pub const Z_UTIL_INC_27: u32 = 28;
pub const Z_UTIL_INC_28: u32 = 29;
pub const Z_UTIL_INC_29: u32 = 30;
pub const Z_UTIL_INC_30: u32 = 31;
pub const Z_UTIL_INC_31: u32 = 32;
pub const Z_UTIL_INC_32: u32 = 33;
pub const Z_UTIL_INC_33: u32 = 34;
pub const Z_UTIL_INC_34: u32 = 35;
pub const Z_UTIL_INC_35: u32 = 36;
pub const Z_UTIL_INC_36: u32 = 37;
pub const Z_UTIL_INC_37: u32 = 38;
pub const Z_UTIL_INC_38: u32 = 39;
pub const Z_UTIL_INC_39: u32 = 40;
pub const Z_UTIL_INC_40: u32 = 41;
pub const Z_UTIL_INC_41: u32 = 42;
pub const Z_UTIL_INC_42: u32 = 43;
pub const Z_UTIL_INC_43: u32 = 44;
pub const Z_UTIL_INC_44: u32 = 45;
pub const Z_UTIL_INC_45: u32 = 46;
pub const Z_UTIL_INC_46: u32 = 47;
pub const Z_UTIL_INC_47: u32 = 48;
pub const Z_UTIL_INC_48: u32 = 49;
pub const Z_UTIL_INC_49: u32 = 50;
pub const Z_UTIL_INC_50: u32 = 51;
pub const Z_UTIL_INC_51: u32 = 52;
pub const Z_UTIL_INC_52: u32 = 53;
pub const Z_UTIL_INC_53: u32 = 54;
pub const Z_UTIL_INC_54: u32 = 55;
pub const Z_UTIL_INC_55: u32 = 56;
pub const Z_UTIL_INC_56: u32 = 57;
pub const Z_UTIL_INC_57: u32 = 58;
pub const Z_UTIL_INC_58: u32 = 59;
pub const Z_UTIL_INC_59: u32 = 60;
pub const Z_UTIL_INC_60: u32 = 61;
pub const Z_UTIL_INC_61: u32 = 62;
pub const Z_UTIL_INC_62: u32 = 63;
pub const Z_UTIL_INC_63: u32 = 64;
pub const Z_UTIL_INC_64: u32 = 65;
pub const Z_UTIL_INC_65: u32 = 66;
pub const Z_UTIL_INC_66: u32 = 67;
pub const Z_UTIL_INC_67: u32 = 68;
pub const Z_UTIL_INC_68: u32 = 69;
pub const Z_UTIL_INC_69: u32 = 70;
pub const Z_UTIL_INC_70: u32 = 71;
pub const Z_UTIL_INC_71: u32 = 72;
pub const Z_UTIL_INC_72: u32 = 73;
pub const Z_UTIL_INC_73: u32 = 74;
pub const Z_UTIL_INC_74: u32 = 75;
pub const Z_UTIL_INC_75: u32 = 76;
pub const Z_UTIL_INC_76: u32 = 77;
pub const Z_UTIL_INC_77: u32 = 78;
pub const Z_UTIL_INC_78: u32 = 79;
pub const Z_UTIL_INC_79: u32 = 80;
pub const Z_UTIL_INC_80: u32 = 81;
pub const Z_UTIL_INC_81: u32 = 82;
pub const Z_UTIL_INC_82: u32 = 83;
pub const Z_UTIL_INC_83: u32 = 84;
pub const Z_UTIL_INC_84: u32 = 85;
pub const Z_UTIL_INC_85: u32 = 86;
pub const Z_UTIL_INC_86: u32 = 87;
pub const Z_UTIL_INC_87: u32 = 88;
pub const Z_UTIL_INC_88: u32 = 89;
pub const Z_UTIL_INC_89: u32 = 90;
pub const Z_UTIL_INC_90: u32 = 91;
pub const Z_UTIL_INC_91: u32 = 92;
pub const Z_UTIL_INC_92: u32 = 93;
pub const Z_UTIL_INC_93: u32 = 94;
pub const Z_UTIL_INC_94: u32 = 95;
pub const Z_UTIL_INC_95: u32 = 96;
pub const Z_UTIL_INC_96: u32 = 97;
pub const Z_UTIL_INC_97: u32 = 98;
pub const Z_UTIL_INC_98: u32 = 99;
pub const Z_UTIL_INC_99: u32 = 100;
pub const Z_UTIL_INC_100: u32 = 101;
pub const Z_UTIL_INC_101: u32 = 102;
pub const Z_UTIL_INC_102: u32 = 103;
pub const Z_UTIL_INC_103: u32 = 104;
pub const Z_UTIL_INC_104: u32 = 105;
pub const Z_UTIL_INC_105: u32 = 106;
pub const Z_UTIL_INC_106: u32 = 107;
pub const Z_UTIL_INC_107: u32 = 108;
pub const Z_UTIL_INC_108: u32 = 109;
pub const Z_UTIL_INC_109: u32 = 110;
pub const Z_UTIL_INC_110: u32 = 111;
pub const Z_UTIL_INC_111: u32 = 112;
pub const Z_UTIL_INC_112: u32 = 113;
pub const Z_UTIL_INC_113: u32 = 114;
pub const Z_UTIL_INC_114: u32 = 115;
pub const Z_UTIL_INC_115: u32 = 116;
pub const Z_UTIL_INC_116: u32 = 117;
pub const Z_UTIL_INC_117: u32 = 118;
pub const Z_UTIL_INC_118: u32 = 119;
pub const Z_UTIL_INC_119: u32 = 120;
pub const Z_UTIL_INC_120: u32 = 121;
pub const Z_UTIL_INC_121: u32 = 122;
pub const Z_UTIL_INC_122: u32 = 123;
pub const Z_UTIL_INC_123: u32 = 124;
pub const Z_UTIL_INC_124: u32 = 125;
pub const Z_UTIL_INC_125: u32 = 126;
pub const Z_UTIL_INC_126: u32 = 127;
pub const Z_UTIL_INC_127: u32 = 128;
pub const Z_UTIL_INC_128: u32 = 129;
pub const Z_UTIL_INC_129: u32 = 130;
pub const Z_UTIL_INC_130: u32 = 131;
pub const Z_UTIL_INC_131: u32 = 132;
pub const Z_UTIL_INC_132: u32 = 133;
pub const Z_UTIL_INC_133: u32 = 134;
pub const Z_UTIL_INC_134: u32 = 135;
pub const Z_UTIL_INC_135: u32 = 136;
pub const Z_UTIL_INC_136: u32 = 137;
pub const Z_UTIL_INC_137: u32 = 138;
pub const Z_UTIL_INC_138: u32 = 139;
pub const Z_UTIL_INC_139: u32 = 140;
pub const Z_UTIL_INC_140: u32 = 141;
pub const Z_UTIL_INC_141: u32 = 142;
pub const Z_UTIL_INC_142: u32 = 143;
pub const Z_UTIL_INC_143: u32 = 144;
pub const Z_UTIL_INC_144: u32 = 145;
pub const Z_UTIL_INC_145: u32 = 146;
pub const Z_UTIL_INC_146: u32 = 147;
pub const Z_UTIL_INC_147: u32 = 148;
pub const Z_UTIL_INC_148: u32 = 149;
pub const Z_UTIL_INC_149: u32 = 150;
pub const Z_UTIL_INC_150: u32 = 151;
pub const Z_UTIL_INC_151: u32 = 152;
pub const Z_UTIL_INC_152: u32 = 153;
pub const Z_UTIL_INC_153: u32 = 154;
pub const Z_UTIL_INC_154: u32 = 155;
pub const Z_UTIL_INC_155: u32 = 156;
pub const Z_UTIL_INC_156: u32 = 157;
pub const Z_UTIL_INC_157: u32 = 158;
pub const Z_UTIL_INC_158: u32 = 159;
pub const Z_UTIL_INC_159: u32 = 160;
pub const Z_UTIL_INC_160: u32 = 161;
pub const Z_UTIL_INC_161: u32 = 162;
pub const Z_UTIL_INC_162: u32 = 163;
pub const Z_UTIL_INC_163: u32 = 164;
pub const Z_UTIL_INC_164: u32 = 165;
pub const Z_UTIL_INC_165: u32 = 166;
pub const Z_UTIL_INC_166: u32 = 167;
pub const Z_UTIL_INC_167: u32 = 168;
pub const Z_UTIL_INC_168: u32 = 169;
pub const Z_UTIL_INC_169: u32 = 170;
pub const Z_UTIL_INC_170: u32 = 171;
pub const Z_UTIL_INC_171: u32 = 172;
pub const Z_UTIL_INC_172: u32 = 173;
pub const Z_UTIL_INC_173: u32 = 174;
pub const Z_UTIL_INC_174: u32 = 175;
pub const Z_UTIL_INC_175: u32 = 176;
pub const Z_UTIL_INC_176: u32 = 177;
pub const Z_UTIL_INC_177: u32 = 178;
pub const Z_UTIL_INC_178: u32 = 179;
pub const Z_UTIL_INC_179: u32 = 180;
pub const Z_UTIL_INC_180: u32 = 181;
pub const Z_UTIL_INC_181: u32 = 182;
pub const Z_UTIL_INC_182: u32 = 183;
pub const Z_UTIL_INC_183: u32 = 184;
pub const Z_UTIL_INC_184: u32 = 185;
pub const Z_UTIL_INC_185: u32 = 186;
pub const Z_UTIL_INC_186: u32 = 187;
pub const Z_UTIL_INC_187: u32 = 188;
pub const Z_UTIL_INC_188: u32 = 189;
pub const Z_UTIL_INC_189: u32 = 190;
pub const Z_UTIL_INC_190: u32 = 191;
pub const Z_UTIL_INC_191: u32 = 192;
pub const Z_UTIL_INC_192: u32 = 193;
pub const Z_UTIL_INC_193: u32 = 194;
pub const Z_UTIL_INC_194: u32 = 195;
pub const Z_UTIL_INC_195: u32 = 196;
pub const Z_UTIL_INC_196: u32 = 197;
pub const Z_UTIL_INC_197: u32 = 198;
pub const Z_UTIL_INC_198: u32 = 199;
pub const Z_UTIL_INC_199: u32 = 200;
pub const Z_UTIL_INC_200: u32 = 201;
pub const Z_UTIL_INC_201: u32 = 202;
pub const Z_UTIL_INC_202: u32 = 203;
pub const Z_UTIL_INC_203: u32 = 204;
pub const Z_UTIL_INC_204: u32 = 205;
pub const Z_UTIL_INC_205: u32 = 206;
pub const Z_UTIL_INC_206: u32 = 207;
pub const Z_UTIL_INC_207: u32 = 208;
pub const Z_UTIL_INC_208: u32 = 209;
pub const Z_UTIL_INC_209: u32 = 210;
pub const Z_UTIL_INC_210: u32 = 211;
pub const Z_UTIL_INC_211: u32 = 212;
pub const Z_UTIL_INC_212: u32 = 213;
pub const Z_UTIL_INC_213: u32 = 214;
pub const Z_UTIL_INC_214: u32 = 215;
pub const Z_UTIL_INC_215: u32 = 216;
pub const Z_UTIL_INC_216: u32 = 217;
pub const Z_UTIL_INC_217: u32 = 218;
pub const Z_UTIL_INC_218: u32 = 219;
pub const Z_UTIL_INC_219: u32 = 220;
pub const Z_UTIL_INC_220: u32 = 221;
pub const Z_UTIL_INC_221: u32 = 222;
pub const Z_UTIL_INC_222: u32 = 223;
pub const Z_UTIL_INC_223: u32 = 224;
pub const Z_UTIL_INC_224: u32 = 225;
pub const Z_UTIL_INC_225: u32 = 226;
pub const Z_UTIL_INC_226: u32 = 227;
pub const Z_UTIL_INC_227: u32 = 228;
pub const Z_UTIL_INC_228: u32 = 229;
pub const Z_UTIL_INC_229: u32 = 230;
pub const Z_UTIL_INC_230: u32 = 231;
pub const Z_UTIL_INC_231: u32 = 232;
pub const Z_UTIL_INC_232: u32 = 233;
pub const Z_UTIL_INC_233: u32 = 234;
pub const Z_UTIL_INC_234: u32 = 235;
pub const Z_UTIL_INC_235: u32 = 236;
pub const Z_UTIL_INC_236: u32 = 237;
pub const Z_UTIL_INC_237: u32 = 238;
pub const Z_UTIL_INC_238: u32 = 239;
pub const Z_UTIL_INC_239: u32 = 240;
pub const Z_UTIL_INC_240: u32 = 241;
pub const Z_UTIL_INC_241: u32 = 242;
pub const Z_UTIL_INC_242: u32 = 243;
pub const Z_UTIL_INC_243: u32 = 244;
pub const Z_UTIL_INC_244: u32 = 245;
pub const Z_UTIL_INC_245: u32 = 246;
pub const Z_UTIL_INC_246: u32 = 247;
pub const Z_UTIL_INC_247: u32 = 248;
pub const Z_UTIL_INC_248: u32 = 249;
pub const Z_UTIL_INC_249: u32 = 250;
pub const Z_UTIL_INC_250: u32 = 251;
pub const Z_UTIL_INC_251: u32 = 252;
pub const Z_UTIL_INC_252: u32 = 253;
pub const Z_UTIL_INC_253: u32 = 254;
pub const Z_UTIL_INC_254: u32 = 255;
pub const Z_UTIL_INC_255: u32 = 256;
pub const Z_UTIL_INC_256: u32 = 257;
pub const Z_UTIL_INC_257: u32 = 258;
pub const Z_UTIL_INC_258: u32 = 259;
pub const Z_UTIL_INC_259: u32 = 260;
pub const Z_UTIL_INC_260: u32 = 261;
pub const Z_UTIL_INC_261: u32 = 262;
pub const Z_UTIL_INC_262: u32 = 263;
pub const Z_UTIL_INC_263: u32 = 264;
pub const Z_UTIL_INC_264: u32 = 265;
pub const Z_UTIL_INC_265: u32 = 266;
pub const Z_UTIL_INC_266: u32 = 267;
pub const Z_UTIL_INC_267: u32 = 268;
pub const Z_UTIL_INC_268: u32 = 269;
pub const Z_UTIL_INC_269: u32 = 270;
pub const Z_UTIL_INC_270: u32 = 271;
pub const Z_UTIL_INC_271: u32 = 272;
pub const Z_UTIL_INC_272: u32 = 273;
pub const Z_UTIL_INC_273: u32 = 274;
pub const Z_UTIL_INC_274: u32 = 275;
pub const Z_UTIL_INC_275: u32 = 276;
pub const Z_UTIL_INC_276: u32 = 277;
pub const Z_UTIL_INC_277: u32 = 278;
pub const Z_UTIL_INC_278: u32 = 279;
pub const Z_UTIL_INC_279: u32 = 280;
pub const Z_UTIL_INC_280: u32 = 281;
pub const Z_UTIL_INC_281: u32 = 282;
pub const Z_UTIL_INC_282: u32 = 283;
pub const Z_UTIL_INC_283: u32 = 284;
pub const Z_UTIL_INC_284: u32 = 285;
pub const Z_UTIL_INC_285: u32 = 286;
pub const Z_UTIL_INC_286: u32 = 287;
pub const Z_UTIL_INC_287: u32 = 288;
pub const Z_UTIL_INC_288: u32 = 289;
pub const Z_UTIL_INC_289: u32 = 290;
pub const Z_UTIL_INC_290: u32 = 291;
pub const Z_UTIL_INC_291: u32 = 292;
pub const Z_UTIL_INC_292: u32 = 293;
pub const Z_UTIL_INC_293: u32 = 294;
pub const Z_UTIL_INC_294: u32 = 295;
pub const Z_UTIL_INC_295: u32 = 296;
pub const Z_UTIL_INC_296: u32 = 297;
pub const Z_UTIL_INC_297: u32 = 298;
pub const Z_UTIL_INC_298: u32 = 299;
pub const Z_UTIL_INC_299: u32 = 300;
pub const Z_UTIL_INC_300: u32 = 301;
pub const Z_UTIL_INC_301: u32 = 302;
pub const Z_UTIL_INC_302: u32 = 303;
pub const Z_UTIL_INC_303: u32 = 304;
pub const Z_UTIL_INC_304: u32 = 305;
pub const Z_UTIL_INC_305: u32 = 306;
pub const Z_UTIL_INC_306: u32 = 307;
pub const Z_UTIL_INC_307: u32 = 308;
pub const Z_UTIL_INC_308: u32 = 309;
pub const Z_UTIL_INC_309: u32 = 310;
pub const Z_UTIL_INC_310: u32 = 311;
pub const Z_UTIL_INC_311: u32 = 312;
pub const Z_UTIL_INC_312: u32 = 313;
pub const Z_UTIL_INC_313: u32 = 314;
pub const Z_UTIL_INC_314: u32 = 315;
pub const Z_UTIL_INC_315: u32 = 316;
pub const Z_UTIL_INC_316: u32 = 317;
pub const Z_UTIL_INC_317: u32 = 318;
pub const Z_UTIL_INC_318: u32 = 319;
pub const Z_UTIL_INC_319: u32 = 320;
pub const Z_UTIL_INC_320: u32 = 321;
pub const Z_UTIL_INC_321: u32 = 322;
pub const Z_UTIL_INC_322: u32 = 323;
pub const Z_UTIL_INC_323: u32 = 324;
pub const Z_UTIL_INC_324: u32 = 325;
pub const Z_UTIL_INC_325: u32 = 326;
pub const Z_UTIL_INC_326: u32 = 327;
pub const Z_UTIL_INC_327: u32 = 328;
pub const Z_UTIL_INC_328: u32 = 329;
pub const Z_UTIL_INC_329: u32 = 330;
pub const Z_UTIL_INC_330: u32 = 331;
pub const Z_UTIL_INC_331: u32 = 332;
pub const Z_UTIL_INC_332: u32 = 333;
pub const Z_UTIL_INC_333: u32 = 334;
pub const Z_UTIL_INC_334: u32 = 335;
pub const Z_UTIL_INC_335: u32 = 336;
pub const Z_UTIL_INC_336: u32 = 337;
pub const Z_UTIL_INC_337: u32 = 338;
pub const Z_UTIL_INC_338: u32 = 339;
pub const Z_UTIL_INC_339: u32 = 340;
pub const Z_UTIL_INC_340: u32 = 341;
pub const Z_UTIL_INC_341: u32 = 342;
pub const Z_UTIL_INC_342: u32 = 343;
pub const Z_UTIL_INC_343: u32 = 344;
pub const Z_UTIL_INC_344: u32 = 345;
pub const Z_UTIL_INC_345: u32 = 346;
pub const Z_UTIL_INC_346: u32 = 347;
pub const Z_UTIL_INC_347: u32 = 348;
pub const Z_UTIL_INC_348: u32 = 349;
pub const Z_UTIL_INC_349: u32 = 350;
pub const Z_UTIL_INC_350: u32 = 351;
pub const Z_UTIL_INC_351: u32 = 352;
pub const Z_UTIL_INC_352: u32 = 353;
pub const Z_UTIL_INC_353: u32 = 354;
pub const Z_UTIL_INC_354: u32 = 355;
pub const Z_UTIL_INC_355: u32 = 356;
pub const Z_UTIL_INC_356: u32 = 357;
pub const Z_UTIL_INC_357: u32 = 358;
pub const Z_UTIL_INC_358: u32 = 359;
pub const Z_UTIL_INC_359: u32 = 360;
pub const Z_UTIL_INC_360: u32 = 361;
pub const Z_UTIL_INC_361: u32 = 362;
pub const Z_UTIL_INC_362: u32 = 363;
pub const Z_UTIL_INC_363: u32 = 364;
pub const Z_UTIL_INC_364: u32 = 365;
pub const Z_UTIL_INC_365: u32 = 366;
pub const Z_UTIL_INC_366: u32 = 367;
pub const Z_UTIL_INC_367: u32 = 368;
pub const Z_UTIL_INC_368: u32 = 369;
pub const Z_UTIL_INC_369: u32 = 370;
pub const Z_UTIL_INC_370: u32 = 371;
pub const Z_UTIL_INC_371: u32 = 372;
pub const Z_UTIL_INC_372: u32 = 373;
pub const Z_UTIL_INC_373: u32 = 374;
pub const Z_UTIL_INC_374: u32 = 375;
pub const Z_UTIL_INC_375: u32 = 376;
pub const Z_UTIL_INC_376: u32 = 377;
pub const Z_UTIL_INC_377: u32 = 378;
pub const Z_UTIL_INC_378: u32 = 379;
pub const Z_UTIL_INC_379: u32 = 380;
pub const Z_UTIL_INC_380: u32 = 381;
pub const Z_UTIL_INC_381: u32 = 382;
pub const Z_UTIL_INC_382: u32 = 383;
pub const Z_UTIL_INC_383: u32 = 384;
pub const Z_UTIL_INC_384: u32 = 385;
pub const Z_UTIL_INC_385: u32 = 386;
pub const Z_UTIL_INC_386: u32 = 387;
pub const Z_UTIL_INC_387: u32 = 388;
pub const Z_UTIL_INC_388: u32 = 389;
pub const Z_UTIL_INC_389: u32 = 390;
pub const Z_UTIL_INC_390: u32 = 391;
pub const Z_UTIL_INC_391: u32 = 392;
pub const Z_UTIL_INC_392: u32 = 393;
pub const Z_UTIL_INC_393: u32 = 394;
pub const Z_UTIL_INC_394: u32 = 395;
pub const Z_UTIL_INC_395: u32 = 396;
pub const Z_UTIL_INC_396: u32 = 397;
pub const Z_UTIL_INC_397: u32 = 398;
pub const Z_UTIL_INC_398: u32 = 399;
pub const Z_UTIL_INC_399: u32 = 400;
pub const Z_UTIL_INC_400: u32 = 401;
pub const Z_UTIL_INC_401: u32 = 402;
pub const Z_UTIL_INC_402: u32 = 403;
pub const Z_UTIL_INC_403: u32 = 404;
pub const Z_UTIL_INC_404: u32 = 405;
pub const Z_UTIL_INC_405: u32 = 406;
pub const Z_UTIL_INC_406: u32 = 407;
pub const Z_UTIL_INC_407: u32 = 408;
pub const Z_UTIL_INC_408: u32 = 409;
pub const Z_UTIL_INC_409: u32 = 410;
pub const Z_UTIL_INC_410: u32 = 411;
pub const Z_UTIL_INC_411: u32 = 412;
pub const Z_UTIL_INC_412: u32 = 413;
pub const Z_UTIL_INC_413: u32 = 414;
pub const Z_UTIL_INC_414: u32 = 415;
pub const Z_UTIL_INC_415: u32 = 416;
pub const Z_UTIL_INC_416: u32 = 417;
pub const Z_UTIL_INC_417: u32 = 418;
pub const Z_UTIL_INC_418: u32 = 419;
pub const Z_UTIL_INC_419: u32 = 420;
pub const Z_UTIL_INC_420: u32 = 421;
pub const Z_UTIL_INC_421: u32 = 422;
pub const Z_UTIL_INC_422: u32 = 423;
pub const Z_UTIL_INC_423: u32 = 424;
pub const Z_UTIL_INC_424: u32 = 425;
pub const Z_UTIL_INC_425: u32 = 426;
pub const Z_UTIL_INC_426: u32 = 427;
pub const Z_UTIL_INC_427: u32 = 428;
pub const Z_UTIL_INC_428: u32 = 429;
pub const Z_UTIL_INC_429: u32 = 430;
pub const Z_UTIL_INC_430: u32 = 431;
pub const Z_UTIL_INC_431: u32 = 432;
pub const Z_UTIL_INC_432: u32 = 433;
pub const Z_UTIL_INC_433: u32 = 434;
pub const Z_UTIL_INC_434: u32 = 435;
pub const Z_UTIL_INC_435: u32 = 436;
pub const Z_UTIL_INC_436: u32 = 437;
pub const Z_UTIL_INC_437: u32 = 438;
pub const Z_UTIL_INC_438: u32 = 439;
pub const Z_UTIL_INC_439: u32 = 440;
pub const Z_UTIL_INC_440: u32 = 441;
pub const Z_UTIL_INC_441: u32 = 442;
pub const Z_UTIL_INC_442: u32 = 443;
pub const Z_UTIL_INC_443: u32 = 444;
pub const Z_UTIL_INC_444: u32 = 445;
pub const Z_UTIL_INC_445: u32 = 446;
pub const Z_UTIL_INC_446: u32 = 447;
pub const Z_UTIL_INC_447: u32 = 448;
pub const Z_UTIL_INC_448: u32 = 449;
pub const Z_UTIL_INC_449: u32 = 450;
pub const Z_UTIL_INC_450: u32 = 451;
pub const Z_UTIL_INC_451: u32 = 452;
pub const Z_UTIL_INC_452: u32 = 453;
pub const Z_UTIL_INC_453: u32 = 454;
pub const Z_UTIL_INC_454: u32 = 455;
pub const Z_UTIL_INC_455: u32 = 456;
pub const Z_UTIL_INC_456: u32 = 457;
pub const Z_UTIL_INC_457: u32 = 458;
pub const Z_UTIL_INC_458: u32 = 459;
pub const Z_UTIL_INC_459: u32 = 460;
pub const Z_UTIL_INC_460: u32 = 461;
pub const Z_UTIL_INC_461: u32 = 462;
pub const Z_UTIL_INC_462: u32 = 463;
pub const Z_UTIL_INC_463: u32 = 464;
pub const Z_UTIL_INC_464: u32 = 465;
pub const Z_UTIL_INC_465: u32 = 466;
pub const Z_UTIL_INC_466: u32 = 467;
pub const Z_UTIL_INC_467: u32 = 468;
pub const Z_UTIL_INC_468: u32 = 469;
pub const Z_UTIL_INC_469: u32 = 470;
pub const Z_UTIL_INC_470: u32 = 471;
pub const Z_UTIL_INC_471: u32 = 472;
pub const Z_UTIL_INC_472: u32 = 473;
pub const Z_UTIL_INC_473: u32 = 474;
pub const Z_UTIL_INC_474: u32 = 475;
pub const Z_UTIL_INC_475: u32 = 476;
pub const Z_UTIL_INC_476: u32 = 477;
pub const Z_UTIL_INC_477: u32 = 478;
pub const Z_UTIL_INC_478: u32 = 479;
pub const Z_UTIL_INC_479: u32 = 480;
pub const Z_UTIL_INC_480: u32 = 481;
pub const Z_UTIL_INC_481: u32 = 482;
pub const Z_UTIL_INC_482: u32 = 483;
pub const Z_UTIL_INC_483: u32 = 484;
pub const Z_UTIL_INC_484: u32 = 485;
pub const Z_UTIL_INC_485: u32 = 486;
pub const Z_UTIL_INC_486: u32 = 487;
pub const Z_UTIL_INC_487: u32 = 488;
pub const Z_UTIL_INC_488: u32 = 489;
pub const Z_UTIL_INC_489: u32 = 490;
pub const Z_UTIL_INC_490: u32 = 491;
pub const Z_UTIL_INC_491: u32 = 492;
pub const Z_UTIL_INC_492: u32 = 493;
pub const Z_UTIL_INC_493: u32 = 494;
pub const Z_UTIL_INC_494: u32 = 495;
pub const Z_UTIL_INC_495: u32 = 496;
pub const Z_UTIL_INC_496: u32 = 497;
pub const Z_UTIL_INC_497: u32 = 498;
pub const Z_UTIL_INC_498: u32 = 499;
pub const Z_UTIL_INC_499: u32 = 500;
pub const Z_UTIL_INC_500: u32 = 501;
pub const Z_UTIL_INC_501: u32 = 502;
pub const Z_UTIL_INC_502: u32 = 503;
pub const Z_UTIL_INC_503: u32 = 504;
pub const Z_UTIL_INC_504: u32 = 505;
pub const Z_UTIL_INC_505: u32 = 506;
pub const Z_UTIL_INC_506: u32 = 507;
pub const Z_UTIL_INC_507: u32 = 508;
pub const Z_UTIL_INC_508: u32 = 509;
pub const Z_UTIL_INC_509: u32 = 510;
pub const Z_UTIL_INC_510: u32 = 511;
pub const Z_UTIL_INC_511: u32 = 512;
pub const Z_UTIL_INC_512: u32 = 513;
pub const Z_UTIL_INC_513: u32 = 514;
pub const Z_UTIL_INC_514: u32 = 515;
pub const Z_UTIL_INC_515: u32 = 516;
pub const Z_UTIL_INC_516: u32 = 517;
pub const Z_UTIL_INC_517: u32 = 518;
pub const Z_UTIL_INC_518: u32 = 519;
pub const Z_UTIL_INC_519: u32 = 520;
pub const Z_UTIL_INC_520: u32 = 521;
pub const Z_UTIL_INC_521: u32 = 522;
pub const Z_UTIL_INC_522: u32 = 523;
pub const Z_UTIL_INC_523: u32 = 524;
pub const Z_UTIL_INC_524: u32 = 525;
pub const Z_UTIL_INC_525: u32 = 526;
pub const Z_UTIL_INC_526: u32 = 527;
pub const Z_UTIL_INC_527: u32 = 528;
pub const Z_UTIL_INC_528: u32 = 529;
pub const Z_UTIL_INC_529: u32 = 530;
pub const Z_UTIL_INC_530: u32 = 531;
pub const Z_UTIL_INC_531: u32 = 532;
pub const Z_UTIL_INC_532: u32 = 533;
pub const Z_UTIL_INC_533: u32 = 534;
pub const Z_UTIL_INC_534: u32 = 535;
pub const Z_UTIL_INC_535: u32 = 536;
pub const Z_UTIL_INC_536: u32 = 537;
pub const Z_UTIL_INC_537: u32 = 538;
pub const Z_UTIL_INC_538: u32 = 539;
pub const Z_UTIL_INC_539: u32 = 540;
pub const Z_UTIL_INC_540: u32 = 541;
pub const Z_UTIL_INC_541: u32 = 542;
pub const Z_UTIL_INC_542: u32 = 543;
pub const Z_UTIL_INC_543: u32 = 544;
pub const Z_UTIL_INC_544: u32 = 545;
pub const Z_UTIL_INC_545: u32 = 546;
pub const Z_UTIL_INC_546: u32 = 547;
pub const Z_UTIL_INC_547: u32 = 548;
pub const Z_UTIL_INC_548: u32 = 549;
pub const Z_UTIL_INC_549: u32 = 550;
pub const Z_UTIL_INC_550: u32 = 551;
pub const Z_UTIL_INC_551: u32 = 552;
pub const Z_UTIL_INC_552: u32 = 553;
pub const Z_UTIL_INC_553: u32 = 554;
pub const Z_UTIL_INC_554: u32 = 555;
pub const Z_UTIL_INC_555: u32 = 556;
pub const Z_UTIL_INC_556: u32 = 557;
pub const Z_UTIL_INC_557: u32 = 558;
pub const Z_UTIL_INC_558: u32 = 559;
pub const Z_UTIL_INC_559: u32 = 560;
pub const Z_UTIL_INC_560: u32 = 561;
pub const Z_UTIL_INC_561: u32 = 562;
pub const Z_UTIL_INC_562: u32 = 563;
pub const Z_UTIL_INC_563: u32 = 564;
pub const Z_UTIL_INC_564: u32 = 565;
pub const Z_UTIL_INC_565: u32 = 566;
pub const Z_UTIL_INC_566: u32 = 567;
pub const Z_UTIL_INC_567: u32 = 568;
pub const Z_UTIL_INC_568: u32 = 569;
pub const Z_UTIL_INC_569: u32 = 570;
pub const Z_UTIL_INC_570: u32 = 571;
pub const Z_UTIL_INC_571: u32 = 572;
pub const Z_UTIL_INC_572: u32 = 573;
pub const Z_UTIL_INC_573: u32 = 574;
pub const Z_UTIL_INC_574: u32 = 575;
pub const Z_UTIL_INC_575: u32 = 576;
pub const Z_UTIL_INC_576: u32 = 577;
pub const Z_UTIL_INC_577: u32 = 578;
pub const Z_UTIL_INC_578: u32 = 579;
pub const Z_UTIL_INC_579: u32 = 580;
pub const Z_UTIL_INC_580: u32 = 581;
pub const Z_UTIL_INC_581: u32 = 582;
pub const Z_UTIL_INC_582: u32 = 583;
pub const Z_UTIL_INC_583: u32 = 584;
pub const Z_UTIL_INC_584: u32 = 585;
pub const Z_UTIL_INC_585: u32 = 586;
pub const Z_UTIL_INC_586: u32 = 587;
pub const Z_UTIL_INC_587: u32 = 588;
pub const Z_UTIL_INC_588: u32 = 589;
pub const Z_UTIL_INC_589: u32 = 590;
pub const Z_UTIL_INC_590: u32 = 591;
pub const Z_UTIL_INC_591: u32 = 592;
pub const Z_UTIL_INC_592: u32 = 593;
pub const Z_UTIL_INC_593: u32 = 594;
pub const Z_UTIL_INC_594: u32 = 595;
pub const Z_UTIL_INC_595: u32 = 596;
pub const Z_UTIL_INC_596: u32 = 597;
pub const Z_UTIL_INC_597: u32 = 598;
pub const Z_UTIL_INC_598: u32 = 599;
pub const Z_UTIL_INC_599: u32 = 600;
pub const Z_UTIL_INC_600: u32 = 601;
pub const Z_UTIL_INC_601: u32 = 602;
pub const Z_UTIL_INC_602: u32 = 603;
pub const Z_UTIL_INC_603: u32 = 604;
pub const Z_UTIL_INC_604: u32 = 605;
pub const Z_UTIL_INC_605: u32 = 606;
pub const Z_UTIL_INC_606: u32 = 607;
pub const Z_UTIL_INC_607: u32 = 608;
pub const Z_UTIL_INC_608: u32 = 609;
pub const Z_UTIL_INC_609: u32 = 610;
pub const Z_UTIL_INC_610: u32 = 611;
pub const Z_UTIL_INC_611: u32 = 612;
pub const Z_UTIL_INC_612: u32 = 613;
pub const Z_UTIL_INC_613: u32 = 614;
pub const Z_UTIL_INC_614: u32 = 615;
pub const Z_UTIL_INC_615: u32 = 616;
pub const Z_UTIL_INC_616: u32 = 617;
pub const Z_UTIL_INC_617: u32 = 618;
pub const Z_UTIL_INC_618: u32 = 619;
pub const Z_UTIL_INC_619: u32 = 620;
pub const Z_UTIL_INC_620: u32 = 621;
pub const Z_UTIL_INC_621: u32 = 622;
pub const Z_UTIL_INC_622: u32 = 623;
pub const Z_UTIL_INC_623: u32 = 624;
pub const Z_UTIL_INC_624: u32 = 625;
pub const Z_UTIL_INC_625: u32 = 626;
pub const Z_UTIL_INC_626: u32 = 627;
pub const Z_UTIL_INC_627: u32 = 628;
pub const Z_UTIL_INC_628: u32 = 629;
pub const Z_UTIL_INC_629: u32 = 630;
pub const Z_UTIL_INC_630: u32 = 631;
pub const Z_UTIL_INC_631: u32 = 632;
pub const Z_UTIL_INC_632: u32 = 633;
pub const Z_UTIL_INC_633: u32 = 634;
pub const Z_UTIL_INC_634: u32 = 635;
pub const Z_UTIL_INC_635: u32 = 636;
pub const Z_UTIL_INC_636: u32 = 637;
pub const Z_UTIL_INC_637: u32 = 638;
pub const Z_UTIL_INC_638: u32 = 639;
pub const Z_UTIL_INC_639: u32 = 640;
pub const Z_UTIL_INC_640: u32 = 641;
pub const Z_UTIL_INC_641: u32 = 642;
pub const Z_UTIL_INC_642: u32 = 643;
pub const Z_UTIL_INC_643: u32 = 644;
pub const Z_UTIL_INC_644: u32 = 645;
pub const Z_UTIL_INC_645: u32 = 646;
pub const Z_UTIL_INC_646: u32 = 647;
pub const Z_UTIL_INC_647: u32 = 648;
pub const Z_UTIL_INC_648: u32 = 649;
pub const Z_UTIL_INC_649: u32 = 650;
pub const Z_UTIL_INC_650: u32 = 651;
pub const Z_UTIL_INC_651: u32 = 652;
pub const Z_UTIL_INC_652: u32 = 653;
pub const Z_UTIL_INC_653: u32 = 654;
pub const Z_UTIL_INC_654: u32 = 655;
pub const Z_UTIL_INC_655: u32 = 656;
pub const Z_UTIL_INC_656: u32 = 657;
pub const Z_UTIL_INC_657: u32 = 658;
pub const Z_UTIL_INC_658: u32 = 659;
pub const Z_UTIL_INC_659: u32 = 660;
pub const Z_UTIL_INC_660: u32 = 661;
pub const Z_UTIL_INC_661: u32 = 662;
pub const Z_UTIL_INC_662: u32 = 663;
pub const Z_UTIL_INC_663: u32 = 664;
pub const Z_UTIL_INC_664: u32 = 665;
pub const Z_UTIL_INC_665: u32 = 666;
pub const Z_UTIL_INC_666: u32 = 667;
pub const Z_UTIL_INC_667: u32 = 668;
pub const Z_UTIL_INC_668: u32 = 669;
pub const Z_UTIL_INC_669: u32 = 670;
pub const Z_UTIL_INC_670: u32 = 671;
pub const Z_UTIL_INC_671: u32 = 672;
pub const Z_UTIL_INC_672: u32 = 673;
pub const Z_UTIL_INC_673: u32 = 674;
pub const Z_UTIL_INC_674: u32 = 675;
pub const Z_UTIL_INC_675: u32 = 676;
pub const Z_UTIL_INC_676: u32 = 677;
pub const Z_UTIL_INC_677: u32 = 678;
pub const Z_UTIL_INC_678: u32 = 679;
pub const Z_UTIL_INC_679: u32 = 680;
pub const Z_UTIL_INC_680: u32 = 681;
pub const Z_UTIL_INC_681: u32 = 682;
pub const Z_UTIL_INC_682: u32 = 683;
pub const Z_UTIL_INC_683: u32 = 684;
pub const Z_UTIL_INC_684: u32 = 685;
pub const Z_UTIL_INC_685: u32 = 686;
pub const Z_UTIL_INC_686: u32 = 687;
pub const Z_UTIL_INC_687: u32 = 688;
pub const Z_UTIL_INC_688: u32 = 689;
pub const Z_UTIL_INC_689: u32 = 690;
pub const Z_UTIL_INC_690: u32 = 691;
pub const Z_UTIL_INC_691: u32 = 692;
pub const Z_UTIL_INC_692: u32 = 693;
pub const Z_UTIL_INC_693: u32 = 694;
pub const Z_UTIL_INC_694: u32 = 695;
pub const Z_UTIL_INC_695: u32 = 696;
pub const Z_UTIL_INC_696: u32 = 697;
pub const Z_UTIL_INC_697: u32 = 698;
pub const Z_UTIL_INC_698: u32 = 699;
pub const Z_UTIL_INC_699: u32 = 700;
pub const Z_UTIL_INC_700: u32 = 701;
pub const Z_UTIL_INC_701: u32 = 702;
pub const Z_UTIL_INC_702: u32 = 703;
pub const Z_UTIL_INC_703: u32 = 704;
pub const Z_UTIL_INC_704: u32 = 705;
pub const Z_UTIL_INC_705: u32 = 706;
pub const Z_UTIL_INC_706: u32 = 707;
pub const Z_UTIL_INC_707: u32 = 708;
pub const Z_UTIL_INC_708: u32 = 709;
pub const Z_UTIL_INC_709: u32 = 710;
pub const Z_UTIL_INC_710: u32 = 711;
pub const Z_UTIL_INC_711: u32 = 712;
pub const Z_UTIL_INC_712: u32 = 713;
pub const Z_UTIL_INC_713: u32 = 714;
pub const Z_UTIL_INC_714: u32 = 715;
pub const Z_UTIL_INC_715: u32 = 716;
pub const Z_UTIL_INC_716: u32 = 717;
pub const Z_UTIL_INC_717: u32 = 718;
pub const Z_UTIL_INC_718: u32 = 719;
pub const Z_UTIL_INC_719: u32 = 720;
pub const Z_UTIL_INC_720: u32 = 721;
pub const Z_UTIL_INC_721: u32 = 722;
pub const Z_UTIL_INC_722: u32 = 723;
pub const Z_UTIL_INC_723: u32 = 724;
pub const Z_UTIL_INC_724: u32 = 725;
pub const Z_UTIL_INC_725: u32 = 726;
pub const Z_UTIL_INC_726: u32 = 727;
pub const Z_UTIL_INC_727: u32 = 728;
pub const Z_UTIL_INC_728: u32 = 729;
pub const Z_UTIL_INC_729: u32 = 730;
pub const Z_UTIL_INC_730: u32 = 731;
pub const Z_UTIL_INC_731: u32 = 732;
pub const Z_UTIL_INC_732: u32 = 733;
pub const Z_UTIL_INC_733: u32 = 734;
pub const Z_UTIL_INC_734: u32 = 735;
pub const Z_UTIL_INC_735: u32 = 736;
pub const Z_UTIL_INC_736: u32 = 737;
pub const Z_UTIL_INC_737: u32 = 738;
pub const Z_UTIL_INC_738: u32 = 739;
pub const Z_UTIL_INC_739: u32 = 740;
pub const Z_UTIL_INC_740: u32 = 741;
pub const Z_UTIL_INC_741: u32 = 742;
pub const Z_UTIL_INC_742: u32 = 743;
pub const Z_UTIL_INC_743: u32 = 744;
pub const Z_UTIL_INC_744: u32 = 745;
pub const Z_UTIL_INC_745: u32 = 746;
pub const Z_UTIL_INC_746: u32 = 747;
pub const Z_UTIL_INC_747: u32 = 748;
pub const Z_UTIL_INC_748: u32 = 749;
pub const Z_UTIL_INC_749: u32 = 750;
pub const Z_UTIL_INC_750: u32 = 751;
pub const Z_UTIL_INC_751: u32 = 752;
pub const Z_UTIL_INC_752: u32 = 753;
pub const Z_UTIL_INC_753: u32 = 754;
pub const Z_UTIL_INC_754: u32 = 755;
pub const Z_UTIL_INC_755: u32 = 756;
pub const Z_UTIL_INC_756: u32 = 757;
pub const Z_UTIL_INC_757: u32 = 758;
pub const Z_UTIL_INC_758: u32 = 759;
pub const Z_UTIL_INC_759: u32 = 760;
pub const Z_UTIL_INC_760: u32 = 761;
pub const Z_UTIL_INC_761: u32 = 762;
pub const Z_UTIL_INC_762: u32 = 763;
pub const Z_UTIL_INC_763: u32 = 764;
pub const Z_UTIL_INC_764: u32 = 765;
pub const Z_UTIL_INC_765: u32 = 766;
pub const Z_UTIL_INC_766: u32 = 767;
pub const Z_UTIL_INC_767: u32 = 768;
pub const Z_UTIL_INC_768: u32 = 769;
pub const Z_UTIL_INC_769: u32 = 770;
pub const Z_UTIL_INC_770: u32 = 771;
pub const Z_UTIL_INC_771: u32 = 772;
pub const Z_UTIL_INC_772: u32 = 773;
pub const Z_UTIL_INC_773: u32 = 774;
pub const Z_UTIL_INC_774: u32 = 775;
pub const Z_UTIL_INC_775: u32 = 776;
pub const Z_UTIL_INC_776: u32 = 777;
pub const Z_UTIL_INC_777: u32 = 778;
pub const Z_UTIL_INC_778: u32 = 779;
pub const Z_UTIL_INC_779: u32 = 780;
pub const Z_UTIL_INC_780: u32 = 781;
pub const Z_UTIL_INC_781: u32 = 782;
pub const Z_UTIL_INC_782: u32 = 783;
pub const Z_UTIL_INC_783: u32 = 784;
pub const Z_UTIL_INC_784: u32 = 785;
pub const Z_UTIL_INC_785: u32 = 786;
pub const Z_UTIL_INC_786: u32 = 787;
pub const Z_UTIL_INC_787: u32 = 788;
pub const Z_UTIL_INC_788: u32 = 789;
pub const Z_UTIL_INC_789: u32 = 790;
pub const Z_UTIL_INC_790: u32 = 791;
pub const Z_UTIL_INC_791: u32 = 792;
pub const Z_UTIL_INC_792: u32 = 793;
pub const Z_UTIL_INC_793: u32 = 794;
pub const Z_UTIL_INC_794: u32 = 795;
pub const Z_UTIL_INC_795: u32 = 796;
pub const Z_UTIL_INC_796: u32 = 797;
pub const Z_UTIL_INC_797: u32 = 798;
pub const Z_UTIL_INC_798: u32 = 799;
pub const Z_UTIL_INC_799: u32 = 800;
pub const Z_UTIL_INC_800: u32 = 801;
pub const Z_UTIL_INC_801: u32 = 802;
pub const Z_UTIL_INC_802: u32 = 803;
pub const Z_UTIL_INC_803: u32 = 804;
pub const Z_UTIL_INC_804: u32 = 805;
pub const Z_UTIL_INC_805: u32 = 806;
pub const Z_UTIL_INC_806: u32 = 807;
pub const Z_UTIL_INC_807: u32 = 808;
pub const Z_UTIL_INC_808: u32 = 809;
pub const Z_UTIL_INC_809: u32 = 810;
pub const Z_UTIL_INC_810: u32 = 811;
pub const Z_UTIL_INC_811: u32 = 812;
pub const Z_UTIL_INC_812: u32 = 813;
pub const Z_UTIL_INC_813: u32 = 814;
pub const Z_UTIL_INC_814: u32 = 815;
pub const Z_UTIL_INC_815: u32 = 816;
pub const Z_UTIL_INC_816: u32 = 817;
pub const Z_UTIL_INC_817: u32 = 818;
pub const Z_UTIL_INC_818: u32 = 819;
pub const Z_UTIL_INC_819: u32 = 820;
pub const Z_UTIL_INC_820: u32 = 821;
pub const Z_UTIL_INC_821: u32 = 822;
pub const Z_UTIL_INC_822: u32 = 823;
pub const Z_UTIL_INC_823: u32 = 824;
pub const Z_UTIL_INC_824: u32 = 825;
pub const Z_UTIL_INC_825: u32 = 826;
pub const Z_UTIL_INC_826: u32 = 827;
pub const Z_UTIL_INC_827: u32 = 828;
pub const Z_UTIL_INC_828: u32 = 829;
pub const Z_UTIL_INC_829: u32 = 830;
pub const Z_UTIL_INC_830: u32 = 831;
pub const Z_UTIL_INC_831: u32 = 832;
pub const Z_UTIL_INC_832: u32 = 833;
pub const Z_UTIL_INC_833: u32 = 834;
pub const Z_UTIL_INC_834: u32 = 835;
pub const Z_UTIL_INC_835: u32 = 836;
pub const Z_UTIL_INC_836: u32 = 837;
pub const Z_UTIL_INC_837: u32 = 838;
pub const Z_UTIL_INC_838: u32 = 839;
pub const Z_UTIL_INC_839: u32 = 840;
pub const Z_UTIL_INC_840: u32 = 841;
pub const Z_UTIL_INC_841: u32 = 842;
pub const Z_UTIL_INC_842: u32 = 843;
pub const Z_UTIL_INC_843: u32 = 844;
pub const Z_UTIL_INC_844: u32 = 845;
pub const Z_UTIL_INC_845: u32 = 846;
pub const Z_UTIL_INC_846: u32 = 847;
pub const Z_UTIL_INC_847: u32 = 848;
pub const Z_UTIL_INC_848: u32 = 849;
pub const Z_UTIL_INC_849: u32 = 850;
pub const Z_UTIL_INC_850: u32 = 851;
pub const Z_UTIL_INC_851: u32 = 852;
pub const Z_UTIL_INC_852: u32 = 853;
pub const Z_UTIL_INC_853: u32 = 854;
pub const Z_UTIL_INC_854: u32 = 855;
pub const Z_UTIL_INC_855: u32 = 856;
pub const Z_UTIL_INC_856: u32 = 857;
pub const Z_UTIL_INC_857: u32 = 858;
pub const Z_UTIL_INC_858: u32 = 859;
pub const Z_UTIL_INC_859: u32 = 860;
pub const Z_UTIL_INC_860: u32 = 861;
pub const Z_UTIL_INC_861: u32 = 862;
pub const Z_UTIL_INC_862: u32 = 863;
pub const Z_UTIL_INC_863: u32 = 864;
pub const Z_UTIL_INC_864: u32 = 865;
pub const Z_UTIL_INC_865: u32 = 866;
pub const Z_UTIL_INC_866: u32 = 867;
pub const Z_UTIL_INC_867: u32 = 868;
pub const Z_UTIL_INC_868: u32 = 869;
pub const Z_UTIL_INC_869: u32 = 870;
pub const Z_UTIL_INC_870: u32 = 871;
pub const Z_UTIL_INC_871: u32 = 872;
pub const Z_UTIL_INC_872: u32 = 873;
pub const Z_UTIL_INC_873: u32 = 874;
pub const Z_UTIL_INC_874: u32 = 875;
pub const Z_UTIL_INC_875: u32 = 876;
pub const Z_UTIL_INC_876: u32 = 877;
pub const Z_UTIL_INC_877: u32 = 878;
pub const Z_UTIL_INC_878: u32 = 879;
pub const Z_UTIL_INC_879: u32 = 880;
pub const Z_UTIL_INC_880: u32 = 881;
pub const Z_UTIL_INC_881: u32 = 882;
pub const Z_UTIL_INC_882: u32 = 883;
pub const Z_UTIL_INC_883: u32 = 884;
pub const Z_UTIL_INC_884: u32 = 885;
pub const Z_UTIL_INC_885: u32 = 886;
pub const Z_UTIL_INC_886: u32 = 887;
pub const Z_UTIL_INC_887: u32 = 888;
pub const Z_UTIL_INC_888: u32 = 889;
pub const Z_UTIL_INC_889: u32 = 890;
pub const Z_UTIL_INC_890: u32 = 891;
pub const Z_UTIL_INC_891: u32 = 892;
pub const Z_UTIL_INC_892: u32 = 893;
pub const Z_UTIL_INC_893: u32 = 894;
pub const Z_UTIL_INC_894: u32 = 895;
pub const Z_UTIL_INC_895: u32 = 896;
pub const Z_UTIL_INC_896: u32 = 897;
pub const Z_UTIL_INC_897: u32 = 898;
pub const Z_UTIL_INC_898: u32 = 899;
pub const Z_UTIL_INC_899: u32 = 900;
pub const Z_UTIL_INC_900: u32 = 901;
pub const Z_UTIL_INC_901: u32 = 902;
pub const Z_UTIL_INC_902: u32 = 903;
pub const Z_UTIL_INC_903: u32 = 904;
pub const Z_UTIL_INC_904: u32 = 905;
pub const Z_UTIL_INC_905: u32 = 906;
pub const Z_UTIL_INC_906: u32 = 907;
pub const Z_UTIL_INC_907: u32 = 908;
pub const Z_UTIL_INC_908: u32 = 909;
pub const Z_UTIL_INC_909: u32 = 910;
pub const Z_UTIL_INC_910: u32 = 911;
pub const Z_UTIL_INC_911: u32 = 912;
pub const Z_UTIL_INC_912: u32 = 913;
pub const Z_UTIL_INC_913: u32 = 914;
pub const Z_UTIL_INC_914: u32 = 915;
pub const Z_UTIL_INC_915: u32 = 916;
pub const Z_UTIL_INC_916: u32 = 917;
pub const Z_UTIL_INC_917: u32 = 918;
pub const Z_UTIL_INC_918: u32 = 919;
pub const Z_UTIL_INC_919: u32 = 920;
pub const Z_UTIL_INC_920: u32 = 921;
pub const Z_UTIL_INC_921: u32 = 922;
pub const Z_UTIL_INC_922: u32 = 923;
pub const Z_UTIL_INC_923: u32 = 924;
pub const Z_UTIL_INC_924: u32 = 925;
pub const Z_UTIL_INC_925: u32 = 926;
pub const Z_UTIL_INC_926: u32 = 927;
pub const Z_UTIL_INC_927: u32 = 928;
pub const Z_UTIL_INC_928: u32 = 929;
pub const Z_UTIL_INC_929: u32 = 930;
pub const Z_UTIL_INC_930: u32 = 931;
pub const Z_UTIL_INC_931: u32 = 932;
pub const Z_UTIL_INC_932: u32 = 933;
pub const Z_UTIL_INC_933: u32 = 934;
pub const Z_UTIL_INC_934: u32 = 935;
pub const Z_UTIL_INC_935: u32 = 936;
pub const Z_UTIL_INC_936: u32 = 937;
pub const Z_UTIL_INC_937: u32 = 938;
pub const Z_UTIL_INC_938: u32 = 939;
pub const Z_UTIL_INC_939: u32 = 940;
pub const Z_UTIL_INC_940: u32 = 941;
pub const Z_UTIL_INC_941: u32 = 942;
pub const Z_UTIL_INC_942: u32 = 943;
pub const Z_UTIL_INC_943: u32 = 944;
pub const Z_UTIL_INC_944: u32 = 945;
pub const Z_UTIL_INC_945: u32 = 946;
pub const Z_UTIL_INC_946: u32 = 947;
pub const Z_UTIL_INC_947: u32 = 948;
pub const Z_UTIL_INC_948: u32 = 949;
pub const Z_UTIL_INC_949: u32 = 950;
pub const Z_UTIL_INC_950: u32 = 951;
pub const Z_UTIL_INC_951: u32 = 952;
pub const Z_UTIL_INC_952: u32 = 953;
pub const Z_UTIL_INC_953: u32 = 954;
pub const Z_UTIL_INC_954: u32 = 955;
pub const Z_UTIL_INC_955: u32 = 956;
pub const Z_UTIL_INC_956: u32 = 957;
pub const Z_UTIL_INC_957: u32 = 958;
pub const Z_UTIL_INC_958: u32 = 959;
pub const Z_UTIL_INC_959: u32 = 960;
pub const Z_UTIL_INC_960: u32 = 961;
pub const Z_UTIL_INC_961: u32 = 962;
pub const Z_UTIL_INC_962: u32 = 963;
pub const Z_UTIL_INC_963: u32 = 964;
pub const Z_UTIL_INC_964: u32 = 965;
pub const Z_UTIL_INC_965: u32 = 966;
pub const Z_UTIL_INC_966: u32 = 967;
pub const Z_UTIL_INC_967: u32 = 968;
pub const Z_UTIL_INC_968: u32 = 969;
pub const Z_UTIL_INC_969: u32 = 970;
pub const Z_UTIL_INC_970: u32 = 971;
pub const Z_UTIL_INC_971: u32 = 972;
pub const Z_UTIL_INC_972: u32 = 973;
pub const Z_UTIL_INC_973: u32 = 974;
pub const Z_UTIL_INC_974: u32 = 975;
pub const Z_UTIL_INC_975: u32 = 976;
pub const Z_UTIL_INC_976: u32 = 977;
pub const Z_UTIL_INC_977: u32 = 978;
pub const Z_UTIL_INC_978: u32 = 979;
pub const Z_UTIL_INC_979: u32 = 980;
pub const Z_UTIL_INC_980: u32 = 981;
pub const Z_UTIL_INC_981: u32 = 982;
pub const Z_UTIL_INC_982: u32 = 983;
pub const Z_UTIL_INC_983: u32 = 984;
pub const Z_UTIL_INC_984: u32 = 985;
pub const Z_UTIL_INC_985: u32 = 986;
pub const Z_UTIL_INC_986: u32 = 987;
pub const Z_UTIL_INC_987: u32 = 988;
pub const Z_UTIL_INC_988: u32 = 989;
pub const Z_UTIL_INC_989: u32 = 990;
pub const Z_UTIL_INC_990: u32 = 991;
pub const Z_UTIL_INC_991: u32 = 992;
pub const Z_UTIL_INC_992: u32 = 993;
pub const Z_UTIL_INC_993: u32 = 994;
pub const Z_UTIL_INC_994: u32 = 995;
pub const Z_UTIL_INC_995: u32 = 996;
pub const Z_UTIL_INC_996: u32 = 997;
pub const Z_UTIL_INC_997: u32 = 998;
pub const Z_UTIL_INC_998: u32 = 999;
pub const Z_UTIL_INC_999: u32 = 1000;
pub const Z_UTIL_INC_1000: u32 = 1001;
pub const Z_UTIL_INC_1001: u32 = 1002;
pub const Z_UTIL_INC_1002: u32 = 1003;
pub const Z_UTIL_INC_1003: u32 = 1004;
pub const Z_UTIL_INC_1004: u32 = 1005;
pub const Z_UTIL_INC_1005: u32 = 1006;
pub const Z_UTIL_INC_1006: u32 = 1007;
pub const Z_UTIL_INC_1007: u32 = 1008;
pub const Z_UTIL_INC_1008: u32 = 1009;
pub const Z_UTIL_INC_1009: u32 = 1010;
pub const Z_UTIL_INC_1010: u32 = 1011;
pub const Z_UTIL_INC_1011: u32 = 1012;
pub const Z_UTIL_INC_1012: u32 = 1013;
pub const Z_UTIL_INC_1013: u32 = 1014;
pub const Z_UTIL_INC_1014: u32 = 1015;
pub const Z_UTIL_INC_1015: u32 = 1016;
pub const Z_UTIL_INC_1016: u32 = 1017;
pub const Z_UTIL_INC_1017: u32 = 1018;
pub const Z_UTIL_INC_1018: u32 = 1019;
pub const Z_UTIL_INC_1019: u32 = 1020;
pub const Z_UTIL_INC_1020: u32 = 1021;
pub const Z_UTIL_INC_1021: u32 = 1022;
pub const Z_UTIL_INC_1022: u32 = 1023;
pub const Z_UTIL_INC_1023: u32 = 1024;
pub const Z_UTIL_INC_1024: u32 = 1025;
pub const Z_UTIL_INC_1025: u32 = 1026;
pub const Z_UTIL_INC_1026: u32 = 1027;
pub const Z_UTIL_INC_1027: u32 = 1028;
pub const Z_UTIL_INC_1028: u32 = 1029;
pub const Z_UTIL_INC_1029: u32 = 1030;
pub const Z_UTIL_INC_1030: u32 = 1031;
pub const Z_UTIL_INC_1031: u32 = 1032;
pub const Z_UTIL_INC_1032: u32 = 1033;
pub const Z_UTIL_INC_1033: u32 = 1034;
pub const Z_UTIL_INC_1034: u32 = 1035;
pub const Z_UTIL_INC_1035: u32 = 1036;
pub const Z_UTIL_INC_1036: u32 = 1037;
pub const Z_UTIL_INC_1037: u32 = 1038;
pub const Z_UTIL_INC_1038: u32 = 1039;
pub const Z_UTIL_INC_1039: u32 = 1040;
pub const Z_UTIL_INC_1040: u32 = 1041;
pub const Z_UTIL_INC_1041: u32 = 1042;
pub const Z_UTIL_INC_1042: u32 = 1043;
pub const Z_UTIL_INC_1043: u32 = 1044;
pub const Z_UTIL_INC_1044: u32 = 1045;
pub const Z_UTIL_INC_1045: u32 = 1046;
pub const Z_UTIL_INC_1046: u32 = 1047;
pub const Z_UTIL_INC_1047: u32 = 1048;
pub const Z_UTIL_INC_1048: u32 = 1049;
pub const Z_UTIL_INC_1049: u32 = 1050;
pub const Z_UTIL_INC_1050: u32 = 1051;
pub const Z_UTIL_INC_1051: u32 = 1052;
pub const Z_UTIL_INC_1052: u32 = 1053;
pub const Z_UTIL_INC_1053: u32 = 1054;
pub const Z_UTIL_INC_1054: u32 = 1055;
pub const Z_UTIL_INC_1055: u32 = 1056;
pub const Z_UTIL_INC_1056: u32 = 1057;
pub const Z_UTIL_INC_1057: u32 = 1058;
pub const Z_UTIL_INC_1058: u32 = 1059;
pub const Z_UTIL_INC_1059: u32 = 1060;
pub const Z_UTIL_INC_1060: u32 = 1061;
pub const Z_UTIL_INC_1061: u32 = 1062;
pub const Z_UTIL_INC_1062: u32 = 1063;
pub const Z_UTIL_INC_1063: u32 = 1064;
pub const Z_UTIL_INC_1064: u32 = 1065;
pub const Z_UTIL_INC_1065: u32 = 1066;
pub const Z_UTIL_INC_1066: u32 = 1067;
pub const Z_UTIL_INC_1067: u32 = 1068;
pub const Z_UTIL_INC_1068: u32 = 1069;
pub const Z_UTIL_INC_1069: u32 = 1070;
pub const Z_UTIL_INC_1070: u32 = 1071;
pub const Z_UTIL_INC_1071: u32 = 1072;
pub const Z_UTIL_INC_1072: u32 = 1073;
pub const Z_UTIL_INC_1073: u32 = 1074;
pub const Z_UTIL_INC_1074: u32 = 1075;
pub const Z_UTIL_INC_1075: u32 = 1076;
pub const Z_UTIL_INC_1076: u32 = 1077;
pub const Z_UTIL_INC_1077: u32 = 1078;
pub const Z_UTIL_INC_1078: u32 = 1079;
pub const Z_UTIL_INC_1079: u32 = 1080;
pub const Z_UTIL_INC_1080: u32 = 1081;
pub const Z_UTIL_INC_1081: u32 = 1082;
pub const Z_UTIL_INC_1082: u32 = 1083;
pub const Z_UTIL_INC_1083: u32 = 1084;
pub const Z_UTIL_INC_1084: u32 = 1085;
pub const Z_UTIL_INC_1085: u32 = 1086;
pub const Z_UTIL_INC_1086: u32 = 1087;
pub const Z_UTIL_INC_1087: u32 = 1088;
pub const Z_UTIL_INC_1088: u32 = 1089;
pub const Z_UTIL_INC_1089: u32 = 1090;
pub const Z_UTIL_INC_1090: u32 = 1091;
pub const Z_UTIL_INC_1091: u32 = 1092;
pub const Z_UTIL_INC_1092: u32 = 1093;
pub const Z_UTIL_INC_1093: u32 = 1094;
pub const Z_UTIL_INC_1094: u32 = 1095;
pub const Z_UTIL_INC_1095: u32 = 1096;
pub const Z_UTIL_INC_1096: u32 = 1097;
pub const Z_UTIL_INC_1097: u32 = 1098;
pub const Z_UTIL_INC_1098: u32 = 1099;
pub const Z_UTIL_INC_1099: u32 = 1100;
pub const Z_UTIL_INC_1100: u32 = 1101;
pub const Z_UTIL_INC_1101: u32 = 1102;
pub const Z_UTIL_INC_1102: u32 = 1103;
pub const Z_UTIL_INC_1103: u32 = 1104;
pub const Z_UTIL_INC_1104: u32 = 1105;
pub const Z_UTIL_INC_1105: u32 = 1106;
pub const Z_UTIL_INC_1106: u32 = 1107;
pub const Z_UTIL_INC_1107: u32 = 1108;
pub const Z_UTIL_INC_1108: u32 = 1109;
pub const Z_UTIL_INC_1109: u32 = 1110;
pub const Z_UTIL_INC_1110: u32 = 1111;
pub const Z_UTIL_INC_1111: u32 = 1112;
pub const Z_UTIL_INC_1112: u32 = 1113;
pub const Z_UTIL_INC_1113: u32 = 1114;
pub const Z_UTIL_INC_1114: u32 = 1115;
pub const Z_UTIL_INC_1115: u32 = 1116;
pub const Z_UTIL_INC_1116: u32 = 1117;
pub const Z_UTIL_INC_1117: u32 = 1118;
pub const Z_UTIL_INC_1118: u32 = 1119;
pub const Z_UTIL_INC_1119: u32 = 1120;
pub const Z_UTIL_INC_1120: u32 = 1121;
pub const Z_UTIL_INC_1121: u32 = 1122;
pub const Z_UTIL_INC_1122: u32 = 1123;
pub const Z_UTIL_INC_1123: u32 = 1124;
pub const Z_UTIL_INC_1124: u32 = 1125;
pub const Z_UTIL_INC_1125: u32 = 1126;
pub const Z_UTIL_INC_1126: u32 = 1127;
pub const Z_UTIL_INC_1127: u32 = 1128;
pub const Z_UTIL_INC_1128: u32 = 1129;
pub const Z_UTIL_INC_1129: u32 = 1130;
pub const Z_UTIL_INC_1130: u32 = 1131;
pub const Z_UTIL_INC_1131: u32 = 1132;
pub const Z_UTIL_INC_1132: u32 = 1133;
pub const Z_UTIL_INC_1133: u32 = 1134;
pub const Z_UTIL_INC_1134: u32 = 1135;
pub const Z_UTIL_INC_1135: u32 = 1136;
pub const Z_UTIL_INC_1136: u32 = 1137;
pub const Z_UTIL_INC_1137: u32 = 1138;
pub const Z_UTIL_INC_1138: u32 = 1139;
pub const Z_UTIL_INC_1139: u32 = 1140;
pub const Z_UTIL_INC_1140: u32 = 1141;
pub const Z_UTIL_INC_1141: u32 = 1142;
pub const Z_UTIL_INC_1142: u32 = 1143;
pub const Z_UTIL_INC_1143: u32 = 1144;
pub const Z_UTIL_INC_1144: u32 = 1145;
pub const Z_UTIL_INC_1145: u32 = 1146;
pub const Z_UTIL_INC_1146: u32 = 1147;
pub const Z_UTIL_INC_1147: u32 = 1148;
pub const Z_UTIL_INC_1148: u32 = 1149;
pub const Z_UTIL_INC_1149: u32 = 1150;
pub const Z_UTIL_INC_1150: u32 = 1151;
pub const Z_UTIL_INC_1151: u32 = 1152;
pub const Z_UTIL_INC_1152: u32 = 1153;
pub const Z_UTIL_INC_1153: u32 = 1154;
pub const Z_UTIL_INC_1154: u32 = 1155;
pub const Z_UTIL_INC_1155: u32 = 1156;
pub const Z_UTIL_INC_1156: u32 = 1157;
pub const Z_UTIL_INC_1157: u32 = 1158;
pub const Z_UTIL_INC_1158: u32 = 1159;
pub const Z_UTIL_INC_1159: u32 = 1160;
pub const Z_UTIL_INC_1160: u32 = 1161;
pub const Z_UTIL_INC_1161: u32 = 1162;
pub const Z_UTIL_INC_1162: u32 = 1163;
pub const Z_UTIL_INC_1163: u32 = 1164;
pub const Z_UTIL_INC_1164: u32 = 1165;
pub const Z_UTIL_INC_1165: u32 = 1166;
pub const Z_UTIL_INC_1166: u32 = 1167;
pub const Z_UTIL_INC_1167: u32 = 1168;
pub const Z_UTIL_INC_1168: u32 = 1169;
pub const Z_UTIL_INC_1169: u32 = 1170;
pub const Z_UTIL_INC_1170: u32 = 1171;
pub const Z_UTIL_INC_1171: u32 = 1172;
pub const Z_UTIL_INC_1172: u32 = 1173;
pub const Z_UTIL_INC_1173: u32 = 1174;
pub const Z_UTIL_INC_1174: u32 = 1175;
pub const Z_UTIL_INC_1175: u32 = 1176;
pub const Z_UTIL_INC_1176: u32 = 1177;
pub const Z_UTIL_INC_1177: u32 = 1178;
pub const Z_UTIL_INC_1178: u32 = 1179;
pub const Z_UTIL_INC_1179: u32 = 1180;
pub const Z_UTIL_INC_1180: u32 = 1181;
pub const Z_UTIL_INC_1181: u32 = 1182;
pub const Z_UTIL_INC_1182: u32 = 1183;
pub const Z_UTIL_INC_1183: u32 = 1184;
pub const Z_UTIL_INC_1184: u32 = 1185;
pub const Z_UTIL_INC_1185: u32 = 1186;
pub const Z_UTIL_INC_1186: u32 = 1187;
pub const Z_UTIL_INC_1187: u32 = 1188;
pub const Z_UTIL_INC_1188: u32 = 1189;
pub const Z_UTIL_INC_1189: u32 = 1190;
pub const Z_UTIL_INC_1190: u32 = 1191;
pub const Z_UTIL_INC_1191: u32 = 1192;
pub const Z_UTIL_INC_1192: u32 = 1193;
pub const Z_UTIL_INC_1193: u32 = 1194;
pub const Z_UTIL_INC_1194: u32 = 1195;
pub const Z_UTIL_INC_1195: u32 = 1196;
pub const Z_UTIL_INC_1196: u32 = 1197;
pub const Z_UTIL_INC_1197: u32 = 1198;
pub const Z_UTIL_INC_1198: u32 = 1199;
pub const Z_UTIL_INC_1199: u32 = 1200;
pub const Z_UTIL_INC_1200: u32 = 1201;
pub const Z_UTIL_INC_1201: u32 = 1202;
pub const Z_UTIL_INC_1202: u32 = 1203;
pub const Z_UTIL_INC_1203: u32 = 1204;
pub const Z_UTIL_INC_1204: u32 = 1205;
pub const Z_UTIL_INC_1205: u32 = 1206;
pub const Z_UTIL_INC_1206: u32 = 1207;
pub const Z_UTIL_INC_1207: u32 = 1208;
pub const Z_UTIL_INC_1208: u32 = 1209;
pub const Z_UTIL_INC_1209: u32 = 1210;
pub const Z_UTIL_INC_1210: u32 = 1211;
pub const Z_UTIL_INC_1211: u32 = 1212;
pub const Z_UTIL_INC_1212: u32 = 1213;
pub const Z_UTIL_INC_1213: u32 = 1214;
pub const Z_UTIL_INC_1214: u32 = 1215;
pub const Z_UTIL_INC_1215: u32 = 1216;
pub const Z_UTIL_INC_1216: u32 = 1217;
pub const Z_UTIL_INC_1217: u32 = 1218;
pub const Z_UTIL_INC_1218: u32 = 1219;
pub const Z_UTIL_INC_1219: u32 = 1220;
pub const Z_UTIL_INC_1220: u32 = 1221;
pub const Z_UTIL_INC_1221: u32 = 1222;
pub const Z_UTIL_INC_1222: u32 = 1223;
pub const Z_UTIL_INC_1223: u32 = 1224;
pub const Z_UTIL_INC_1224: u32 = 1225;
pub const Z_UTIL_INC_1225: u32 = 1226;
pub const Z_UTIL_INC_1226: u32 = 1227;
pub const Z_UTIL_INC_1227: u32 = 1228;
pub const Z_UTIL_INC_1228: u32 = 1229;
pub const Z_UTIL_INC_1229: u32 = 1230;
pub const Z_UTIL_INC_1230: u32 = 1231;
pub const Z_UTIL_INC_1231: u32 = 1232;
pub const Z_UTIL_INC_1232: u32 = 1233;
pub const Z_UTIL_INC_1233: u32 = 1234;
pub const Z_UTIL_INC_1234: u32 = 1235;
pub const Z_UTIL_INC_1235: u32 = 1236;
pub const Z_UTIL_INC_1236: u32 = 1237;
pub const Z_UTIL_INC_1237: u32 = 1238;
pub const Z_UTIL_INC_1238: u32 = 1239;
pub const Z_UTIL_INC_1239: u32 = 1240;
pub const Z_UTIL_INC_1240: u32 = 1241;
pub const Z_UTIL_INC_1241: u32 = 1242;
pub const Z_UTIL_INC_1242: u32 = 1243;
pub const Z_UTIL_INC_1243: u32 = 1244;
pub const Z_UTIL_INC_1244: u32 = 1245;
pub const Z_UTIL_INC_1245: u32 = 1246;
pub const Z_UTIL_INC_1246: u32 = 1247;
pub const Z_UTIL_INC_1247: u32 = 1248;
pub const Z_UTIL_INC_1248: u32 = 1249;
pub const Z_UTIL_INC_1249: u32 = 1250;
pub const Z_UTIL_INC_1250: u32 = 1251;
pub const Z_UTIL_INC_1251: u32 = 1252;
pub const Z_UTIL_INC_1252: u32 = 1253;
pub const Z_UTIL_INC_1253: u32 = 1254;
pub const Z_UTIL_INC_1254: u32 = 1255;
pub const Z_UTIL_INC_1255: u32 = 1256;
pub const Z_UTIL_INC_1256: u32 = 1257;
pub const Z_UTIL_INC_1257: u32 = 1258;
pub const Z_UTIL_INC_1258: u32 = 1259;
pub const Z_UTIL_INC_1259: u32 = 1260;
pub const Z_UTIL_INC_1260: u32 = 1261;
pub const Z_UTIL_INC_1261: u32 = 1262;
pub const Z_UTIL_INC_1262: u32 = 1263;
pub const Z_UTIL_INC_1263: u32 = 1264;
pub const Z_UTIL_INC_1264: u32 = 1265;
pub const Z_UTIL_INC_1265: u32 = 1266;
pub const Z_UTIL_INC_1266: u32 = 1267;
pub const Z_UTIL_INC_1267: u32 = 1268;
pub const Z_UTIL_INC_1268: u32 = 1269;
pub const Z_UTIL_INC_1269: u32 = 1270;
pub const Z_UTIL_INC_1270: u32 = 1271;
pub const Z_UTIL_INC_1271: u32 = 1272;
pub const Z_UTIL_INC_1272: u32 = 1273;
pub const Z_UTIL_INC_1273: u32 = 1274;
pub const Z_UTIL_INC_1274: u32 = 1275;
pub const Z_UTIL_INC_1275: u32 = 1276;
pub const Z_UTIL_INC_1276: u32 = 1277;
pub const Z_UTIL_INC_1277: u32 = 1278;
pub const Z_UTIL_INC_1278: u32 = 1279;
pub const Z_UTIL_INC_1279: u32 = 1280;
pub const Z_UTIL_INC_1280: u32 = 1281;
pub const Z_UTIL_INC_1281: u32 = 1282;
pub const Z_UTIL_INC_1282: u32 = 1283;
pub const Z_UTIL_INC_1283: u32 = 1284;
pub const Z_UTIL_INC_1284: u32 = 1285;
pub const Z_UTIL_INC_1285: u32 = 1286;
pub const Z_UTIL_INC_1286: u32 = 1287;
pub const Z_UTIL_INC_1287: u32 = 1288;
pub const Z_UTIL_INC_1288: u32 = 1289;
pub const Z_UTIL_INC_1289: u32 = 1290;
pub const Z_UTIL_INC_1290: u32 = 1291;
pub const Z_UTIL_INC_1291: u32 = 1292;
pub const Z_UTIL_INC_1292: u32 = 1293;
pub const Z_UTIL_INC_1293: u32 = 1294;
pub const Z_UTIL_INC_1294: u32 = 1295;
pub const Z_UTIL_INC_1295: u32 = 1296;
pub const Z_UTIL_INC_1296: u32 = 1297;
pub const Z_UTIL_INC_1297: u32 = 1298;
pub const Z_UTIL_INC_1298: u32 = 1299;
pub const Z_UTIL_INC_1299: u32 = 1300;
pub const Z_UTIL_INC_1300: u32 = 1301;
pub const Z_UTIL_INC_1301: u32 = 1302;
pub const Z_UTIL_INC_1302: u32 = 1303;
pub const Z_UTIL_INC_1303: u32 = 1304;
pub const Z_UTIL_INC_1304: u32 = 1305;
pub const Z_UTIL_INC_1305: u32 = 1306;
pub const Z_UTIL_INC_1306: u32 = 1307;
pub const Z_UTIL_INC_1307: u32 = 1308;
pub const Z_UTIL_INC_1308: u32 = 1309;
pub const Z_UTIL_INC_1309: u32 = 1310;
pub const Z_UTIL_INC_1310: u32 = 1311;
pub const Z_UTIL_INC_1311: u32 = 1312;
pub const Z_UTIL_INC_1312: u32 = 1313;
pub const Z_UTIL_INC_1313: u32 = 1314;
pub const Z_UTIL_INC_1314: u32 = 1315;
pub const Z_UTIL_INC_1315: u32 = 1316;
pub const Z_UTIL_INC_1316: u32 = 1317;
pub const Z_UTIL_INC_1317: u32 = 1318;
pub const Z_UTIL_INC_1318: u32 = 1319;
pub const Z_UTIL_INC_1319: u32 = 1320;
pub const Z_UTIL_INC_1320: u32 = 1321;
pub const Z_UTIL_INC_1321: u32 = 1322;
pub const Z_UTIL_INC_1322: u32 = 1323;
pub const Z_UTIL_INC_1323: u32 = 1324;
pub const Z_UTIL_INC_1324: u32 = 1325;
pub const Z_UTIL_INC_1325: u32 = 1326;
pub const Z_UTIL_INC_1326: u32 = 1327;
pub const Z_UTIL_INC_1327: u32 = 1328;
pub const Z_UTIL_INC_1328: u32 = 1329;
pub const Z_UTIL_INC_1329: u32 = 1330;
pub const Z_UTIL_INC_1330: u32 = 1331;
pub const Z_UTIL_INC_1331: u32 = 1332;
pub const Z_UTIL_INC_1332: u32 = 1333;
pub const Z_UTIL_INC_1333: u32 = 1334;
pub const Z_UTIL_INC_1334: u32 = 1335;
pub const Z_UTIL_INC_1335: u32 = 1336;
pub const Z_UTIL_INC_1336: u32 = 1337;
pub const Z_UTIL_INC_1337: u32 = 1338;
pub const Z_UTIL_INC_1338: u32 = 1339;
pub const Z_UTIL_INC_1339: u32 = 1340;
pub const Z_UTIL_INC_1340: u32 = 1341;
pub const Z_UTIL_INC_1341: u32 = 1342;
pub const Z_UTIL_INC_1342: u32 = 1343;
pub const Z_UTIL_INC_1343: u32 = 1344;
pub const Z_UTIL_INC_1344: u32 = 1345;
pub const Z_UTIL_INC_1345: u32 = 1346;
pub const Z_UTIL_INC_1346: u32 = 1347;
pub const Z_UTIL_INC_1347: u32 = 1348;
pub const Z_UTIL_INC_1348: u32 = 1349;
pub const Z_UTIL_INC_1349: u32 = 1350;
pub const Z_UTIL_INC_1350: u32 = 1351;
pub const Z_UTIL_INC_1351: u32 = 1352;
pub const Z_UTIL_INC_1352: u32 = 1353;
pub const Z_UTIL_INC_1353: u32 = 1354;
pub const Z_UTIL_INC_1354: u32 = 1355;
pub const Z_UTIL_INC_1355: u32 = 1356;
pub const Z_UTIL_INC_1356: u32 = 1357;
pub const Z_UTIL_INC_1357: u32 = 1358;
pub const Z_UTIL_INC_1358: u32 = 1359;
pub const Z_UTIL_INC_1359: u32 = 1360;
pub const Z_UTIL_INC_1360: u32 = 1361;
pub const Z_UTIL_INC_1361: u32 = 1362;
pub const Z_UTIL_INC_1362: u32 = 1363;
pub const Z_UTIL_INC_1363: u32 = 1364;
pub const Z_UTIL_INC_1364: u32 = 1365;
pub const Z_UTIL_INC_1365: u32 = 1366;
pub const Z_UTIL_INC_1366: u32 = 1367;
pub const Z_UTIL_INC_1367: u32 = 1368;
pub const Z_UTIL_INC_1368: u32 = 1369;
pub const Z_UTIL_INC_1369: u32 = 1370;
pub const Z_UTIL_INC_1370: u32 = 1371;
pub const Z_UTIL_INC_1371: u32 = 1372;
pub const Z_UTIL_INC_1372: u32 = 1373;
pub const Z_UTIL_INC_1373: u32 = 1374;
pub const Z_UTIL_INC_1374: u32 = 1375;
pub const Z_UTIL_INC_1375: u32 = 1376;
pub const Z_UTIL_INC_1376: u32 = 1377;
pub const Z_UTIL_INC_1377: u32 = 1378;
pub const Z_UTIL_INC_1378: u32 = 1379;
pub const Z_UTIL_INC_1379: u32 = 1380;
pub const Z_UTIL_INC_1380: u32 = 1381;
pub const Z_UTIL_INC_1381: u32 = 1382;
pub const Z_UTIL_INC_1382: u32 = 1383;
pub const Z_UTIL_INC_1383: u32 = 1384;
pub const Z_UTIL_INC_1384: u32 = 1385;
pub const Z_UTIL_INC_1385: u32 = 1386;
pub const Z_UTIL_INC_1386: u32 = 1387;
pub const Z_UTIL_INC_1387: u32 = 1388;
pub const Z_UTIL_INC_1388: u32 = 1389;
pub const Z_UTIL_INC_1389: u32 = 1390;
pub const Z_UTIL_INC_1390: u32 = 1391;
pub const Z_UTIL_INC_1391: u32 = 1392;
pub const Z_UTIL_INC_1392: u32 = 1393;
pub const Z_UTIL_INC_1393: u32 = 1394;
pub const Z_UTIL_INC_1394: u32 = 1395;
pub const Z_UTIL_INC_1395: u32 = 1396;
pub const Z_UTIL_INC_1396: u32 = 1397;
pub const Z_UTIL_INC_1397: u32 = 1398;
pub const Z_UTIL_INC_1398: u32 = 1399;
pub const Z_UTIL_INC_1399: u32 = 1400;
pub const Z_UTIL_INC_1400: u32 = 1401;
pub const Z_UTIL_INC_1401: u32 = 1402;
pub const Z_UTIL_INC_1402: u32 = 1403;
pub const Z_UTIL_INC_1403: u32 = 1404;
pub const Z_UTIL_INC_1404: u32 = 1405;
pub const Z_UTIL_INC_1405: u32 = 1406;
pub const Z_UTIL_INC_1406: u32 = 1407;
pub const Z_UTIL_INC_1407: u32 = 1408;
pub const Z_UTIL_INC_1408: u32 = 1409;
pub const Z_UTIL_INC_1409: u32 = 1410;
pub const Z_UTIL_INC_1410: u32 = 1411;
pub const Z_UTIL_INC_1411: u32 = 1412;
pub const Z_UTIL_INC_1412: u32 = 1413;
pub const Z_UTIL_INC_1413: u32 = 1414;
pub const Z_UTIL_INC_1414: u32 = 1415;
pub const Z_UTIL_INC_1415: u32 = 1416;
pub const Z_UTIL_INC_1416: u32 = 1417;
pub const Z_UTIL_INC_1417: u32 = 1418;
pub const Z_UTIL_INC_1418: u32 = 1419;
pub const Z_UTIL_INC_1419: u32 = 1420;
pub const Z_UTIL_INC_1420: u32 = 1421;
pub const Z_UTIL_INC_1421: u32 = 1422;
pub const Z_UTIL_INC_1422: u32 = 1423;
pub const Z_UTIL_INC_1423: u32 = 1424;
pub const Z_UTIL_INC_1424: u32 = 1425;
pub const Z_UTIL_INC_1425: u32 = 1426;
pub const Z_UTIL_INC_1426: u32 = 1427;
pub const Z_UTIL_INC_1427: u32 = 1428;
pub const Z_UTIL_INC_1428: u32 = 1429;
pub const Z_UTIL_INC_1429: u32 = 1430;
pub const Z_UTIL_INC_1430: u32 = 1431;
pub const Z_UTIL_INC_1431: u32 = 1432;
pub const Z_UTIL_INC_1432: u32 = 1433;
pub const Z_UTIL_INC_1433: u32 = 1434;
pub const Z_UTIL_INC_1434: u32 = 1435;
pub const Z_UTIL_INC_1435: u32 = 1436;
pub const Z_UTIL_INC_1436: u32 = 1437;
pub const Z_UTIL_INC_1437: u32 = 1438;
pub const Z_UTIL_INC_1438: u32 = 1439;
pub const Z_UTIL_INC_1439: u32 = 1440;
pub const Z_UTIL_INC_1440: u32 = 1441;
pub const Z_UTIL_INC_1441: u32 = 1442;
pub const Z_UTIL_INC_1442: u32 = 1443;
pub const Z_UTIL_INC_1443: u32 = 1444;
pub const Z_UTIL_INC_1444: u32 = 1445;
pub const Z_UTIL_INC_1445: u32 = 1446;
pub const Z_UTIL_INC_1446: u32 = 1447;
pub const Z_UTIL_INC_1447: u32 = 1448;
pub const Z_UTIL_INC_1448: u32 = 1449;
pub const Z_UTIL_INC_1449: u32 = 1450;
pub const Z_UTIL_INC_1450: u32 = 1451;
pub const Z_UTIL_INC_1451: u32 = 1452;
pub const Z_UTIL_INC_1452: u32 = 1453;
pub const Z_UTIL_INC_1453: u32 = 1454;
pub const Z_UTIL_INC_1454: u32 = 1455;
pub const Z_UTIL_INC_1455: u32 = 1456;
pub const Z_UTIL_INC_1456: u32 = 1457;
pub const Z_UTIL_INC_1457: u32 = 1458;
pub const Z_UTIL_INC_1458: u32 = 1459;
pub const Z_UTIL_INC_1459: u32 = 1460;
pub const Z_UTIL_INC_1460: u32 = 1461;
pub const Z_UTIL_INC_1461: u32 = 1462;
pub const Z_UTIL_INC_1462: u32 = 1463;
pub const Z_UTIL_INC_1463: u32 = 1464;
pub const Z_UTIL_INC_1464: u32 = 1465;
pub const Z_UTIL_INC_1465: u32 = 1466;
pub const Z_UTIL_INC_1466: u32 = 1467;
pub const Z_UTIL_INC_1467: u32 = 1468;
pub const Z_UTIL_INC_1468: u32 = 1469;
pub const Z_UTIL_INC_1469: u32 = 1470;
pub const Z_UTIL_INC_1470: u32 = 1471;
pub const Z_UTIL_INC_1471: u32 = 1472;
pub const Z_UTIL_INC_1472: u32 = 1473;
pub const Z_UTIL_INC_1473: u32 = 1474;
pub const Z_UTIL_INC_1474: u32 = 1475;
pub const Z_UTIL_INC_1475: u32 = 1476;
pub const Z_UTIL_INC_1476: u32 = 1477;
pub const Z_UTIL_INC_1477: u32 = 1478;
pub const Z_UTIL_INC_1478: u32 = 1479;
pub const Z_UTIL_INC_1479: u32 = 1480;
pub const Z_UTIL_INC_1480: u32 = 1481;
pub const Z_UTIL_INC_1481: u32 = 1482;
pub const Z_UTIL_INC_1482: u32 = 1483;
pub const Z_UTIL_INC_1483: u32 = 1484;
pub const Z_UTIL_INC_1484: u32 = 1485;
pub const Z_UTIL_INC_1485: u32 = 1486;
pub const Z_UTIL_INC_1486: u32 = 1487;
pub const Z_UTIL_INC_1487: u32 = 1488;
pub const Z_UTIL_INC_1488: u32 = 1489;
pub const Z_UTIL_INC_1489: u32 = 1490;
pub const Z_UTIL_INC_1490: u32 = 1491;
pub const Z_UTIL_INC_1491: u32 = 1492;
pub const Z_UTIL_INC_1492: u32 = 1493;
pub const Z_UTIL_INC_1493: u32 = 1494;
pub const Z_UTIL_INC_1494: u32 = 1495;
pub const Z_UTIL_INC_1495: u32 = 1496;
pub const Z_UTIL_INC_1496: u32 = 1497;
pub const Z_UTIL_INC_1497: u32 = 1498;
pub const Z_UTIL_INC_1498: u32 = 1499;
pub const Z_UTIL_INC_1499: u32 = 1500;
pub const Z_UTIL_INC_1500: u32 = 1501;
pub const Z_UTIL_INC_1501: u32 = 1502;
pub const Z_UTIL_INC_1502: u32 = 1503;
pub const Z_UTIL_INC_1503: u32 = 1504;
pub const Z_UTIL_INC_1504: u32 = 1505;
pub const Z_UTIL_INC_1505: u32 = 1506;
pub const Z_UTIL_INC_1506: u32 = 1507;
pub const Z_UTIL_INC_1507: u32 = 1508;
pub const Z_UTIL_INC_1508: u32 = 1509;
pub const Z_UTIL_INC_1509: u32 = 1510;
pub const Z_UTIL_INC_1510: u32 = 1511;
pub const Z_UTIL_INC_1511: u32 = 1512;
pub const Z_UTIL_INC_1512: u32 = 1513;
pub const Z_UTIL_INC_1513: u32 = 1514;
pub const Z_UTIL_INC_1514: u32 = 1515;
pub const Z_UTIL_INC_1515: u32 = 1516;
pub const Z_UTIL_INC_1516: u32 = 1517;
pub const Z_UTIL_INC_1517: u32 = 1518;
pub const Z_UTIL_INC_1518: u32 = 1519;
pub const Z_UTIL_INC_1519: u32 = 1520;
pub const Z_UTIL_INC_1520: u32 = 1521;
pub const Z_UTIL_INC_1521: u32 = 1522;
pub const Z_UTIL_INC_1522: u32 = 1523;
pub const Z_UTIL_INC_1523: u32 = 1524;
pub const Z_UTIL_INC_1524: u32 = 1525;
pub const Z_UTIL_INC_1525: u32 = 1526;
pub const Z_UTIL_INC_1526: u32 = 1527;
pub const Z_UTIL_INC_1527: u32 = 1528;
pub const Z_UTIL_INC_1528: u32 = 1529;
pub const Z_UTIL_INC_1529: u32 = 1530;
pub const Z_UTIL_INC_1530: u32 = 1531;
pub const Z_UTIL_INC_1531: u32 = 1532;
pub const Z_UTIL_INC_1532: u32 = 1533;
pub const Z_UTIL_INC_1533: u32 = 1534;
pub const Z_UTIL_INC_1534: u32 = 1535;
pub const Z_UTIL_INC_1535: u32 = 1536;
pub const Z_UTIL_INC_1536: u32 = 1537;
pub const Z_UTIL_INC_1537: u32 = 1538;
pub const Z_UTIL_INC_1538: u32 = 1539;
pub const Z_UTIL_INC_1539: u32 = 1540;
pub const Z_UTIL_INC_1540: u32 = 1541;
pub const Z_UTIL_INC_1541: u32 = 1542;
pub const Z_UTIL_INC_1542: u32 = 1543;
pub const Z_UTIL_INC_1543: u32 = 1544;
pub const Z_UTIL_INC_1544: u32 = 1545;
pub const Z_UTIL_INC_1545: u32 = 1546;
pub const Z_UTIL_INC_1546: u32 = 1547;
pub const Z_UTIL_INC_1547: u32 = 1548;
pub const Z_UTIL_INC_1548: u32 = 1549;
pub const Z_UTIL_INC_1549: u32 = 1550;
pub const Z_UTIL_INC_1550: u32 = 1551;
pub const Z_UTIL_INC_1551: u32 = 1552;
pub const Z_UTIL_INC_1552: u32 = 1553;
pub const Z_UTIL_INC_1553: u32 = 1554;
pub const Z_UTIL_INC_1554: u32 = 1555;
pub const Z_UTIL_INC_1555: u32 = 1556;
pub const Z_UTIL_INC_1556: u32 = 1557;
pub const Z_UTIL_INC_1557: u32 = 1558;
pub const Z_UTIL_INC_1558: u32 = 1559;
pub const Z_UTIL_INC_1559: u32 = 1560;
pub const Z_UTIL_INC_1560: u32 = 1561;
pub const Z_UTIL_INC_1561: u32 = 1562;
pub const Z_UTIL_INC_1562: u32 = 1563;
pub const Z_UTIL_INC_1563: u32 = 1564;
pub const Z_UTIL_INC_1564: u32 = 1565;
pub const Z_UTIL_INC_1565: u32 = 1566;
pub const Z_UTIL_INC_1566: u32 = 1567;
pub const Z_UTIL_INC_1567: u32 = 1568;
pub const Z_UTIL_INC_1568: u32 = 1569;
pub const Z_UTIL_INC_1569: u32 = 1570;
pub const Z_UTIL_INC_1570: u32 = 1571;
pub const Z_UTIL_INC_1571: u32 = 1572;
pub const Z_UTIL_INC_1572: u32 = 1573;
pub const Z_UTIL_INC_1573: u32 = 1574;
pub const Z_UTIL_INC_1574: u32 = 1575;
pub const Z_UTIL_INC_1575: u32 = 1576;
pub const Z_UTIL_INC_1576: u32 = 1577;
pub const Z_UTIL_INC_1577: u32 = 1578;
pub const Z_UTIL_INC_1578: u32 = 1579;
pub const Z_UTIL_INC_1579: u32 = 1580;
pub const Z_UTIL_INC_1580: u32 = 1581;
pub const Z_UTIL_INC_1581: u32 = 1582;
pub const Z_UTIL_INC_1582: u32 = 1583;
pub const Z_UTIL_INC_1583: u32 = 1584;
pub const Z_UTIL_INC_1584: u32 = 1585;
pub const Z_UTIL_INC_1585: u32 = 1586;
pub const Z_UTIL_INC_1586: u32 = 1587;
pub const Z_UTIL_INC_1587: u32 = 1588;
pub const Z_UTIL_INC_1588: u32 = 1589;
pub const Z_UTIL_INC_1589: u32 = 1590;
pub const Z_UTIL_INC_1590: u32 = 1591;
pub const Z_UTIL_INC_1591: u32 = 1592;
pub const Z_UTIL_INC_1592: u32 = 1593;
pub const Z_UTIL_INC_1593: u32 = 1594;
pub const Z_UTIL_INC_1594: u32 = 1595;
pub const Z_UTIL_INC_1595: u32 = 1596;
pub const Z_UTIL_INC_1596: u32 = 1597;
pub const Z_UTIL_INC_1597: u32 = 1598;
pub const Z_UTIL_INC_1598: u32 = 1599;
pub const Z_UTIL_INC_1599: u32 = 1600;
pub const Z_UTIL_INC_1600: u32 = 1601;
pub const Z_UTIL_INC_1601: u32 = 1602;
pub const Z_UTIL_INC_1602: u32 = 1603;
pub const Z_UTIL_INC_1603: u32 = 1604;
pub const Z_UTIL_INC_1604: u32 = 1605;
pub const Z_UTIL_INC_1605: u32 = 1606;
pub const Z_UTIL_INC_1606: u32 = 1607;
pub const Z_UTIL_INC_1607: u32 = 1608;
pub const Z_UTIL_INC_1608: u32 = 1609;
pub const Z_UTIL_INC_1609: u32 = 1610;
pub const Z_UTIL_INC_1610: u32 = 1611;
pub const Z_UTIL_INC_1611: u32 = 1612;
pub const Z_UTIL_INC_1612: u32 = 1613;
pub const Z_UTIL_INC_1613: u32 = 1614;
pub const Z_UTIL_INC_1614: u32 = 1615;
pub const Z_UTIL_INC_1615: u32 = 1616;
pub const Z_UTIL_INC_1616: u32 = 1617;
pub const Z_UTIL_INC_1617: u32 = 1618;
pub const Z_UTIL_INC_1618: u32 = 1619;
pub const Z_UTIL_INC_1619: u32 = 1620;
pub const Z_UTIL_INC_1620: u32 = 1621;
pub const Z_UTIL_INC_1621: u32 = 1622;
pub const Z_UTIL_INC_1622: u32 = 1623;
pub const Z_UTIL_INC_1623: u32 = 1624;
pub const Z_UTIL_INC_1624: u32 = 1625;
pub const Z_UTIL_INC_1625: u32 = 1626;
pub const Z_UTIL_INC_1626: u32 = 1627;
pub const Z_UTIL_INC_1627: u32 = 1628;
pub const Z_UTIL_INC_1628: u32 = 1629;
pub const Z_UTIL_INC_1629: u32 = 1630;
pub const Z_UTIL_INC_1630: u32 = 1631;
pub const Z_UTIL_INC_1631: u32 = 1632;
pub const Z_UTIL_INC_1632: u32 = 1633;
pub const Z_UTIL_INC_1633: u32 = 1634;
pub const Z_UTIL_INC_1634: u32 = 1635;
pub const Z_UTIL_INC_1635: u32 = 1636;
pub const Z_UTIL_INC_1636: u32 = 1637;
pub const Z_UTIL_INC_1637: u32 = 1638;
pub const Z_UTIL_INC_1638: u32 = 1639;
pub const Z_UTIL_INC_1639: u32 = 1640;
pub const Z_UTIL_INC_1640: u32 = 1641;
pub const Z_UTIL_INC_1641: u32 = 1642;
pub const Z_UTIL_INC_1642: u32 = 1643;
pub const Z_UTIL_INC_1643: u32 = 1644;
pub const Z_UTIL_INC_1644: u32 = 1645;
pub const Z_UTIL_INC_1645: u32 = 1646;
pub const Z_UTIL_INC_1646: u32 = 1647;
pub const Z_UTIL_INC_1647: u32 = 1648;
pub const Z_UTIL_INC_1648: u32 = 1649;
pub const Z_UTIL_INC_1649: u32 = 1650;
pub const Z_UTIL_INC_1650: u32 = 1651;
pub const Z_UTIL_INC_1651: u32 = 1652;
pub const Z_UTIL_INC_1652: u32 = 1653;
pub const Z_UTIL_INC_1653: u32 = 1654;
pub const Z_UTIL_INC_1654: u32 = 1655;
pub const Z_UTIL_INC_1655: u32 = 1656;
pub const Z_UTIL_INC_1656: u32 = 1657;
pub const Z_UTIL_INC_1657: u32 = 1658;
pub const Z_UTIL_INC_1658: u32 = 1659;
pub const Z_UTIL_INC_1659: u32 = 1660;
pub const Z_UTIL_INC_1660: u32 = 1661;
pub const Z_UTIL_INC_1661: u32 = 1662;
pub const Z_UTIL_INC_1662: u32 = 1663;
pub const Z_UTIL_INC_1663: u32 = 1664;
pub const Z_UTIL_INC_1664: u32 = 1665;
pub const Z_UTIL_INC_1665: u32 = 1666;
pub const Z_UTIL_INC_1666: u32 = 1667;
pub const Z_UTIL_INC_1667: u32 = 1668;
pub const Z_UTIL_INC_1668: u32 = 1669;
pub const Z_UTIL_INC_1669: u32 = 1670;
pub const Z_UTIL_INC_1670: u32 = 1671;
pub const Z_UTIL_INC_1671: u32 = 1672;
pub const Z_UTIL_INC_1672: u32 = 1673;
pub const Z_UTIL_INC_1673: u32 = 1674;
pub const Z_UTIL_INC_1674: u32 = 1675;
pub const Z_UTIL_INC_1675: u32 = 1676;
pub const Z_UTIL_INC_1676: u32 = 1677;
pub const Z_UTIL_INC_1677: u32 = 1678;
pub const Z_UTIL_INC_1678: u32 = 1679;
pub const Z_UTIL_INC_1679: u32 = 1680;
pub const Z_UTIL_INC_1680: u32 = 1681;
pub const Z_UTIL_INC_1681: u32 = 1682;
pub const Z_UTIL_INC_1682: u32 = 1683;
pub const Z_UTIL_INC_1683: u32 = 1684;
pub const Z_UTIL_INC_1684: u32 = 1685;
pub const Z_UTIL_INC_1685: u32 = 1686;
pub const Z_UTIL_INC_1686: u32 = 1687;
pub const Z_UTIL_INC_1687: u32 = 1688;
pub const Z_UTIL_INC_1688: u32 = 1689;
pub const Z_UTIL_INC_1689: u32 = 1690;
pub const Z_UTIL_INC_1690: u32 = 1691;
pub const Z_UTIL_INC_1691: u32 = 1692;
pub const Z_UTIL_INC_1692: u32 = 1693;
pub const Z_UTIL_INC_1693: u32 = 1694;
pub const Z_UTIL_INC_1694: u32 = 1695;
pub const Z_UTIL_INC_1695: u32 = 1696;
pub const Z_UTIL_INC_1696: u32 = 1697;
pub const Z_UTIL_INC_1697: u32 = 1698;
pub const Z_UTIL_INC_1698: u32 = 1699;
pub const Z_UTIL_INC_1699: u32 = 1700;
pub const Z_UTIL_INC_1700: u32 = 1701;
pub const Z_UTIL_INC_1701: u32 = 1702;
pub const Z_UTIL_INC_1702: u32 = 1703;
pub const Z_UTIL_INC_1703: u32 = 1704;
pub const Z_UTIL_INC_1704: u32 = 1705;
pub const Z_UTIL_INC_1705: u32 = 1706;
pub const Z_UTIL_INC_1706: u32 = 1707;
pub const Z_UTIL_INC_1707: u32 = 1708;
pub const Z_UTIL_INC_1708: u32 = 1709;
pub const Z_UTIL_INC_1709: u32 = 1710;
pub const Z_UTIL_INC_1710: u32 = 1711;
pub const Z_UTIL_INC_1711: u32 = 1712;
pub const Z_UTIL_INC_1712: u32 = 1713;
pub const Z_UTIL_INC_1713: u32 = 1714;
pub const Z_UTIL_INC_1714: u32 = 1715;
pub const Z_UTIL_INC_1715: u32 = 1716;
pub const Z_UTIL_INC_1716: u32 = 1717;
pub const Z_UTIL_INC_1717: u32 = 1718;
pub const Z_UTIL_INC_1718: u32 = 1719;
pub const Z_UTIL_INC_1719: u32 = 1720;
pub const Z_UTIL_INC_1720: u32 = 1721;
pub const Z_UTIL_INC_1721: u32 = 1722;
pub const Z_UTIL_INC_1722: u32 = 1723;
pub const Z_UTIL_INC_1723: u32 = 1724;
pub const Z_UTIL_INC_1724: u32 = 1725;
pub const Z_UTIL_INC_1725: u32 = 1726;
pub const Z_UTIL_INC_1726: u32 = 1727;
pub const Z_UTIL_INC_1727: u32 = 1728;
pub const Z_UTIL_INC_1728: u32 = 1729;
pub const Z_UTIL_INC_1729: u32 = 1730;
pub const Z_UTIL_INC_1730: u32 = 1731;
pub const Z_UTIL_INC_1731: u32 = 1732;
pub const Z_UTIL_INC_1732: u32 = 1733;
pub const Z_UTIL_INC_1733: u32 = 1734;
pub const Z_UTIL_INC_1734: u32 = 1735;
pub const Z_UTIL_INC_1735: u32 = 1736;
pub const Z_UTIL_INC_1736: u32 = 1737;
pub const Z_UTIL_INC_1737: u32 = 1738;
pub const Z_UTIL_INC_1738: u32 = 1739;
pub const Z_UTIL_INC_1739: u32 = 1740;
pub const Z_UTIL_INC_1740: u32 = 1741;
pub const Z_UTIL_INC_1741: u32 = 1742;
pub const Z_UTIL_INC_1742: u32 = 1743;
pub const Z_UTIL_INC_1743: u32 = 1744;
pub const Z_UTIL_INC_1744: u32 = 1745;
pub const Z_UTIL_INC_1745: u32 = 1746;
pub const Z_UTIL_INC_1746: u32 = 1747;
pub const Z_UTIL_INC_1747: u32 = 1748;
pub const Z_UTIL_INC_1748: u32 = 1749;
pub const Z_UTIL_INC_1749: u32 = 1750;
pub const Z_UTIL_INC_1750: u32 = 1751;
pub const Z_UTIL_INC_1751: u32 = 1752;
pub const Z_UTIL_INC_1752: u32 = 1753;
pub const Z_UTIL_INC_1753: u32 = 1754;
pub const Z_UTIL_INC_1754: u32 = 1755;
pub const Z_UTIL_INC_1755: u32 = 1756;
pub const Z_UTIL_INC_1756: u32 = 1757;
pub const Z_UTIL_INC_1757: u32 = 1758;
pub const Z_UTIL_INC_1758: u32 = 1759;
pub const Z_UTIL_INC_1759: u32 = 1760;
pub const Z_UTIL_INC_1760: u32 = 1761;
pub const Z_UTIL_INC_1761: u32 = 1762;
pub const Z_UTIL_INC_1762: u32 = 1763;
pub const Z_UTIL_INC_1763: u32 = 1764;
pub const Z_UTIL_INC_1764: u32 = 1765;
pub const Z_UTIL_INC_1765: u32 = 1766;
pub const Z_UTIL_INC_1766: u32 = 1767;
pub const Z_UTIL_INC_1767: u32 = 1768;
pub const Z_UTIL_INC_1768: u32 = 1769;
pub const Z_UTIL_INC_1769: u32 = 1770;
pub const Z_UTIL_INC_1770: u32 = 1771;
pub const Z_UTIL_INC_1771: u32 = 1772;
pub const Z_UTIL_INC_1772: u32 = 1773;
pub const Z_UTIL_INC_1773: u32 = 1774;
pub const Z_UTIL_INC_1774: u32 = 1775;
pub const Z_UTIL_INC_1775: u32 = 1776;
pub const Z_UTIL_INC_1776: u32 = 1777;
pub const Z_UTIL_INC_1777: u32 = 1778;
pub const Z_UTIL_INC_1778: u32 = 1779;
pub const Z_UTIL_INC_1779: u32 = 1780;
pub const Z_UTIL_INC_1780: u32 = 1781;
pub const Z_UTIL_INC_1781: u32 = 1782;
pub const Z_UTIL_INC_1782: u32 = 1783;
pub const Z_UTIL_INC_1783: u32 = 1784;
pub const Z_UTIL_INC_1784: u32 = 1785;
pub const Z_UTIL_INC_1785: u32 = 1786;
pub const Z_UTIL_INC_1786: u32 = 1787;
pub const Z_UTIL_INC_1787: u32 = 1788;
pub const Z_UTIL_INC_1788: u32 = 1789;
pub const Z_UTIL_INC_1789: u32 = 1790;
pub const Z_UTIL_INC_1790: u32 = 1791;
pub const Z_UTIL_INC_1791: u32 = 1792;
pub const Z_UTIL_INC_1792: u32 = 1793;
pub const Z_UTIL_INC_1793: u32 = 1794;
pub const Z_UTIL_INC_1794: u32 = 1795;
pub const Z_UTIL_INC_1795: u32 = 1796;
pub const Z_UTIL_INC_1796: u32 = 1797;
pub const Z_UTIL_INC_1797: u32 = 1798;
pub const Z_UTIL_INC_1798: u32 = 1799;
pub const Z_UTIL_INC_1799: u32 = 1800;
pub const Z_UTIL_INC_1800: u32 = 1801;
pub const Z_UTIL_INC_1801: u32 = 1802;
pub const Z_UTIL_INC_1802: u32 = 1803;
pub const Z_UTIL_INC_1803: u32 = 1804;
pub const Z_UTIL_INC_1804: u32 = 1805;
pub const Z_UTIL_INC_1805: u32 = 1806;
pub const Z_UTIL_INC_1806: u32 = 1807;
pub const Z_UTIL_INC_1807: u32 = 1808;
pub const Z_UTIL_INC_1808: u32 = 1809;
pub const Z_UTIL_INC_1809: u32 = 1810;
pub const Z_UTIL_INC_1810: u32 = 1811;
pub const Z_UTIL_INC_1811: u32 = 1812;
pub const Z_UTIL_INC_1812: u32 = 1813;
pub const Z_UTIL_INC_1813: u32 = 1814;
pub const Z_UTIL_INC_1814: u32 = 1815;
pub const Z_UTIL_INC_1815: u32 = 1816;
pub const Z_UTIL_INC_1816: u32 = 1817;
pub const Z_UTIL_INC_1817: u32 = 1818;
pub const Z_UTIL_INC_1818: u32 = 1819;
pub const Z_UTIL_INC_1819: u32 = 1820;
pub const Z_UTIL_INC_1820: u32 = 1821;
pub const Z_UTIL_INC_1821: u32 = 1822;
pub const Z_UTIL_INC_1822: u32 = 1823;
pub const Z_UTIL_INC_1823: u32 = 1824;
pub const Z_UTIL_INC_1824: u32 = 1825;
pub const Z_UTIL_INC_1825: u32 = 1826;
pub const Z_UTIL_INC_1826: u32 = 1827;
pub const Z_UTIL_INC_1827: u32 = 1828;
pub const Z_UTIL_INC_1828: u32 = 1829;
pub const Z_UTIL_INC_1829: u32 = 1830;
pub const Z_UTIL_INC_1830: u32 = 1831;
pub const Z_UTIL_INC_1831: u32 = 1832;
pub const Z_UTIL_INC_1832: u32 = 1833;
pub const Z_UTIL_INC_1833: u32 = 1834;
pub const Z_UTIL_INC_1834: u32 = 1835;
pub const Z_UTIL_INC_1835: u32 = 1836;
pub const Z_UTIL_INC_1836: u32 = 1837;
pub const Z_UTIL_INC_1837: u32 = 1838;
pub const Z_UTIL_INC_1838: u32 = 1839;
pub const Z_UTIL_INC_1839: u32 = 1840;
pub const Z_UTIL_INC_1840: u32 = 1841;
pub const Z_UTIL_INC_1841: u32 = 1842;
pub const Z_UTIL_INC_1842: u32 = 1843;
pub const Z_UTIL_INC_1843: u32 = 1844;
pub const Z_UTIL_INC_1844: u32 = 1845;
pub const Z_UTIL_INC_1845: u32 = 1846;
pub const Z_UTIL_INC_1846: u32 = 1847;
pub const Z_UTIL_INC_1847: u32 = 1848;
pub const Z_UTIL_INC_1848: u32 = 1849;
pub const Z_UTIL_INC_1849: u32 = 1850;
pub const Z_UTIL_INC_1850: u32 = 1851;
pub const Z_UTIL_INC_1851: u32 = 1852;
pub const Z_UTIL_INC_1852: u32 = 1853;
pub const Z_UTIL_INC_1853: u32 = 1854;
pub const Z_UTIL_INC_1854: u32 = 1855;
pub const Z_UTIL_INC_1855: u32 = 1856;
pub const Z_UTIL_INC_1856: u32 = 1857;
pub const Z_UTIL_INC_1857: u32 = 1858;
pub const Z_UTIL_INC_1858: u32 = 1859;
pub const Z_UTIL_INC_1859: u32 = 1860;
pub const Z_UTIL_INC_1860: u32 = 1861;
pub const Z_UTIL_INC_1861: u32 = 1862;
pub const Z_UTIL_INC_1862: u32 = 1863;
pub const Z_UTIL_INC_1863: u32 = 1864;
pub const Z_UTIL_INC_1864: u32 = 1865;
pub const Z_UTIL_INC_1865: u32 = 1866;
pub const Z_UTIL_INC_1866: u32 = 1867;
pub const Z_UTIL_INC_1867: u32 = 1868;
pub const Z_UTIL_INC_1868: u32 = 1869;
pub const Z_UTIL_INC_1869: u32 = 1870;
pub const Z_UTIL_INC_1870: u32 = 1871;
pub const Z_UTIL_INC_1871: u32 = 1872;
pub const Z_UTIL_INC_1872: u32 = 1873;
pub const Z_UTIL_INC_1873: u32 = 1874;
pub const Z_UTIL_INC_1874: u32 = 1875;
pub const Z_UTIL_INC_1875: u32 = 1876;
pub const Z_UTIL_INC_1876: u32 = 1877;
pub const Z_UTIL_INC_1877: u32 = 1878;
pub const Z_UTIL_INC_1878: u32 = 1879;
pub const Z_UTIL_INC_1879: u32 = 1880;
pub const Z_UTIL_INC_1880: u32 = 1881;
pub const Z_UTIL_INC_1881: u32 = 1882;
pub const Z_UTIL_INC_1882: u32 = 1883;
pub const Z_UTIL_INC_1883: u32 = 1884;
pub const Z_UTIL_INC_1884: u32 = 1885;
pub const Z_UTIL_INC_1885: u32 = 1886;
pub const Z_UTIL_INC_1886: u32 = 1887;
pub const Z_UTIL_INC_1887: u32 = 1888;
pub const Z_UTIL_INC_1888: u32 = 1889;
pub const Z_UTIL_INC_1889: u32 = 1890;
pub const Z_UTIL_INC_1890: u32 = 1891;
pub const Z_UTIL_INC_1891: u32 = 1892;
pub const Z_UTIL_INC_1892: u32 = 1893;
pub const Z_UTIL_INC_1893: u32 = 1894;
pub const Z_UTIL_INC_1894: u32 = 1895;
pub const Z_UTIL_INC_1895: u32 = 1896;
pub const Z_UTIL_INC_1896: u32 = 1897;
pub const Z_UTIL_INC_1897: u32 = 1898;
pub const Z_UTIL_INC_1898: u32 = 1899;
pub const Z_UTIL_INC_1899: u32 = 1900;
pub const Z_UTIL_INC_1900: u32 = 1901;
pub const Z_UTIL_INC_1901: u32 = 1902;
pub const Z_UTIL_INC_1902: u32 = 1903;
pub const Z_UTIL_INC_1903: u32 = 1904;
pub const Z_UTIL_INC_1904: u32 = 1905;
pub const Z_UTIL_INC_1905: u32 = 1906;
pub const Z_UTIL_INC_1906: u32 = 1907;
pub const Z_UTIL_INC_1907: u32 = 1908;
pub const Z_UTIL_INC_1908: u32 = 1909;
pub const Z_UTIL_INC_1909: u32 = 1910;
pub const Z_UTIL_INC_1910: u32 = 1911;
pub const Z_UTIL_INC_1911: u32 = 1912;
pub const Z_UTIL_INC_1912: u32 = 1913;
pub const Z_UTIL_INC_1913: u32 = 1914;
pub const Z_UTIL_INC_1914: u32 = 1915;
pub const Z_UTIL_INC_1915: u32 = 1916;
pub const Z_UTIL_INC_1916: u32 = 1917;
pub const Z_UTIL_INC_1917: u32 = 1918;
pub const Z_UTIL_INC_1918: u32 = 1919;
pub const Z_UTIL_INC_1919: u32 = 1920;
pub const Z_UTIL_INC_1920: u32 = 1921;
pub const Z_UTIL_INC_1921: u32 = 1922;
pub const Z_UTIL_INC_1922: u32 = 1923;
pub const Z_UTIL_INC_1923: u32 = 1924;
pub const Z_UTIL_INC_1924: u32 = 1925;
pub const Z_UTIL_INC_1925: u32 = 1926;
pub const Z_UTIL_INC_1926: u32 = 1927;
pub const Z_UTIL_INC_1927: u32 = 1928;
pub const Z_UTIL_INC_1928: u32 = 1929;
pub const Z_UTIL_INC_1929: u32 = 1930;
pub const Z_UTIL_INC_1930: u32 = 1931;
pub const Z_UTIL_INC_1931: u32 = 1932;
pub const Z_UTIL_INC_1932: u32 = 1933;
pub const Z_UTIL_INC_1933: u32 = 1934;
pub const Z_UTIL_INC_1934: u32 = 1935;
pub const Z_UTIL_INC_1935: u32 = 1936;
pub const Z_UTIL_INC_1936: u32 = 1937;
pub const Z_UTIL_INC_1937: u32 = 1938;
pub const Z_UTIL_INC_1938: u32 = 1939;
pub const Z_UTIL_INC_1939: u32 = 1940;
pub const Z_UTIL_INC_1940: u32 = 1941;
pub const Z_UTIL_INC_1941: u32 = 1942;
pub const Z_UTIL_INC_1942: u32 = 1943;
pub const Z_UTIL_INC_1943: u32 = 1944;
pub const Z_UTIL_INC_1944: u32 = 1945;
pub const Z_UTIL_INC_1945: u32 = 1946;
pub const Z_UTIL_INC_1946: u32 = 1947;
pub const Z_UTIL_INC_1947: u32 = 1948;
pub const Z_UTIL_INC_1948: u32 = 1949;
pub const Z_UTIL_INC_1949: u32 = 1950;
pub const Z_UTIL_INC_1950: u32 = 1951;
pub const Z_UTIL_INC_1951: u32 = 1952;
pub const Z_UTIL_INC_1952: u32 = 1953;
pub const Z_UTIL_INC_1953: u32 = 1954;
pub const Z_UTIL_INC_1954: u32 = 1955;
pub const Z_UTIL_INC_1955: u32 = 1956;
pub const Z_UTIL_INC_1956: u32 = 1957;
pub const Z_UTIL_INC_1957: u32 = 1958;
pub const Z_UTIL_INC_1958: u32 = 1959;
pub const Z_UTIL_INC_1959: u32 = 1960;
pub const Z_UTIL_INC_1960: u32 = 1961;
pub const Z_UTIL_INC_1961: u32 = 1962;
pub const Z_UTIL_INC_1962: u32 = 1963;
pub const Z_UTIL_INC_1963: u32 = 1964;
pub const Z_UTIL_INC_1964: u32 = 1965;
pub const Z_UTIL_INC_1965: u32 = 1966;
pub const Z_UTIL_INC_1966: u32 = 1967;
pub const Z_UTIL_INC_1967: u32 = 1968;
pub const Z_UTIL_INC_1968: u32 = 1969;
pub const Z_UTIL_INC_1969: u32 = 1970;
pub const Z_UTIL_INC_1970: u32 = 1971;
pub const Z_UTIL_INC_1971: u32 = 1972;
pub const Z_UTIL_INC_1972: u32 = 1973;
pub const Z_UTIL_INC_1973: u32 = 1974;
pub const Z_UTIL_INC_1974: u32 = 1975;
pub const Z_UTIL_INC_1975: u32 = 1976;
pub const Z_UTIL_INC_1976: u32 = 1977;
pub const Z_UTIL_INC_1977: u32 = 1978;
pub const Z_UTIL_INC_1978: u32 = 1979;
pub const Z_UTIL_INC_1979: u32 = 1980;
pub const Z_UTIL_INC_1980: u32 = 1981;
pub const Z_UTIL_INC_1981: u32 = 1982;
pub const Z_UTIL_INC_1982: u32 = 1983;
pub const Z_UTIL_INC_1983: u32 = 1984;
pub const Z_UTIL_INC_1984: u32 = 1985;
pub const Z_UTIL_INC_1985: u32 = 1986;
pub const Z_UTIL_INC_1986: u32 = 1987;
pub const Z_UTIL_INC_1987: u32 = 1988;
pub const Z_UTIL_INC_1988: u32 = 1989;
pub const Z_UTIL_INC_1989: u32 = 1990;
pub const Z_UTIL_INC_1990: u32 = 1991;
pub const Z_UTIL_INC_1991: u32 = 1992;
pub const Z_UTIL_INC_1992: u32 = 1993;
pub const Z_UTIL_INC_1993: u32 = 1994;
pub const Z_UTIL_INC_1994: u32 = 1995;
pub const Z_UTIL_INC_1995: u32 = 1996;
pub const Z_UTIL_INC_1996: u32 = 1997;
pub const Z_UTIL_INC_1997: u32 = 1998;
pub const Z_UTIL_INC_1998: u32 = 1999;
pub const Z_UTIL_INC_1999: u32 = 2000;
pub const Z_UTIL_INC_2000: u32 = 2001;
pub const Z_UTIL_INC_2001: u32 = 2002;
pub const Z_UTIL_INC_2002: u32 = 2003;
pub const Z_UTIL_INC_2003: u32 = 2004;
pub const Z_UTIL_INC_2004: u32 = 2005;
pub const Z_UTIL_INC_2005: u32 = 2006;
pub const Z_UTIL_INC_2006: u32 = 2007;
pub const Z_UTIL_INC_2007: u32 = 2008;
pub const Z_UTIL_INC_2008: u32 = 2009;
pub const Z_UTIL_INC_2009: u32 = 2010;
pub const Z_UTIL_INC_2010: u32 = 2011;
pub const Z_UTIL_INC_2011: u32 = 2012;
pub const Z_UTIL_INC_2012: u32 = 2013;
pub const Z_UTIL_INC_2013: u32 = 2014;
pub const Z_UTIL_INC_2014: u32 = 2015;
pub const Z_UTIL_INC_2015: u32 = 2016;
pub const Z_UTIL_INC_2016: u32 = 2017;
pub const Z_UTIL_INC_2017: u32 = 2018;
pub const Z_UTIL_INC_2018: u32 = 2019;
pub const Z_UTIL_INC_2019: u32 = 2020;
pub const Z_UTIL_INC_2020: u32 = 2021;
pub const Z_UTIL_INC_2021: u32 = 2022;
pub const Z_UTIL_INC_2022: u32 = 2023;
pub const Z_UTIL_INC_2023: u32 = 2024;
pub const Z_UTIL_INC_2024: u32 = 2025;
pub const Z_UTIL_INC_2025: u32 = 2026;
pub const Z_UTIL_INC_2026: u32 = 2027;
pub const Z_UTIL_INC_2027: u32 = 2028;
pub const Z_UTIL_INC_2028: u32 = 2029;
pub const Z_UTIL_INC_2029: u32 = 2030;
pub const Z_UTIL_INC_2030: u32 = 2031;
pub const Z_UTIL_INC_2031: u32 = 2032;
pub const Z_UTIL_INC_2032: u32 = 2033;
pub const Z_UTIL_INC_2033: u32 = 2034;
pub const Z_UTIL_INC_2034: u32 = 2035;
pub const Z_UTIL_INC_2035: u32 = 2036;
pub const Z_UTIL_INC_2036: u32 = 2037;
pub const Z_UTIL_INC_2037: u32 = 2038;
pub const Z_UTIL_INC_2038: u32 = 2039;
pub const Z_UTIL_INC_2039: u32 = 2040;
pub const Z_UTIL_INC_2040: u32 = 2041;
pub const Z_UTIL_INC_2041: u32 = 2042;
pub const Z_UTIL_INC_2042: u32 = 2043;
pub const Z_UTIL_INC_2043: u32 = 2044;
pub const Z_UTIL_INC_2044: u32 = 2045;
pub const Z_UTIL_INC_2045: u32 = 2046;
pub const Z_UTIL_INC_2046: u32 = 2047;
pub const Z_UTIL_INC_2047: u32 = 2048;
pub const Z_UTIL_INC_2048: u32 = 2049;
pub const Z_UTIL_INC_2049: u32 = 2050;
pub const Z_UTIL_INC_2050: u32 = 2051;
pub const Z_UTIL_INC_2051: u32 = 2052;
pub const Z_UTIL_INC_2052: u32 = 2053;
pub const Z_UTIL_INC_2053: u32 = 2054;
pub const Z_UTIL_INC_2054: u32 = 2055;
pub const Z_UTIL_INC_2055: u32 = 2056;
pub const Z_UTIL_INC_2056: u32 = 2057;
pub const Z_UTIL_INC_2057: u32 = 2058;
pub const Z_UTIL_INC_2058: u32 = 2059;
pub const Z_UTIL_INC_2059: u32 = 2060;
pub const Z_UTIL_INC_2060: u32 = 2061;
pub const Z_UTIL_INC_2061: u32 = 2062;
pub const Z_UTIL_INC_2062: u32 = 2063;
pub const Z_UTIL_INC_2063: u32 = 2064;
pub const Z_UTIL_INC_2064: u32 = 2065;
pub const Z_UTIL_INC_2065: u32 = 2066;
pub const Z_UTIL_INC_2066: u32 = 2067;
pub const Z_UTIL_INC_2067: u32 = 2068;
pub const Z_UTIL_INC_2068: u32 = 2069;
pub const Z_UTIL_INC_2069: u32 = 2070;
pub const Z_UTIL_INC_2070: u32 = 2071;
pub const Z_UTIL_INC_2071: u32 = 2072;
pub const Z_UTIL_INC_2072: u32 = 2073;
pub const Z_UTIL_INC_2073: u32 = 2074;
pub const Z_UTIL_INC_2074: u32 = 2075;
pub const Z_UTIL_INC_2075: u32 = 2076;
pub const Z_UTIL_INC_2076: u32 = 2077;
pub const Z_UTIL_INC_2077: u32 = 2078;
pub const Z_UTIL_INC_2078: u32 = 2079;
pub const Z_UTIL_INC_2079: u32 = 2080;
pub const Z_UTIL_INC_2080: u32 = 2081;
pub const Z_UTIL_INC_2081: u32 = 2082;
pub const Z_UTIL_INC_2082: u32 = 2083;
pub const Z_UTIL_INC_2083: u32 = 2084;
pub const Z_UTIL_INC_2084: u32 = 2085;
pub const Z_UTIL_INC_2085: u32 = 2086;
pub const Z_UTIL_INC_2086: u32 = 2087;
pub const Z_UTIL_INC_2087: u32 = 2088;
pub const Z_UTIL_INC_2088: u32 = 2089;
pub const Z_UTIL_INC_2089: u32 = 2090;
pub const Z_UTIL_INC_2090: u32 = 2091;
pub const Z_UTIL_INC_2091: u32 = 2092;
pub const Z_UTIL_INC_2092: u32 = 2093;
pub const Z_UTIL_INC_2093: u32 = 2094;
pub const Z_UTIL_INC_2094: u32 = 2095;
pub const Z_UTIL_INC_2095: u32 = 2096;
pub const Z_UTIL_INC_2096: u32 = 2097;
pub const Z_UTIL_INC_2097: u32 = 2098;
pub const Z_UTIL_INC_2098: u32 = 2099;
pub const Z_UTIL_INC_2099: u32 = 2100;
pub const Z_UTIL_INC_2100: u32 = 2101;
pub const Z_UTIL_INC_2101: u32 = 2102;
pub const Z_UTIL_INC_2102: u32 = 2103;
pub const Z_UTIL_INC_2103: u32 = 2104;
pub const Z_UTIL_INC_2104: u32 = 2105;
pub const Z_UTIL_INC_2105: u32 = 2106;
pub const Z_UTIL_INC_2106: u32 = 2107;
pub const Z_UTIL_INC_2107: u32 = 2108;
pub const Z_UTIL_INC_2108: u32 = 2109;
pub const Z_UTIL_INC_2109: u32 = 2110;
pub const Z_UTIL_INC_2110: u32 = 2111;
pub const Z_UTIL_INC_2111: u32 = 2112;
pub const Z_UTIL_INC_2112: u32 = 2113;
pub const Z_UTIL_INC_2113: u32 = 2114;
pub const Z_UTIL_INC_2114: u32 = 2115;
pub const Z_UTIL_INC_2115: u32 = 2116;
pub const Z_UTIL_INC_2116: u32 = 2117;
pub const Z_UTIL_INC_2117: u32 = 2118;
pub const Z_UTIL_INC_2118: u32 = 2119;
pub const Z_UTIL_INC_2119: u32 = 2120;
pub const Z_UTIL_INC_2120: u32 = 2121;
pub const Z_UTIL_INC_2121: u32 = 2122;
pub const Z_UTIL_INC_2122: u32 = 2123;
pub const Z_UTIL_INC_2123: u32 = 2124;
pub const Z_UTIL_INC_2124: u32 = 2125;
pub const Z_UTIL_INC_2125: u32 = 2126;
pub const Z_UTIL_INC_2126: u32 = 2127;
pub const Z_UTIL_INC_2127: u32 = 2128;
pub const Z_UTIL_INC_2128: u32 = 2129;
pub const Z_UTIL_INC_2129: u32 = 2130;
pub const Z_UTIL_INC_2130: u32 = 2131;
pub const Z_UTIL_INC_2131: u32 = 2132;
pub const Z_UTIL_INC_2132: u32 = 2133;
pub const Z_UTIL_INC_2133: u32 = 2134;
pub const Z_UTIL_INC_2134: u32 = 2135;
pub const Z_UTIL_INC_2135: u32 = 2136;
pub const Z_UTIL_INC_2136: u32 = 2137;
pub const Z_UTIL_INC_2137: u32 = 2138;
pub const Z_UTIL_INC_2138: u32 = 2139;
pub const Z_UTIL_INC_2139: u32 = 2140;
pub const Z_UTIL_INC_2140: u32 = 2141;
pub const Z_UTIL_INC_2141: u32 = 2142;
pub const Z_UTIL_INC_2142: u32 = 2143;
pub const Z_UTIL_INC_2143: u32 = 2144;
pub const Z_UTIL_INC_2144: u32 = 2145;
pub const Z_UTIL_INC_2145: u32 = 2146;
pub const Z_UTIL_INC_2146: u32 = 2147;
pub const Z_UTIL_INC_2147: u32 = 2148;
pub const Z_UTIL_INC_2148: u32 = 2149;
pub const Z_UTIL_INC_2149: u32 = 2150;
pub const Z_UTIL_INC_2150: u32 = 2151;
pub const Z_UTIL_INC_2151: u32 = 2152;
pub const Z_UTIL_INC_2152: u32 = 2153;
pub const Z_UTIL_INC_2153: u32 = 2154;
pub const Z_UTIL_INC_2154: u32 = 2155;
pub const Z_UTIL_INC_2155: u32 = 2156;
pub const Z_UTIL_INC_2156: u32 = 2157;
pub const Z_UTIL_INC_2157: u32 = 2158;
pub const Z_UTIL_INC_2158: u32 = 2159;
pub const Z_UTIL_INC_2159: u32 = 2160;
pub const Z_UTIL_INC_2160: u32 = 2161;
pub const Z_UTIL_INC_2161: u32 = 2162;
pub const Z_UTIL_INC_2162: u32 = 2163;
pub const Z_UTIL_INC_2163: u32 = 2164;
pub const Z_UTIL_INC_2164: u32 = 2165;
pub const Z_UTIL_INC_2165: u32 = 2166;
pub const Z_UTIL_INC_2166: u32 = 2167;
pub const Z_UTIL_INC_2167: u32 = 2168;
pub const Z_UTIL_INC_2168: u32 = 2169;
pub const Z_UTIL_INC_2169: u32 = 2170;
pub const Z_UTIL_INC_2170: u32 = 2171;
pub const Z_UTIL_INC_2171: u32 = 2172;
pub const Z_UTIL_INC_2172: u32 = 2173;
pub const Z_UTIL_INC_2173: u32 = 2174;
pub const Z_UTIL_INC_2174: u32 = 2175;
pub const Z_UTIL_INC_2175: u32 = 2176;
pub const Z_UTIL_INC_2176: u32 = 2177;
pub const Z_UTIL_INC_2177: u32 = 2178;
pub const Z_UTIL_INC_2178: u32 = 2179;
pub const Z_UTIL_INC_2179: u32 = 2180;
pub const Z_UTIL_INC_2180: u32 = 2181;
pub const Z_UTIL_INC_2181: u32 = 2182;
pub const Z_UTIL_INC_2182: u32 = 2183;
pub const Z_UTIL_INC_2183: u32 = 2184;
pub const Z_UTIL_INC_2184: u32 = 2185;
pub const Z_UTIL_INC_2185: u32 = 2186;
pub const Z_UTIL_INC_2186: u32 = 2187;
pub const Z_UTIL_INC_2187: u32 = 2188;
pub const Z_UTIL_INC_2188: u32 = 2189;
pub const Z_UTIL_INC_2189: u32 = 2190;
pub const Z_UTIL_INC_2190: u32 = 2191;
pub const Z_UTIL_INC_2191: u32 = 2192;
pub const Z_UTIL_INC_2192: u32 = 2193;
pub const Z_UTIL_INC_2193: u32 = 2194;
pub const Z_UTIL_INC_2194: u32 = 2195;
pub const Z_UTIL_INC_2195: u32 = 2196;
pub const Z_UTIL_INC_2196: u32 = 2197;
pub const Z_UTIL_INC_2197: u32 = 2198;
pub const Z_UTIL_INC_2198: u32 = 2199;
pub const Z_UTIL_INC_2199: u32 = 2200;
pub const Z_UTIL_INC_2200: u32 = 2201;
pub const Z_UTIL_INC_2201: u32 = 2202;
pub const Z_UTIL_INC_2202: u32 = 2203;
pub const Z_UTIL_INC_2203: u32 = 2204;
pub const Z_UTIL_INC_2204: u32 = 2205;
pub const Z_UTIL_INC_2205: u32 = 2206;
pub const Z_UTIL_INC_2206: u32 = 2207;
pub const Z_UTIL_INC_2207: u32 = 2208;
pub const Z_UTIL_INC_2208: u32 = 2209;
pub const Z_UTIL_INC_2209: u32 = 2210;
pub const Z_UTIL_INC_2210: u32 = 2211;
pub const Z_UTIL_INC_2211: u32 = 2212;
pub const Z_UTIL_INC_2212: u32 = 2213;
pub const Z_UTIL_INC_2213: u32 = 2214;
pub const Z_UTIL_INC_2214: u32 = 2215;
pub const Z_UTIL_INC_2215: u32 = 2216;
pub const Z_UTIL_INC_2216: u32 = 2217;
pub const Z_UTIL_INC_2217: u32 = 2218;
pub const Z_UTIL_INC_2218: u32 = 2219;
pub const Z_UTIL_INC_2219: u32 = 2220;
pub const Z_UTIL_INC_2220: u32 = 2221;
pub const Z_UTIL_INC_2221: u32 = 2222;
pub const Z_UTIL_INC_2222: u32 = 2223;
pub const Z_UTIL_INC_2223: u32 = 2224;
pub const Z_UTIL_INC_2224: u32 = 2225;
pub const Z_UTIL_INC_2225: u32 = 2226;
pub const Z_UTIL_INC_2226: u32 = 2227;
pub const Z_UTIL_INC_2227: u32 = 2228;
pub const Z_UTIL_INC_2228: u32 = 2229;
pub const Z_UTIL_INC_2229: u32 = 2230;
pub const Z_UTIL_INC_2230: u32 = 2231;
pub const Z_UTIL_INC_2231: u32 = 2232;
pub const Z_UTIL_INC_2232: u32 = 2233;
pub const Z_UTIL_INC_2233: u32 = 2234;
pub const Z_UTIL_INC_2234: u32 = 2235;
pub const Z_UTIL_INC_2235: u32 = 2236;
pub const Z_UTIL_INC_2236: u32 = 2237;
pub const Z_UTIL_INC_2237: u32 = 2238;
pub const Z_UTIL_INC_2238: u32 = 2239;
pub const Z_UTIL_INC_2239: u32 = 2240;
pub const Z_UTIL_INC_2240: u32 = 2241;
pub const Z_UTIL_INC_2241: u32 = 2242;
pub const Z_UTIL_INC_2242: u32 = 2243;
pub const Z_UTIL_INC_2243: u32 = 2244;
pub const Z_UTIL_INC_2244: u32 = 2245;
pub const Z_UTIL_INC_2245: u32 = 2246;
pub const Z_UTIL_INC_2246: u32 = 2247;
pub const Z_UTIL_INC_2247: u32 = 2248;
pub const Z_UTIL_INC_2248: u32 = 2249;
pub const Z_UTIL_INC_2249: u32 = 2250;
pub const Z_UTIL_INC_2250: u32 = 2251;
pub const Z_UTIL_INC_2251: u32 = 2252;
pub const Z_UTIL_INC_2252: u32 = 2253;
pub const Z_UTIL_INC_2253: u32 = 2254;
pub const Z_UTIL_INC_2254: u32 = 2255;
pub const Z_UTIL_INC_2255: u32 = 2256;
pub const Z_UTIL_INC_2256: u32 = 2257;
pub const Z_UTIL_INC_2257: u32 = 2258;
pub const Z_UTIL_INC_2258: u32 = 2259;
pub const Z_UTIL_INC_2259: u32 = 2260;
pub const Z_UTIL_INC_2260: u32 = 2261;
pub const Z_UTIL_INC_2261: u32 = 2262;
pub const Z_UTIL_INC_2262: u32 = 2263;
pub const Z_UTIL_INC_2263: u32 = 2264;
pub const Z_UTIL_INC_2264: u32 = 2265;
pub const Z_UTIL_INC_2265: u32 = 2266;
pub const Z_UTIL_INC_2266: u32 = 2267;
pub const Z_UTIL_INC_2267: u32 = 2268;
pub const Z_UTIL_INC_2268: u32 = 2269;
pub const Z_UTIL_INC_2269: u32 = 2270;
pub const Z_UTIL_INC_2270: u32 = 2271;
pub const Z_UTIL_INC_2271: u32 = 2272;
pub const Z_UTIL_INC_2272: u32 = 2273;
pub const Z_UTIL_INC_2273: u32 = 2274;
pub const Z_UTIL_INC_2274: u32 = 2275;
pub const Z_UTIL_INC_2275: u32 = 2276;
pub const Z_UTIL_INC_2276: u32 = 2277;
pub const Z_UTIL_INC_2277: u32 = 2278;
pub const Z_UTIL_INC_2278: u32 = 2279;
pub const Z_UTIL_INC_2279: u32 = 2280;
pub const Z_UTIL_INC_2280: u32 = 2281;
pub const Z_UTIL_INC_2281: u32 = 2282;
pub const Z_UTIL_INC_2282: u32 = 2283;
pub const Z_UTIL_INC_2283: u32 = 2284;
pub const Z_UTIL_INC_2284: u32 = 2285;
pub const Z_UTIL_INC_2285: u32 = 2286;
pub const Z_UTIL_INC_2286: u32 = 2287;
pub const Z_UTIL_INC_2287: u32 = 2288;
pub const Z_UTIL_INC_2288: u32 = 2289;
pub const Z_UTIL_INC_2289: u32 = 2290;
pub const Z_UTIL_INC_2290: u32 = 2291;
pub const Z_UTIL_INC_2291: u32 = 2292;
pub const Z_UTIL_INC_2292: u32 = 2293;
pub const Z_UTIL_INC_2293: u32 = 2294;
pub const Z_UTIL_INC_2294: u32 = 2295;
pub const Z_UTIL_INC_2295: u32 = 2296;
pub const Z_UTIL_INC_2296: u32 = 2297;
pub const Z_UTIL_INC_2297: u32 = 2298;
pub const Z_UTIL_INC_2298: u32 = 2299;
pub const Z_UTIL_INC_2299: u32 = 2300;
pub const Z_UTIL_INC_2300: u32 = 2301;
pub const Z_UTIL_INC_2301: u32 = 2302;
pub const Z_UTIL_INC_2302: u32 = 2303;
pub const Z_UTIL_INC_2303: u32 = 2304;
pub const Z_UTIL_INC_2304: u32 = 2305;
pub const Z_UTIL_INC_2305: u32 = 2306;
pub const Z_UTIL_INC_2306: u32 = 2307;
pub const Z_UTIL_INC_2307: u32 = 2308;
pub const Z_UTIL_INC_2308: u32 = 2309;
pub const Z_UTIL_INC_2309: u32 = 2310;
pub const Z_UTIL_INC_2310: u32 = 2311;
pub const Z_UTIL_INC_2311: u32 = 2312;
pub const Z_UTIL_INC_2312: u32 = 2313;
pub const Z_UTIL_INC_2313: u32 = 2314;
pub const Z_UTIL_INC_2314: u32 = 2315;
pub const Z_UTIL_INC_2315: u32 = 2316;
pub const Z_UTIL_INC_2316: u32 = 2317;
pub const Z_UTIL_INC_2317: u32 = 2318;
pub const Z_UTIL_INC_2318: u32 = 2319;
pub const Z_UTIL_INC_2319: u32 = 2320;
pub const Z_UTIL_INC_2320: u32 = 2321;
pub const Z_UTIL_INC_2321: u32 = 2322;
pub const Z_UTIL_INC_2322: u32 = 2323;
pub const Z_UTIL_INC_2323: u32 = 2324;
pub const Z_UTIL_INC_2324: u32 = 2325;
pub const Z_UTIL_INC_2325: u32 = 2326;
pub const Z_UTIL_INC_2326: u32 = 2327;
pub const Z_UTIL_INC_2327: u32 = 2328;
pub const Z_UTIL_INC_2328: u32 = 2329;
pub const Z_UTIL_INC_2329: u32 = 2330;
pub const Z_UTIL_INC_2330: u32 = 2331;
pub const Z_UTIL_INC_2331: u32 = 2332;
pub const Z_UTIL_INC_2332: u32 = 2333;
pub const Z_UTIL_INC_2333: u32 = 2334;
pub const Z_UTIL_INC_2334: u32 = 2335;
pub const Z_UTIL_INC_2335: u32 = 2336;
pub const Z_UTIL_INC_2336: u32 = 2337;
pub const Z_UTIL_INC_2337: u32 = 2338;
pub const Z_UTIL_INC_2338: u32 = 2339;
pub const Z_UTIL_INC_2339: u32 = 2340;
pub const Z_UTIL_INC_2340: u32 = 2341;
pub const Z_UTIL_INC_2341: u32 = 2342;
pub const Z_UTIL_INC_2342: u32 = 2343;
pub const Z_UTIL_INC_2343: u32 = 2344;
pub const Z_UTIL_INC_2344: u32 = 2345;
pub const Z_UTIL_INC_2345: u32 = 2346;
pub const Z_UTIL_INC_2346: u32 = 2347;
pub const Z_UTIL_INC_2347: u32 = 2348;
pub const Z_UTIL_INC_2348: u32 = 2349;
pub const Z_UTIL_INC_2349: u32 = 2350;
pub const Z_UTIL_INC_2350: u32 = 2351;
pub const Z_UTIL_INC_2351: u32 = 2352;
pub const Z_UTIL_INC_2352: u32 = 2353;
pub const Z_UTIL_INC_2353: u32 = 2354;
pub const Z_UTIL_INC_2354: u32 = 2355;
pub const Z_UTIL_INC_2355: u32 = 2356;
pub const Z_UTIL_INC_2356: u32 = 2357;
pub const Z_UTIL_INC_2357: u32 = 2358;
pub const Z_UTIL_INC_2358: u32 = 2359;
pub const Z_UTIL_INC_2359: u32 = 2360;
pub const Z_UTIL_INC_2360: u32 = 2361;
pub const Z_UTIL_INC_2361: u32 = 2362;
pub const Z_UTIL_INC_2362: u32 = 2363;
pub const Z_UTIL_INC_2363: u32 = 2364;
pub const Z_UTIL_INC_2364: u32 = 2365;
pub const Z_UTIL_INC_2365: u32 = 2366;
pub const Z_UTIL_INC_2366: u32 = 2367;
pub const Z_UTIL_INC_2367: u32 = 2368;
pub const Z_UTIL_INC_2368: u32 = 2369;
pub const Z_UTIL_INC_2369: u32 = 2370;
pub const Z_UTIL_INC_2370: u32 = 2371;
pub const Z_UTIL_INC_2371: u32 = 2372;
pub const Z_UTIL_INC_2372: u32 = 2373;
pub const Z_UTIL_INC_2373: u32 = 2374;
pub const Z_UTIL_INC_2374: u32 = 2375;
pub const Z_UTIL_INC_2375: u32 = 2376;
pub const Z_UTIL_INC_2376: u32 = 2377;
pub const Z_UTIL_INC_2377: u32 = 2378;
pub const Z_UTIL_INC_2378: u32 = 2379;
pub const Z_UTIL_INC_2379: u32 = 2380;
pub const Z_UTIL_INC_2380: u32 = 2381;
pub const Z_UTIL_INC_2381: u32 = 2382;
pub const Z_UTIL_INC_2382: u32 = 2383;
pub const Z_UTIL_INC_2383: u32 = 2384;
pub const Z_UTIL_INC_2384: u32 = 2385;
pub const Z_UTIL_INC_2385: u32 = 2386;
pub const Z_UTIL_INC_2386: u32 = 2387;
pub const Z_UTIL_INC_2387: u32 = 2388;
pub const Z_UTIL_INC_2388: u32 = 2389;
pub const Z_UTIL_INC_2389: u32 = 2390;
pub const Z_UTIL_INC_2390: u32 = 2391;
pub const Z_UTIL_INC_2391: u32 = 2392;
pub const Z_UTIL_INC_2392: u32 = 2393;
pub const Z_UTIL_INC_2393: u32 = 2394;
pub const Z_UTIL_INC_2394: u32 = 2395;
pub const Z_UTIL_INC_2395: u32 = 2396;
pub const Z_UTIL_INC_2396: u32 = 2397;
pub const Z_UTIL_INC_2397: u32 = 2398;
pub const Z_UTIL_INC_2398: u32 = 2399;
pub const Z_UTIL_INC_2399: u32 = 2400;
pub const Z_UTIL_INC_2400: u32 = 2401;
pub const Z_UTIL_INC_2401: u32 = 2402;
pub const Z_UTIL_INC_2402: u32 = 2403;
pub const Z_UTIL_INC_2403: u32 = 2404;
pub const Z_UTIL_INC_2404: u32 = 2405;
pub const Z_UTIL_INC_2405: u32 = 2406;
pub const Z_UTIL_INC_2406: u32 = 2407;
pub const Z_UTIL_INC_2407: u32 = 2408;
pub const Z_UTIL_INC_2408: u32 = 2409;
pub const Z_UTIL_INC_2409: u32 = 2410;
pub const Z_UTIL_INC_2410: u32 = 2411;
pub const Z_UTIL_INC_2411: u32 = 2412;
pub const Z_UTIL_INC_2412: u32 = 2413;
pub const Z_UTIL_INC_2413: u32 = 2414;
pub const Z_UTIL_INC_2414: u32 = 2415;
pub const Z_UTIL_INC_2415: u32 = 2416;
pub const Z_UTIL_INC_2416: u32 = 2417;
pub const Z_UTIL_INC_2417: u32 = 2418;
pub const Z_UTIL_INC_2418: u32 = 2419;
pub const Z_UTIL_INC_2419: u32 = 2420;
pub const Z_UTIL_INC_2420: u32 = 2421;
pub const Z_UTIL_INC_2421: u32 = 2422;
pub const Z_UTIL_INC_2422: u32 = 2423;
pub const Z_UTIL_INC_2423: u32 = 2424;
pub const Z_UTIL_INC_2424: u32 = 2425;
pub const Z_UTIL_INC_2425: u32 = 2426;
pub const Z_UTIL_INC_2426: u32 = 2427;
pub const Z_UTIL_INC_2427: u32 = 2428;
pub const Z_UTIL_INC_2428: u32 = 2429;
pub const Z_UTIL_INC_2429: u32 = 2430;
pub const Z_UTIL_INC_2430: u32 = 2431;
pub const Z_UTIL_INC_2431: u32 = 2432;
pub const Z_UTIL_INC_2432: u32 = 2433;
pub const Z_UTIL_INC_2433: u32 = 2434;
pub const Z_UTIL_INC_2434: u32 = 2435;
pub const Z_UTIL_INC_2435: u32 = 2436;
pub const Z_UTIL_INC_2436: u32 = 2437;
pub const Z_UTIL_INC_2437: u32 = 2438;
pub const Z_UTIL_INC_2438: u32 = 2439;
pub const Z_UTIL_INC_2439: u32 = 2440;
pub const Z_UTIL_INC_2440: u32 = 2441;
pub const Z_UTIL_INC_2441: u32 = 2442;
pub const Z_UTIL_INC_2442: u32 = 2443;
pub const Z_UTIL_INC_2443: u32 = 2444;
pub const Z_UTIL_INC_2444: u32 = 2445;
pub const Z_UTIL_INC_2445: u32 = 2446;
pub const Z_UTIL_INC_2446: u32 = 2447;
pub const Z_UTIL_INC_2447: u32 = 2448;
pub const Z_UTIL_INC_2448: u32 = 2449;
pub const Z_UTIL_INC_2449: u32 = 2450;
pub const Z_UTIL_INC_2450: u32 = 2451;
pub const Z_UTIL_INC_2451: u32 = 2452;
pub const Z_UTIL_INC_2452: u32 = 2453;
pub const Z_UTIL_INC_2453: u32 = 2454;
pub const Z_UTIL_INC_2454: u32 = 2455;
pub const Z_UTIL_INC_2455: u32 = 2456;
pub const Z_UTIL_INC_2456: u32 = 2457;
pub const Z_UTIL_INC_2457: u32 = 2458;
pub const Z_UTIL_INC_2458: u32 = 2459;
pub const Z_UTIL_INC_2459: u32 = 2460;
pub const Z_UTIL_INC_2460: u32 = 2461;
pub const Z_UTIL_INC_2461: u32 = 2462;
pub const Z_UTIL_INC_2462: u32 = 2463;
pub const Z_UTIL_INC_2463: u32 = 2464;
pub const Z_UTIL_INC_2464: u32 = 2465;
pub const Z_UTIL_INC_2465: u32 = 2466;
pub const Z_UTIL_INC_2466: u32 = 2467;
pub const Z_UTIL_INC_2467: u32 = 2468;
pub const Z_UTIL_INC_2468: u32 = 2469;
pub const Z_UTIL_INC_2469: u32 = 2470;
pub const Z_UTIL_INC_2470: u32 = 2471;
pub const Z_UTIL_INC_2471: u32 = 2472;
pub const Z_UTIL_INC_2472: u32 = 2473;
pub const Z_UTIL_INC_2473: u32 = 2474;
pub const Z_UTIL_INC_2474: u32 = 2475;
pub const Z_UTIL_INC_2475: u32 = 2476;
pub const Z_UTIL_INC_2476: u32 = 2477;
pub const Z_UTIL_INC_2477: u32 = 2478;
pub const Z_UTIL_INC_2478: u32 = 2479;
pub const Z_UTIL_INC_2479: u32 = 2480;
pub const Z_UTIL_INC_2480: u32 = 2481;
pub const Z_UTIL_INC_2481: u32 = 2482;
pub const Z_UTIL_INC_2482: u32 = 2483;
pub const Z_UTIL_INC_2483: u32 = 2484;
pub const Z_UTIL_INC_2484: u32 = 2485;
pub const Z_UTIL_INC_2485: u32 = 2486;
pub const Z_UTIL_INC_2486: u32 = 2487;
pub const Z_UTIL_INC_2487: u32 = 2488;
pub const Z_UTIL_INC_2488: u32 = 2489;
pub const Z_UTIL_INC_2489: u32 = 2490;
pub const Z_UTIL_INC_2490: u32 = 2491;
pub const Z_UTIL_INC_2491: u32 = 2492;
pub const Z_UTIL_INC_2492: u32 = 2493;
pub const Z_UTIL_INC_2493: u32 = 2494;
pub const Z_UTIL_INC_2494: u32 = 2495;
pub const Z_UTIL_INC_2495: u32 = 2496;
pub const Z_UTIL_INC_2496: u32 = 2497;
pub const Z_UTIL_INC_2497: u32 = 2498;
pub const Z_UTIL_INC_2498: u32 = 2499;
pub const Z_UTIL_INC_2499: u32 = 2500;
pub const Z_UTIL_INC_2500: u32 = 2501;
pub const Z_UTIL_INC_2501: u32 = 2502;
pub const Z_UTIL_INC_2502: u32 = 2503;
pub const Z_UTIL_INC_2503: u32 = 2504;
pub const Z_UTIL_INC_2504: u32 = 2505;
pub const Z_UTIL_INC_2505: u32 = 2506;
pub const Z_UTIL_INC_2506: u32 = 2507;
pub const Z_UTIL_INC_2507: u32 = 2508;
pub const Z_UTIL_INC_2508: u32 = 2509;
pub const Z_UTIL_INC_2509: u32 = 2510;
pub const Z_UTIL_INC_2510: u32 = 2511;
pub const Z_UTIL_INC_2511: u32 = 2512;
pub const Z_UTIL_INC_2512: u32 = 2513;
pub const Z_UTIL_INC_2513: u32 = 2514;
pub const Z_UTIL_INC_2514: u32 = 2515;
pub const Z_UTIL_INC_2515: u32 = 2516;
pub const Z_UTIL_INC_2516: u32 = 2517;
pub const Z_UTIL_INC_2517: u32 = 2518;
pub const Z_UTIL_INC_2518: u32 = 2519;
pub const Z_UTIL_INC_2519: u32 = 2520;
pub const Z_UTIL_INC_2520: u32 = 2521;
pub const Z_UTIL_INC_2521: u32 = 2522;
pub const Z_UTIL_INC_2522: u32 = 2523;
pub const Z_UTIL_INC_2523: u32 = 2524;
pub const Z_UTIL_INC_2524: u32 = 2525;
pub const Z_UTIL_INC_2525: u32 = 2526;
pub const Z_UTIL_INC_2526: u32 = 2527;
pub const Z_UTIL_INC_2527: u32 = 2528;
pub const Z_UTIL_INC_2528: u32 = 2529;
pub const Z_UTIL_INC_2529: u32 = 2530;
pub const Z_UTIL_INC_2530: u32 = 2531;
pub const Z_UTIL_INC_2531: u32 = 2532;
pub const Z_UTIL_INC_2532: u32 = 2533;
pub const Z_UTIL_INC_2533: u32 = 2534;
pub const Z_UTIL_INC_2534: u32 = 2535;
pub const Z_UTIL_INC_2535: u32 = 2536;
pub const Z_UTIL_INC_2536: u32 = 2537;
pub const Z_UTIL_INC_2537: u32 = 2538;
pub const Z_UTIL_INC_2538: u32 = 2539;
pub const Z_UTIL_INC_2539: u32 = 2540;
pub const Z_UTIL_INC_2540: u32 = 2541;
pub const Z_UTIL_INC_2541: u32 = 2542;
pub const Z_UTIL_INC_2542: u32 = 2543;
pub const Z_UTIL_INC_2543: u32 = 2544;
pub const Z_UTIL_INC_2544: u32 = 2545;
pub const Z_UTIL_INC_2545: u32 = 2546;
pub const Z_UTIL_INC_2546: u32 = 2547;
pub const Z_UTIL_INC_2547: u32 = 2548;
pub const Z_UTIL_INC_2548: u32 = 2549;
pub const Z_UTIL_INC_2549: u32 = 2550;
pub const Z_UTIL_INC_2550: u32 = 2551;
pub const Z_UTIL_INC_2551: u32 = 2552;
pub const Z_UTIL_INC_2552: u32 = 2553;
pub const Z_UTIL_INC_2553: u32 = 2554;
pub const Z_UTIL_INC_2554: u32 = 2555;
pub const Z_UTIL_INC_2555: u32 = 2556;
pub const Z_UTIL_INC_2556: u32 = 2557;
pub const Z_UTIL_INC_2557: u32 = 2558;
pub const Z_UTIL_INC_2558: u32 = 2559;
pub const Z_UTIL_INC_2559: u32 = 2560;
pub const Z_UTIL_INC_2560: u32 = 2561;
pub const Z_UTIL_INC_2561: u32 = 2562;
pub const Z_UTIL_INC_2562: u32 = 2563;
pub const Z_UTIL_INC_2563: u32 = 2564;
pub const Z_UTIL_INC_2564: u32 = 2565;
pub const Z_UTIL_INC_2565: u32 = 2566;
pub const Z_UTIL_INC_2566: u32 = 2567;
pub const Z_UTIL_INC_2567: u32 = 2568;
pub const Z_UTIL_INC_2568: u32 = 2569;
pub const Z_UTIL_INC_2569: u32 = 2570;
pub const Z_UTIL_INC_2570: u32 = 2571;
pub const Z_UTIL_INC_2571: u32 = 2572;
pub const Z_UTIL_INC_2572: u32 = 2573;
pub const Z_UTIL_INC_2573: u32 = 2574;
pub const Z_UTIL_INC_2574: u32 = 2575;
pub const Z_UTIL_INC_2575: u32 = 2576;
pub const Z_UTIL_INC_2576: u32 = 2577;
pub const Z_UTIL_INC_2577: u32 = 2578;
pub const Z_UTIL_INC_2578: u32 = 2579;
pub const Z_UTIL_INC_2579: u32 = 2580;
pub const Z_UTIL_INC_2580: u32 = 2581;
pub const Z_UTIL_INC_2581: u32 = 2582;
pub const Z_UTIL_INC_2582: u32 = 2583;
pub const Z_UTIL_INC_2583: u32 = 2584;
pub const Z_UTIL_INC_2584: u32 = 2585;
pub const Z_UTIL_INC_2585: u32 = 2586;
pub const Z_UTIL_INC_2586: u32 = 2587;
pub const Z_UTIL_INC_2587: u32 = 2588;
pub const Z_UTIL_INC_2588: u32 = 2589;
pub const Z_UTIL_INC_2589: u32 = 2590;
pub const Z_UTIL_INC_2590: u32 = 2591;
pub const Z_UTIL_INC_2591: u32 = 2592;
pub const Z_UTIL_INC_2592: u32 = 2593;
pub const Z_UTIL_INC_2593: u32 = 2594;
pub const Z_UTIL_INC_2594: u32 = 2595;
pub const Z_UTIL_INC_2595: u32 = 2596;
pub const Z_UTIL_INC_2596: u32 = 2597;
pub const Z_UTIL_INC_2597: u32 = 2598;
pub const Z_UTIL_INC_2598: u32 = 2599;
pub const Z_UTIL_INC_2599: u32 = 2600;
pub const Z_UTIL_INC_2600: u32 = 2601;
pub const Z_UTIL_INC_2601: u32 = 2602;
pub const Z_UTIL_INC_2602: u32 = 2603;
pub const Z_UTIL_INC_2603: u32 = 2604;
pub const Z_UTIL_INC_2604: u32 = 2605;
pub const Z_UTIL_INC_2605: u32 = 2606;
pub const Z_UTIL_INC_2606: u32 = 2607;
pub const Z_UTIL_INC_2607: u32 = 2608;
pub const Z_UTIL_INC_2608: u32 = 2609;
pub const Z_UTIL_INC_2609: u32 = 2610;
pub const Z_UTIL_INC_2610: u32 = 2611;
pub const Z_UTIL_INC_2611: u32 = 2612;
pub const Z_UTIL_INC_2612: u32 = 2613;
pub const Z_UTIL_INC_2613: u32 = 2614;
pub const Z_UTIL_INC_2614: u32 = 2615;
pub const Z_UTIL_INC_2615: u32 = 2616;
pub const Z_UTIL_INC_2616: u32 = 2617;
pub const Z_UTIL_INC_2617: u32 = 2618;
pub const Z_UTIL_INC_2618: u32 = 2619;
pub const Z_UTIL_INC_2619: u32 = 2620;
pub const Z_UTIL_INC_2620: u32 = 2621;
pub const Z_UTIL_INC_2621: u32 = 2622;
pub const Z_UTIL_INC_2622: u32 = 2623;
pub const Z_UTIL_INC_2623: u32 = 2624;
pub const Z_UTIL_INC_2624: u32 = 2625;
pub const Z_UTIL_INC_2625: u32 = 2626;
pub const Z_UTIL_INC_2626: u32 = 2627;
pub const Z_UTIL_INC_2627: u32 = 2628;
pub const Z_UTIL_INC_2628: u32 = 2629;
pub const Z_UTIL_INC_2629: u32 = 2630;
pub const Z_UTIL_INC_2630: u32 = 2631;
pub const Z_UTIL_INC_2631: u32 = 2632;
pub const Z_UTIL_INC_2632: u32 = 2633;
pub const Z_UTIL_INC_2633: u32 = 2634;
pub const Z_UTIL_INC_2634: u32 = 2635;
pub const Z_UTIL_INC_2635: u32 = 2636;
pub const Z_UTIL_INC_2636: u32 = 2637;
pub const Z_UTIL_INC_2637: u32 = 2638;
pub const Z_UTIL_INC_2638: u32 = 2639;
pub const Z_UTIL_INC_2639: u32 = 2640;
pub const Z_UTIL_INC_2640: u32 = 2641;
pub const Z_UTIL_INC_2641: u32 = 2642;
pub const Z_UTIL_INC_2642: u32 = 2643;
pub const Z_UTIL_INC_2643: u32 = 2644;
pub const Z_UTIL_INC_2644: u32 = 2645;
pub const Z_UTIL_INC_2645: u32 = 2646;
pub const Z_UTIL_INC_2646: u32 = 2647;
pub const Z_UTIL_INC_2647: u32 = 2648;
pub const Z_UTIL_INC_2648: u32 = 2649;
pub const Z_UTIL_INC_2649: u32 = 2650;
pub const Z_UTIL_INC_2650: u32 = 2651;
pub const Z_UTIL_INC_2651: u32 = 2652;
pub const Z_UTIL_INC_2652: u32 = 2653;
pub const Z_UTIL_INC_2653: u32 = 2654;
pub const Z_UTIL_INC_2654: u32 = 2655;
pub const Z_UTIL_INC_2655: u32 = 2656;
pub const Z_UTIL_INC_2656: u32 = 2657;
pub const Z_UTIL_INC_2657: u32 = 2658;
pub const Z_UTIL_INC_2658: u32 = 2659;
pub const Z_UTIL_INC_2659: u32 = 2660;
pub const Z_UTIL_INC_2660: u32 = 2661;
pub const Z_UTIL_INC_2661: u32 = 2662;
pub const Z_UTIL_INC_2662: u32 = 2663;
pub const Z_UTIL_INC_2663: u32 = 2664;
pub const Z_UTIL_INC_2664: u32 = 2665;
pub const Z_UTIL_INC_2665: u32 = 2666;
pub const Z_UTIL_INC_2666: u32 = 2667;
pub const Z_UTIL_INC_2667: u32 = 2668;
pub const Z_UTIL_INC_2668: u32 = 2669;
pub const Z_UTIL_INC_2669: u32 = 2670;
pub const Z_UTIL_INC_2670: u32 = 2671;
pub const Z_UTIL_INC_2671: u32 = 2672;
pub const Z_UTIL_INC_2672: u32 = 2673;
pub const Z_UTIL_INC_2673: u32 = 2674;
pub const Z_UTIL_INC_2674: u32 = 2675;
pub const Z_UTIL_INC_2675: u32 = 2676;
pub const Z_UTIL_INC_2676: u32 = 2677;
pub const Z_UTIL_INC_2677: u32 = 2678;
pub const Z_UTIL_INC_2678: u32 = 2679;
pub const Z_UTIL_INC_2679: u32 = 2680;
pub const Z_UTIL_INC_2680: u32 = 2681;
pub const Z_UTIL_INC_2681: u32 = 2682;
pub const Z_UTIL_INC_2682: u32 = 2683;
pub const Z_UTIL_INC_2683: u32 = 2684;
pub const Z_UTIL_INC_2684: u32 = 2685;
pub const Z_UTIL_INC_2685: u32 = 2686;
pub const Z_UTIL_INC_2686: u32 = 2687;
pub const Z_UTIL_INC_2687: u32 = 2688;
pub const Z_UTIL_INC_2688: u32 = 2689;
pub const Z_UTIL_INC_2689: u32 = 2690;
pub const Z_UTIL_INC_2690: u32 = 2691;
pub const Z_UTIL_INC_2691: u32 = 2692;
pub const Z_UTIL_INC_2692: u32 = 2693;
pub const Z_UTIL_INC_2693: u32 = 2694;
pub const Z_UTIL_INC_2694: u32 = 2695;
pub const Z_UTIL_INC_2695: u32 = 2696;
pub const Z_UTIL_INC_2696: u32 = 2697;
pub const Z_UTIL_INC_2697: u32 = 2698;
pub const Z_UTIL_INC_2698: u32 = 2699;
pub const Z_UTIL_INC_2699: u32 = 2700;
pub const Z_UTIL_INC_2700: u32 = 2701;
pub const Z_UTIL_INC_2701: u32 = 2702;
pub const Z_UTIL_INC_2702: u32 = 2703;
pub const Z_UTIL_INC_2703: u32 = 2704;
pub const Z_UTIL_INC_2704: u32 = 2705;
pub const Z_UTIL_INC_2705: u32 = 2706;
pub const Z_UTIL_INC_2706: u32 = 2707;
pub const Z_UTIL_INC_2707: u32 = 2708;
pub const Z_UTIL_INC_2708: u32 = 2709;
pub const Z_UTIL_INC_2709: u32 = 2710;
pub const Z_UTIL_INC_2710: u32 = 2711;
pub const Z_UTIL_INC_2711: u32 = 2712;
pub const Z_UTIL_INC_2712: u32 = 2713;
pub const Z_UTIL_INC_2713: u32 = 2714;
pub const Z_UTIL_INC_2714: u32 = 2715;
pub const Z_UTIL_INC_2715: u32 = 2716;
pub const Z_UTIL_INC_2716: u32 = 2717;
pub const Z_UTIL_INC_2717: u32 = 2718;
pub const Z_UTIL_INC_2718: u32 = 2719;
pub const Z_UTIL_INC_2719: u32 = 2720;
pub const Z_UTIL_INC_2720: u32 = 2721;
pub const Z_UTIL_INC_2721: u32 = 2722;
pub const Z_UTIL_INC_2722: u32 = 2723;
pub const Z_UTIL_INC_2723: u32 = 2724;
pub const Z_UTIL_INC_2724: u32 = 2725;
pub const Z_UTIL_INC_2725: u32 = 2726;
pub const Z_UTIL_INC_2726: u32 = 2727;
pub const Z_UTIL_INC_2727: u32 = 2728;
pub const Z_UTIL_INC_2728: u32 = 2729;
pub const Z_UTIL_INC_2729: u32 = 2730;
pub const Z_UTIL_INC_2730: u32 = 2731;
pub const Z_UTIL_INC_2731: u32 = 2732;
pub const Z_UTIL_INC_2732: u32 = 2733;
pub const Z_UTIL_INC_2733: u32 = 2734;
pub const Z_UTIL_INC_2734: u32 = 2735;
pub const Z_UTIL_INC_2735: u32 = 2736;
pub const Z_UTIL_INC_2736: u32 = 2737;
pub const Z_UTIL_INC_2737: u32 = 2738;
pub const Z_UTIL_INC_2738: u32 = 2739;
pub const Z_UTIL_INC_2739: u32 = 2740;
pub const Z_UTIL_INC_2740: u32 = 2741;
pub const Z_UTIL_INC_2741: u32 = 2742;
pub const Z_UTIL_INC_2742: u32 = 2743;
pub const Z_UTIL_INC_2743: u32 = 2744;
pub const Z_UTIL_INC_2744: u32 = 2745;
pub const Z_UTIL_INC_2745: u32 = 2746;
pub const Z_UTIL_INC_2746: u32 = 2747;
pub const Z_UTIL_INC_2747: u32 = 2748;
pub const Z_UTIL_INC_2748: u32 = 2749;
pub const Z_UTIL_INC_2749: u32 = 2750;
pub const Z_UTIL_INC_2750: u32 = 2751;
pub const Z_UTIL_INC_2751: u32 = 2752;
pub const Z_UTIL_INC_2752: u32 = 2753;
pub const Z_UTIL_INC_2753: u32 = 2754;
pub const Z_UTIL_INC_2754: u32 = 2755;
pub const Z_UTIL_INC_2755: u32 = 2756;
pub const Z_UTIL_INC_2756: u32 = 2757;
pub const Z_UTIL_INC_2757: u32 = 2758;
pub const Z_UTIL_INC_2758: u32 = 2759;
pub const Z_UTIL_INC_2759: u32 = 2760;
pub const Z_UTIL_INC_2760: u32 = 2761;
pub const Z_UTIL_INC_2761: u32 = 2762;
pub const Z_UTIL_INC_2762: u32 = 2763;
pub const Z_UTIL_INC_2763: u32 = 2764;
pub const Z_UTIL_INC_2764: u32 = 2765;
pub const Z_UTIL_INC_2765: u32 = 2766;
pub const Z_UTIL_INC_2766: u32 = 2767;
pub const Z_UTIL_INC_2767: u32 = 2768;
pub const Z_UTIL_INC_2768: u32 = 2769;
pub const Z_UTIL_INC_2769: u32 = 2770;
pub const Z_UTIL_INC_2770: u32 = 2771;
pub const Z_UTIL_INC_2771: u32 = 2772;
pub const Z_UTIL_INC_2772: u32 = 2773;
pub const Z_UTIL_INC_2773: u32 = 2774;
pub const Z_UTIL_INC_2774: u32 = 2775;
pub const Z_UTIL_INC_2775: u32 = 2776;
pub const Z_UTIL_INC_2776: u32 = 2777;
pub const Z_UTIL_INC_2777: u32 = 2778;
pub const Z_UTIL_INC_2778: u32 = 2779;
pub const Z_UTIL_INC_2779: u32 = 2780;
pub const Z_UTIL_INC_2780: u32 = 2781;
pub const Z_UTIL_INC_2781: u32 = 2782;
pub const Z_UTIL_INC_2782: u32 = 2783;
pub const Z_UTIL_INC_2783: u32 = 2784;
pub const Z_UTIL_INC_2784: u32 = 2785;
pub const Z_UTIL_INC_2785: u32 = 2786;
pub const Z_UTIL_INC_2786: u32 = 2787;
pub const Z_UTIL_INC_2787: u32 = 2788;
pub const Z_UTIL_INC_2788: u32 = 2789;
pub const Z_UTIL_INC_2789: u32 = 2790;
pub const Z_UTIL_INC_2790: u32 = 2791;
pub const Z_UTIL_INC_2791: u32 = 2792;
pub const Z_UTIL_INC_2792: u32 = 2793;
pub const Z_UTIL_INC_2793: u32 = 2794;
pub const Z_UTIL_INC_2794: u32 = 2795;
pub const Z_UTIL_INC_2795: u32 = 2796;
pub const Z_UTIL_INC_2796: u32 = 2797;
pub const Z_UTIL_INC_2797: u32 = 2798;
pub const Z_UTIL_INC_2798: u32 = 2799;
pub const Z_UTIL_INC_2799: u32 = 2800;
pub const Z_UTIL_INC_2800: u32 = 2801;
pub const Z_UTIL_INC_2801: u32 = 2802;
pub const Z_UTIL_INC_2802: u32 = 2803;
pub const Z_UTIL_INC_2803: u32 = 2804;
pub const Z_UTIL_INC_2804: u32 = 2805;
pub const Z_UTIL_INC_2805: u32 = 2806;
pub const Z_UTIL_INC_2806: u32 = 2807;
pub const Z_UTIL_INC_2807: u32 = 2808;
pub const Z_UTIL_INC_2808: u32 = 2809;
pub const Z_UTIL_INC_2809: u32 = 2810;
pub const Z_UTIL_INC_2810: u32 = 2811;
pub const Z_UTIL_INC_2811: u32 = 2812;
pub const Z_UTIL_INC_2812: u32 = 2813;
pub const Z_UTIL_INC_2813: u32 = 2814;
pub const Z_UTIL_INC_2814: u32 = 2815;
pub const Z_UTIL_INC_2815: u32 = 2816;
pub const Z_UTIL_INC_2816: u32 = 2817;
pub const Z_UTIL_INC_2817: u32 = 2818;
pub const Z_UTIL_INC_2818: u32 = 2819;
pub const Z_UTIL_INC_2819: u32 = 2820;
pub const Z_UTIL_INC_2820: u32 = 2821;
pub const Z_UTIL_INC_2821: u32 = 2822;
pub const Z_UTIL_INC_2822: u32 = 2823;
pub const Z_UTIL_INC_2823: u32 = 2824;
pub const Z_UTIL_INC_2824: u32 = 2825;
pub const Z_UTIL_INC_2825: u32 = 2826;
pub const Z_UTIL_INC_2826: u32 = 2827;
pub const Z_UTIL_INC_2827: u32 = 2828;
pub const Z_UTIL_INC_2828: u32 = 2829;
pub const Z_UTIL_INC_2829: u32 = 2830;
pub const Z_UTIL_INC_2830: u32 = 2831;
pub const Z_UTIL_INC_2831: u32 = 2832;
pub const Z_UTIL_INC_2832: u32 = 2833;
pub const Z_UTIL_INC_2833: u32 = 2834;
pub const Z_UTIL_INC_2834: u32 = 2835;
pub const Z_UTIL_INC_2835: u32 = 2836;
pub const Z_UTIL_INC_2836: u32 = 2837;
pub const Z_UTIL_INC_2837: u32 = 2838;
pub const Z_UTIL_INC_2838: u32 = 2839;
pub const Z_UTIL_INC_2839: u32 = 2840;
pub const Z_UTIL_INC_2840: u32 = 2841;
pub const Z_UTIL_INC_2841: u32 = 2842;
pub const Z_UTIL_INC_2842: u32 = 2843;
pub const Z_UTIL_INC_2843: u32 = 2844;
pub const Z_UTIL_INC_2844: u32 = 2845;
pub const Z_UTIL_INC_2845: u32 = 2846;
pub const Z_UTIL_INC_2846: u32 = 2847;
pub const Z_UTIL_INC_2847: u32 = 2848;
pub const Z_UTIL_INC_2848: u32 = 2849;
pub const Z_UTIL_INC_2849: u32 = 2850;
pub const Z_UTIL_INC_2850: u32 = 2851;
pub const Z_UTIL_INC_2851: u32 = 2852;
pub const Z_UTIL_INC_2852: u32 = 2853;
pub const Z_UTIL_INC_2853: u32 = 2854;
pub const Z_UTIL_INC_2854: u32 = 2855;
pub const Z_UTIL_INC_2855: u32 = 2856;
pub const Z_UTIL_INC_2856: u32 = 2857;
pub const Z_UTIL_INC_2857: u32 = 2858;
pub const Z_UTIL_INC_2858: u32 = 2859;
pub const Z_UTIL_INC_2859: u32 = 2860;
pub const Z_UTIL_INC_2860: u32 = 2861;
pub const Z_UTIL_INC_2861: u32 = 2862;
pub const Z_UTIL_INC_2862: u32 = 2863;
pub const Z_UTIL_INC_2863: u32 = 2864;
pub const Z_UTIL_INC_2864: u32 = 2865;
pub const Z_UTIL_INC_2865: u32 = 2866;
pub const Z_UTIL_INC_2866: u32 = 2867;
pub const Z_UTIL_INC_2867: u32 = 2868;
pub const Z_UTIL_INC_2868: u32 = 2869;
pub const Z_UTIL_INC_2869: u32 = 2870;
pub const Z_UTIL_INC_2870: u32 = 2871;
pub const Z_UTIL_INC_2871: u32 = 2872;
pub const Z_UTIL_INC_2872: u32 = 2873;
pub const Z_UTIL_INC_2873: u32 = 2874;
pub const Z_UTIL_INC_2874: u32 = 2875;
pub const Z_UTIL_INC_2875: u32 = 2876;
pub const Z_UTIL_INC_2876: u32 = 2877;
pub const Z_UTIL_INC_2877: u32 = 2878;
pub const Z_UTIL_INC_2878: u32 = 2879;
pub const Z_UTIL_INC_2879: u32 = 2880;
pub const Z_UTIL_INC_2880: u32 = 2881;
pub const Z_UTIL_INC_2881: u32 = 2882;
pub const Z_UTIL_INC_2882: u32 = 2883;
pub const Z_UTIL_INC_2883: u32 = 2884;
pub const Z_UTIL_INC_2884: u32 = 2885;
pub const Z_UTIL_INC_2885: u32 = 2886;
pub const Z_UTIL_INC_2886: u32 = 2887;
pub const Z_UTIL_INC_2887: u32 = 2888;
pub const Z_UTIL_INC_2888: u32 = 2889;
pub const Z_UTIL_INC_2889: u32 = 2890;
pub const Z_UTIL_INC_2890: u32 = 2891;
pub const Z_UTIL_INC_2891: u32 = 2892;
pub const Z_UTIL_INC_2892: u32 = 2893;
pub const Z_UTIL_INC_2893: u32 = 2894;
pub const Z_UTIL_INC_2894: u32 = 2895;
pub const Z_UTIL_INC_2895: u32 = 2896;
pub const Z_UTIL_INC_2896: u32 = 2897;
pub const Z_UTIL_INC_2897: u32 = 2898;
pub const Z_UTIL_INC_2898: u32 = 2899;
pub const Z_UTIL_INC_2899: u32 = 2900;
pub const Z_UTIL_INC_2900: u32 = 2901;
pub const Z_UTIL_INC_2901: u32 = 2902;
pub const Z_UTIL_INC_2902: u32 = 2903;
pub const Z_UTIL_INC_2903: u32 = 2904;
pub const Z_UTIL_INC_2904: u32 = 2905;
pub const Z_UTIL_INC_2905: u32 = 2906;
pub const Z_UTIL_INC_2906: u32 = 2907;
pub const Z_UTIL_INC_2907: u32 = 2908;
pub const Z_UTIL_INC_2908: u32 = 2909;
pub const Z_UTIL_INC_2909: u32 = 2910;
pub const Z_UTIL_INC_2910: u32 = 2911;
pub const Z_UTIL_INC_2911: u32 = 2912;
pub const Z_UTIL_INC_2912: u32 = 2913;
pub const Z_UTIL_INC_2913: u32 = 2914;
pub const Z_UTIL_INC_2914: u32 = 2915;
pub const Z_UTIL_INC_2915: u32 = 2916;
pub const Z_UTIL_INC_2916: u32 = 2917;
pub const Z_UTIL_INC_2917: u32 = 2918;
pub const Z_UTIL_INC_2918: u32 = 2919;
pub const Z_UTIL_INC_2919: u32 = 2920;
pub const Z_UTIL_INC_2920: u32 = 2921;
pub const Z_UTIL_INC_2921: u32 = 2922;
pub const Z_UTIL_INC_2922: u32 = 2923;
pub const Z_UTIL_INC_2923: u32 = 2924;
pub const Z_UTIL_INC_2924: u32 = 2925;
pub const Z_UTIL_INC_2925: u32 = 2926;
pub const Z_UTIL_INC_2926: u32 = 2927;
pub const Z_UTIL_INC_2927: u32 = 2928;
pub const Z_UTIL_INC_2928: u32 = 2929;
pub const Z_UTIL_INC_2929: u32 = 2930;
pub const Z_UTIL_INC_2930: u32 = 2931;
pub const Z_UTIL_INC_2931: u32 = 2932;
pub const Z_UTIL_INC_2932: u32 = 2933;
pub const Z_UTIL_INC_2933: u32 = 2934;
pub const Z_UTIL_INC_2934: u32 = 2935;
pub const Z_UTIL_INC_2935: u32 = 2936;
pub const Z_UTIL_INC_2936: u32 = 2937;
pub const Z_UTIL_INC_2937: u32 = 2938;
pub const Z_UTIL_INC_2938: u32 = 2939;
pub const Z_UTIL_INC_2939: u32 = 2940;
pub const Z_UTIL_INC_2940: u32 = 2941;
pub const Z_UTIL_INC_2941: u32 = 2942;
pub const Z_UTIL_INC_2942: u32 = 2943;
pub const Z_UTIL_INC_2943: u32 = 2944;
pub const Z_UTIL_INC_2944: u32 = 2945;
pub const Z_UTIL_INC_2945: u32 = 2946;
pub const Z_UTIL_INC_2946: u32 = 2947;
pub const Z_UTIL_INC_2947: u32 = 2948;
pub const Z_UTIL_INC_2948: u32 = 2949;
pub const Z_UTIL_INC_2949: u32 = 2950;
pub const Z_UTIL_INC_2950: u32 = 2951;
pub const Z_UTIL_INC_2951: u32 = 2952;
pub const Z_UTIL_INC_2952: u32 = 2953;
pub const Z_UTIL_INC_2953: u32 = 2954;
pub const Z_UTIL_INC_2954: u32 = 2955;
pub const Z_UTIL_INC_2955: u32 = 2956;
pub const Z_UTIL_INC_2956: u32 = 2957;
pub const Z_UTIL_INC_2957: u32 = 2958;
pub const Z_UTIL_INC_2958: u32 = 2959;
pub const Z_UTIL_INC_2959: u32 = 2960;
pub const Z_UTIL_INC_2960: u32 = 2961;
pub const Z_UTIL_INC_2961: u32 = 2962;
pub const Z_UTIL_INC_2962: u32 = 2963;
pub const Z_UTIL_INC_2963: u32 = 2964;
pub const Z_UTIL_INC_2964: u32 = 2965;
pub const Z_UTIL_INC_2965: u32 = 2966;
pub const Z_UTIL_INC_2966: u32 = 2967;
pub const Z_UTIL_INC_2967: u32 = 2968;
pub const Z_UTIL_INC_2968: u32 = 2969;
pub const Z_UTIL_INC_2969: u32 = 2970;
pub const Z_UTIL_INC_2970: u32 = 2971;
pub const Z_UTIL_INC_2971: u32 = 2972;
pub const Z_UTIL_INC_2972: u32 = 2973;
pub const Z_UTIL_INC_2973: u32 = 2974;
pub const Z_UTIL_INC_2974: u32 = 2975;
pub const Z_UTIL_INC_2975: u32 = 2976;
pub const Z_UTIL_INC_2976: u32 = 2977;
pub const Z_UTIL_INC_2977: u32 = 2978;
pub const Z_UTIL_INC_2978: u32 = 2979;
pub const Z_UTIL_INC_2979: u32 = 2980;
pub const Z_UTIL_INC_2980: u32 = 2981;
pub const Z_UTIL_INC_2981: u32 = 2982;
pub const Z_UTIL_INC_2982: u32 = 2983;
pub const Z_UTIL_INC_2983: u32 = 2984;
pub const Z_UTIL_INC_2984: u32 = 2985;
pub const Z_UTIL_INC_2985: u32 = 2986;
pub const Z_UTIL_INC_2986: u32 = 2987;
pub const Z_UTIL_INC_2987: u32 = 2988;
pub const Z_UTIL_INC_2988: u32 = 2989;
pub const Z_UTIL_INC_2989: u32 = 2990;
pub const Z_UTIL_INC_2990: u32 = 2991;
pub const Z_UTIL_INC_2991: u32 = 2992;
pub const Z_UTIL_INC_2992: u32 = 2993;
pub const Z_UTIL_INC_2993: u32 = 2994;
pub const Z_UTIL_INC_2994: u32 = 2995;
pub const Z_UTIL_INC_2995: u32 = 2996;
pub const Z_UTIL_INC_2996: u32 = 2997;
pub const Z_UTIL_INC_2997: u32 = 2998;
pub const Z_UTIL_INC_2998: u32 = 2999;
pub const Z_UTIL_INC_2999: u32 = 3000;
pub const Z_UTIL_INC_3000: u32 = 3001;
pub const Z_UTIL_INC_3001: u32 = 3002;
pub const Z_UTIL_INC_3002: u32 = 3003;
pub const Z_UTIL_INC_3003: u32 = 3004;
pub const Z_UTIL_INC_3004: u32 = 3005;
pub const Z_UTIL_INC_3005: u32 = 3006;
pub const Z_UTIL_INC_3006: u32 = 3007;
pub const Z_UTIL_INC_3007: u32 = 3008;
pub const Z_UTIL_INC_3008: u32 = 3009;
pub const Z_UTIL_INC_3009: u32 = 3010;
pub const Z_UTIL_INC_3010: u32 = 3011;
pub const Z_UTIL_INC_3011: u32 = 3012;
pub const Z_UTIL_INC_3012: u32 = 3013;
pub const Z_UTIL_INC_3013: u32 = 3014;
pub const Z_UTIL_INC_3014: u32 = 3015;
pub const Z_UTIL_INC_3015: u32 = 3016;
pub const Z_UTIL_INC_3016: u32 = 3017;
pub const Z_UTIL_INC_3017: u32 = 3018;
pub const Z_UTIL_INC_3018: u32 = 3019;
pub const Z_UTIL_INC_3019: u32 = 3020;
pub const Z_UTIL_INC_3020: u32 = 3021;
pub const Z_UTIL_INC_3021: u32 = 3022;
pub const Z_UTIL_INC_3022: u32 = 3023;
pub const Z_UTIL_INC_3023: u32 = 3024;
pub const Z_UTIL_INC_3024: u32 = 3025;
pub const Z_UTIL_INC_3025: u32 = 3026;
pub const Z_UTIL_INC_3026: u32 = 3027;
pub const Z_UTIL_INC_3027: u32 = 3028;
pub const Z_UTIL_INC_3028: u32 = 3029;
pub const Z_UTIL_INC_3029: u32 = 3030;
pub const Z_UTIL_INC_3030: u32 = 3031;
pub const Z_UTIL_INC_3031: u32 = 3032;
pub const Z_UTIL_INC_3032: u32 = 3033;
pub const Z_UTIL_INC_3033: u32 = 3034;
pub const Z_UTIL_INC_3034: u32 = 3035;
pub const Z_UTIL_INC_3035: u32 = 3036;
pub const Z_UTIL_INC_3036: u32 = 3037;
pub const Z_UTIL_INC_3037: u32 = 3038;
pub const Z_UTIL_INC_3038: u32 = 3039;
pub const Z_UTIL_INC_3039: u32 = 3040;
pub const Z_UTIL_INC_3040: u32 = 3041;
pub const Z_UTIL_INC_3041: u32 = 3042;
pub const Z_UTIL_INC_3042: u32 = 3043;
pub const Z_UTIL_INC_3043: u32 = 3044;
pub const Z_UTIL_INC_3044: u32 = 3045;
pub const Z_UTIL_INC_3045: u32 = 3046;
pub const Z_UTIL_INC_3046: u32 = 3047;
pub const Z_UTIL_INC_3047: u32 = 3048;
pub const Z_UTIL_INC_3048: u32 = 3049;
pub const Z_UTIL_INC_3049: u32 = 3050;
pub const Z_UTIL_INC_3050: u32 = 3051;
pub const Z_UTIL_INC_3051: u32 = 3052;
pub const Z_UTIL_INC_3052: u32 = 3053;
pub const Z_UTIL_INC_3053: u32 = 3054;
pub const Z_UTIL_INC_3054: u32 = 3055;
pub const Z_UTIL_INC_3055: u32 = 3056;
pub const Z_UTIL_INC_3056: u32 = 3057;
pub const Z_UTIL_INC_3057: u32 = 3058;
pub const Z_UTIL_INC_3058: u32 = 3059;
pub const Z_UTIL_INC_3059: u32 = 3060;
pub const Z_UTIL_INC_3060: u32 = 3061;
pub const Z_UTIL_INC_3061: u32 = 3062;
pub const Z_UTIL_INC_3062: u32 = 3063;
pub const Z_UTIL_INC_3063: u32 = 3064;
pub const Z_UTIL_INC_3064: u32 = 3065;
pub const Z_UTIL_INC_3065: u32 = 3066;
pub const Z_UTIL_INC_3066: u32 = 3067;
pub const Z_UTIL_INC_3067: u32 = 3068;
pub const Z_UTIL_INC_3068: u32 = 3069;
pub const Z_UTIL_INC_3069: u32 = 3070;
pub const Z_UTIL_INC_3070: u32 = 3071;
pub const Z_UTIL_INC_3071: u32 = 3072;
pub const Z_UTIL_INC_3072: u32 = 3073;
pub const Z_UTIL_INC_3073: u32 = 3074;
pub const Z_UTIL_INC_3074: u32 = 3075;
pub const Z_UTIL_INC_3075: u32 = 3076;
pub const Z_UTIL_INC_3076: u32 = 3077;
pub const Z_UTIL_INC_3077: u32 = 3078;
pub const Z_UTIL_INC_3078: u32 = 3079;
pub const Z_UTIL_INC_3079: u32 = 3080;
pub const Z_UTIL_INC_3080: u32 = 3081;
pub const Z_UTIL_INC_3081: u32 = 3082;
pub const Z_UTIL_INC_3082: u32 = 3083;
pub const Z_UTIL_INC_3083: u32 = 3084;
pub const Z_UTIL_INC_3084: u32 = 3085;
pub const Z_UTIL_INC_3085: u32 = 3086;
pub const Z_UTIL_INC_3086: u32 = 3087;
pub const Z_UTIL_INC_3087: u32 = 3088;
pub const Z_UTIL_INC_3088: u32 = 3089;
pub const Z_UTIL_INC_3089: u32 = 3090;
pub const Z_UTIL_INC_3090: u32 = 3091;
pub const Z_UTIL_INC_3091: u32 = 3092;
pub const Z_UTIL_INC_3092: u32 = 3093;
pub const Z_UTIL_INC_3093: u32 = 3094;
pub const Z_UTIL_INC_3094: u32 = 3095;
pub const Z_UTIL_INC_3095: u32 = 3096;
pub const Z_UTIL_INC_3096: u32 = 3097;
pub const Z_UTIL_INC_3097: u32 = 3098;
pub const Z_UTIL_INC_3098: u32 = 3099;
pub const Z_UTIL_INC_3099: u32 = 3100;
pub const Z_UTIL_INC_3100: u32 = 3101;
pub const Z_UTIL_INC_3101: u32 = 3102;
pub const Z_UTIL_INC_3102: u32 = 3103;
pub const Z_UTIL_INC_3103: u32 = 3104;
pub const Z_UTIL_INC_3104: u32 = 3105;
pub const Z_UTIL_INC_3105: u32 = 3106;
pub const Z_UTIL_INC_3106: u32 = 3107;
pub const Z_UTIL_INC_3107: u32 = 3108;
pub const Z_UTIL_INC_3108: u32 = 3109;
pub const Z_UTIL_INC_3109: u32 = 3110;
pub const Z_UTIL_INC_3110: u32 = 3111;
pub const Z_UTIL_INC_3111: u32 = 3112;
pub const Z_UTIL_INC_3112: u32 = 3113;
pub const Z_UTIL_INC_3113: u32 = 3114;
pub const Z_UTIL_INC_3114: u32 = 3115;
pub const Z_UTIL_INC_3115: u32 = 3116;
pub const Z_UTIL_INC_3116: u32 = 3117;
pub const Z_UTIL_INC_3117: u32 = 3118;
pub const Z_UTIL_INC_3118: u32 = 3119;
pub const Z_UTIL_INC_3119: u32 = 3120;
pub const Z_UTIL_INC_3120: u32 = 3121;
pub const Z_UTIL_INC_3121: u32 = 3122;
pub const Z_UTIL_INC_3122: u32 = 3123;
pub const Z_UTIL_INC_3123: u32 = 3124;
pub const Z_UTIL_INC_3124: u32 = 3125;
pub const Z_UTIL_INC_3125: u32 = 3126;
pub const Z_UTIL_INC_3126: u32 = 3127;
pub const Z_UTIL_INC_3127: u32 = 3128;
pub const Z_UTIL_INC_3128: u32 = 3129;
pub const Z_UTIL_INC_3129: u32 = 3130;
pub const Z_UTIL_INC_3130: u32 = 3131;
pub const Z_UTIL_INC_3131: u32 = 3132;
pub const Z_UTIL_INC_3132: u32 = 3133;
pub const Z_UTIL_INC_3133: u32 = 3134;
pub const Z_UTIL_INC_3134: u32 = 3135;
pub const Z_UTIL_INC_3135: u32 = 3136;
pub const Z_UTIL_INC_3136: u32 = 3137;
pub const Z_UTIL_INC_3137: u32 = 3138;
pub const Z_UTIL_INC_3138: u32 = 3139;
pub const Z_UTIL_INC_3139: u32 = 3140;
pub const Z_UTIL_INC_3140: u32 = 3141;
pub const Z_UTIL_INC_3141: u32 = 3142;
pub const Z_UTIL_INC_3142: u32 = 3143;
pub const Z_UTIL_INC_3143: u32 = 3144;
pub const Z_UTIL_INC_3144: u32 = 3145;
pub const Z_UTIL_INC_3145: u32 = 3146;
pub const Z_UTIL_INC_3146: u32 = 3147;
pub const Z_UTIL_INC_3147: u32 = 3148;
pub const Z_UTIL_INC_3148: u32 = 3149;
pub const Z_UTIL_INC_3149: u32 = 3150;
pub const Z_UTIL_INC_3150: u32 = 3151;
pub const Z_UTIL_INC_3151: u32 = 3152;
pub const Z_UTIL_INC_3152: u32 = 3153;
pub const Z_UTIL_INC_3153: u32 = 3154;
pub const Z_UTIL_INC_3154: u32 = 3155;
pub const Z_UTIL_INC_3155: u32 = 3156;
pub const Z_UTIL_INC_3156: u32 = 3157;
pub const Z_UTIL_INC_3157: u32 = 3158;
pub const Z_UTIL_INC_3158: u32 = 3159;
pub const Z_UTIL_INC_3159: u32 = 3160;
pub const Z_UTIL_INC_3160: u32 = 3161;
pub const Z_UTIL_INC_3161: u32 = 3162;
pub const Z_UTIL_INC_3162: u32 = 3163;
pub const Z_UTIL_INC_3163: u32 = 3164;
pub const Z_UTIL_INC_3164: u32 = 3165;
pub const Z_UTIL_INC_3165: u32 = 3166;
pub const Z_UTIL_INC_3166: u32 = 3167;
pub const Z_UTIL_INC_3167: u32 = 3168;
pub const Z_UTIL_INC_3168: u32 = 3169;
pub const Z_UTIL_INC_3169: u32 = 3170;
pub const Z_UTIL_INC_3170: u32 = 3171;
pub const Z_UTIL_INC_3171: u32 = 3172;
pub const Z_UTIL_INC_3172: u32 = 3173;
pub const Z_UTIL_INC_3173: u32 = 3174;
pub const Z_UTIL_INC_3174: u32 = 3175;
pub const Z_UTIL_INC_3175: u32 = 3176;
pub const Z_UTIL_INC_3176: u32 = 3177;
pub const Z_UTIL_INC_3177: u32 = 3178;
pub const Z_UTIL_INC_3178: u32 = 3179;
pub const Z_UTIL_INC_3179: u32 = 3180;
pub const Z_UTIL_INC_3180: u32 = 3181;
pub const Z_UTIL_INC_3181: u32 = 3182;
pub const Z_UTIL_INC_3182: u32 = 3183;
pub const Z_UTIL_INC_3183: u32 = 3184;
pub const Z_UTIL_INC_3184: u32 = 3185;
pub const Z_UTIL_INC_3185: u32 = 3186;
pub const Z_UTIL_INC_3186: u32 = 3187;
pub const Z_UTIL_INC_3187: u32 = 3188;
pub const Z_UTIL_INC_3188: u32 = 3189;
pub const Z_UTIL_INC_3189: u32 = 3190;
pub const Z_UTIL_INC_3190: u32 = 3191;
pub const Z_UTIL_INC_3191: u32 = 3192;
pub const Z_UTIL_INC_3192: u32 = 3193;
pub const Z_UTIL_INC_3193: u32 = 3194;
pub const Z_UTIL_INC_3194: u32 = 3195;
pub const Z_UTIL_INC_3195: u32 = 3196;
pub const Z_UTIL_INC_3196: u32 = 3197;
pub const Z_UTIL_INC_3197: u32 = 3198;
pub const Z_UTIL_INC_3198: u32 = 3199;
pub const Z_UTIL_INC_3199: u32 = 3200;
pub const Z_UTIL_INC_3200: u32 = 3201;
pub const Z_UTIL_INC_3201: u32 = 3202;
pub const Z_UTIL_INC_3202: u32 = 3203;
pub const Z_UTIL_INC_3203: u32 = 3204;
pub const Z_UTIL_INC_3204: u32 = 3205;
pub const Z_UTIL_INC_3205: u32 = 3206;
pub const Z_UTIL_INC_3206: u32 = 3207;
pub const Z_UTIL_INC_3207: u32 = 3208;
pub const Z_UTIL_INC_3208: u32 = 3209;
pub const Z_UTIL_INC_3209: u32 = 3210;
pub const Z_UTIL_INC_3210: u32 = 3211;
pub const Z_UTIL_INC_3211: u32 = 3212;
pub const Z_UTIL_INC_3212: u32 = 3213;
pub const Z_UTIL_INC_3213: u32 = 3214;
pub const Z_UTIL_INC_3214: u32 = 3215;
pub const Z_UTIL_INC_3215: u32 = 3216;
pub const Z_UTIL_INC_3216: u32 = 3217;
pub const Z_UTIL_INC_3217: u32 = 3218;
pub const Z_UTIL_INC_3218: u32 = 3219;
pub const Z_UTIL_INC_3219: u32 = 3220;
pub const Z_UTIL_INC_3220: u32 = 3221;
pub const Z_UTIL_INC_3221: u32 = 3222;
pub const Z_UTIL_INC_3222: u32 = 3223;
pub const Z_UTIL_INC_3223: u32 = 3224;
pub const Z_UTIL_INC_3224: u32 = 3225;
pub const Z_UTIL_INC_3225: u32 = 3226;
pub const Z_UTIL_INC_3226: u32 = 3227;
pub const Z_UTIL_INC_3227: u32 = 3228;
pub const Z_UTIL_INC_3228: u32 = 3229;
pub const Z_UTIL_INC_3229: u32 = 3230;
pub const Z_UTIL_INC_3230: u32 = 3231;
pub const Z_UTIL_INC_3231: u32 = 3232;
pub const Z_UTIL_INC_3232: u32 = 3233;
pub const Z_UTIL_INC_3233: u32 = 3234;
pub const Z_UTIL_INC_3234: u32 = 3235;
pub const Z_UTIL_INC_3235: u32 = 3236;
pub const Z_UTIL_INC_3236: u32 = 3237;
pub const Z_UTIL_INC_3237: u32 = 3238;
pub const Z_UTIL_INC_3238: u32 = 3239;
pub const Z_UTIL_INC_3239: u32 = 3240;
pub const Z_UTIL_INC_3240: u32 = 3241;
pub const Z_UTIL_INC_3241: u32 = 3242;
pub const Z_UTIL_INC_3242: u32 = 3243;
pub const Z_UTIL_INC_3243: u32 = 3244;
pub const Z_UTIL_INC_3244: u32 = 3245;
pub const Z_UTIL_INC_3245: u32 = 3246;
pub const Z_UTIL_INC_3246: u32 = 3247;
pub const Z_UTIL_INC_3247: u32 = 3248;
pub const Z_UTIL_INC_3248: u32 = 3249;
pub const Z_UTIL_INC_3249: u32 = 3250;
pub const Z_UTIL_INC_3250: u32 = 3251;
pub const Z_UTIL_INC_3251: u32 = 3252;
pub const Z_UTIL_INC_3252: u32 = 3253;
pub const Z_UTIL_INC_3253: u32 = 3254;
pub const Z_UTIL_INC_3254: u32 = 3255;
pub const Z_UTIL_INC_3255: u32 = 3256;
pub const Z_UTIL_INC_3256: u32 = 3257;
pub const Z_UTIL_INC_3257: u32 = 3258;
pub const Z_UTIL_INC_3258: u32 = 3259;
pub const Z_UTIL_INC_3259: u32 = 3260;
pub const Z_UTIL_INC_3260: u32 = 3261;
pub const Z_UTIL_INC_3261: u32 = 3262;
pub const Z_UTIL_INC_3262: u32 = 3263;
pub const Z_UTIL_INC_3263: u32 = 3264;
pub const Z_UTIL_INC_3264: u32 = 3265;
pub const Z_UTIL_INC_3265: u32 = 3266;
pub const Z_UTIL_INC_3266: u32 = 3267;
pub const Z_UTIL_INC_3267: u32 = 3268;
pub const Z_UTIL_INC_3268: u32 = 3269;
pub const Z_UTIL_INC_3269: u32 = 3270;
pub const Z_UTIL_INC_3270: u32 = 3271;
pub const Z_UTIL_INC_3271: u32 = 3272;
pub const Z_UTIL_INC_3272: u32 = 3273;
pub const Z_UTIL_INC_3273: u32 = 3274;
pub const Z_UTIL_INC_3274: u32 = 3275;
pub const Z_UTIL_INC_3275: u32 = 3276;
pub const Z_UTIL_INC_3276: u32 = 3277;
pub const Z_UTIL_INC_3277: u32 = 3278;
pub const Z_UTIL_INC_3278: u32 = 3279;
pub const Z_UTIL_INC_3279: u32 = 3280;
pub const Z_UTIL_INC_3280: u32 = 3281;
pub const Z_UTIL_INC_3281: u32 = 3282;
pub const Z_UTIL_INC_3282: u32 = 3283;
pub const Z_UTIL_INC_3283: u32 = 3284;
pub const Z_UTIL_INC_3284: u32 = 3285;
pub const Z_UTIL_INC_3285: u32 = 3286;
pub const Z_UTIL_INC_3286: u32 = 3287;
pub const Z_UTIL_INC_3287: u32 = 3288;
pub const Z_UTIL_INC_3288: u32 = 3289;
pub const Z_UTIL_INC_3289: u32 = 3290;
pub const Z_UTIL_INC_3290: u32 = 3291;
pub const Z_UTIL_INC_3291: u32 = 3292;
pub const Z_UTIL_INC_3292: u32 = 3293;
pub const Z_UTIL_INC_3293: u32 = 3294;
pub const Z_UTIL_INC_3294: u32 = 3295;
pub const Z_UTIL_INC_3295: u32 = 3296;
pub const Z_UTIL_INC_3296: u32 = 3297;
pub const Z_UTIL_INC_3297: u32 = 3298;
pub const Z_UTIL_INC_3298: u32 = 3299;
pub const Z_UTIL_INC_3299: u32 = 3300;
pub const Z_UTIL_INC_3300: u32 = 3301;
pub const Z_UTIL_INC_3301: u32 = 3302;
pub const Z_UTIL_INC_3302: u32 = 3303;
pub const Z_UTIL_INC_3303: u32 = 3304;
pub const Z_UTIL_INC_3304: u32 = 3305;
pub const Z_UTIL_INC_3305: u32 = 3306;
pub const Z_UTIL_INC_3306: u32 = 3307;
pub const Z_UTIL_INC_3307: u32 = 3308;
pub const Z_UTIL_INC_3308: u32 = 3309;
pub const Z_UTIL_INC_3309: u32 = 3310;
pub const Z_UTIL_INC_3310: u32 = 3311;
pub const Z_UTIL_INC_3311: u32 = 3312;
pub const Z_UTIL_INC_3312: u32 = 3313;
pub const Z_UTIL_INC_3313: u32 = 3314;
pub const Z_UTIL_INC_3314: u32 = 3315;
pub const Z_UTIL_INC_3315: u32 = 3316;
pub const Z_UTIL_INC_3316: u32 = 3317;
pub const Z_UTIL_INC_3317: u32 = 3318;
pub const Z_UTIL_INC_3318: u32 = 3319;
pub const Z_UTIL_INC_3319: u32 = 3320;
pub const Z_UTIL_INC_3320: u32 = 3321;
pub const Z_UTIL_INC_3321: u32 = 3322;
pub const Z_UTIL_INC_3322: u32 = 3323;
pub const Z_UTIL_INC_3323: u32 = 3324;
pub const Z_UTIL_INC_3324: u32 = 3325;
pub const Z_UTIL_INC_3325: u32 = 3326;
pub const Z_UTIL_INC_3326: u32 = 3327;
pub const Z_UTIL_INC_3327: u32 = 3328;
pub const Z_UTIL_INC_3328: u32 = 3329;
pub const Z_UTIL_INC_3329: u32 = 3330;
pub const Z_UTIL_INC_3330: u32 = 3331;
pub const Z_UTIL_INC_3331: u32 = 3332;
pub const Z_UTIL_INC_3332: u32 = 3333;
pub const Z_UTIL_INC_3333: u32 = 3334;
pub const Z_UTIL_INC_3334: u32 = 3335;
pub const Z_UTIL_INC_3335: u32 = 3336;
pub const Z_UTIL_INC_3336: u32 = 3337;
pub const Z_UTIL_INC_3337: u32 = 3338;
pub const Z_UTIL_INC_3338: u32 = 3339;
pub const Z_UTIL_INC_3339: u32 = 3340;
pub const Z_UTIL_INC_3340: u32 = 3341;
pub const Z_UTIL_INC_3341: u32 = 3342;
pub const Z_UTIL_INC_3342: u32 = 3343;
pub const Z_UTIL_INC_3343: u32 = 3344;
pub const Z_UTIL_INC_3344: u32 = 3345;
pub const Z_UTIL_INC_3345: u32 = 3346;
pub const Z_UTIL_INC_3346: u32 = 3347;
pub const Z_UTIL_INC_3347: u32 = 3348;
pub const Z_UTIL_INC_3348: u32 = 3349;
pub const Z_UTIL_INC_3349: u32 = 3350;
pub const Z_UTIL_INC_3350: u32 = 3351;
pub const Z_UTIL_INC_3351: u32 = 3352;
pub const Z_UTIL_INC_3352: u32 = 3353;
pub const Z_UTIL_INC_3353: u32 = 3354;
pub const Z_UTIL_INC_3354: u32 = 3355;
pub const Z_UTIL_INC_3355: u32 = 3356;
pub const Z_UTIL_INC_3356: u32 = 3357;
pub const Z_UTIL_INC_3357: u32 = 3358;
pub const Z_UTIL_INC_3358: u32 = 3359;
pub const Z_UTIL_INC_3359: u32 = 3360;
pub const Z_UTIL_INC_3360: u32 = 3361;
pub const Z_UTIL_INC_3361: u32 = 3362;
pub const Z_UTIL_INC_3362: u32 = 3363;
pub const Z_UTIL_INC_3363: u32 = 3364;
pub const Z_UTIL_INC_3364: u32 = 3365;
pub const Z_UTIL_INC_3365: u32 = 3366;
pub const Z_UTIL_INC_3366: u32 = 3367;
pub const Z_UTIL_INC_3367: u32 = 3368;
pub const Z_UTIL_INC_3368: u32 = 3369;
pub const Z_UTIL_INC_3369: u32 = 3370;
pub const Z_UTIL_INC_3370: u32 = 3371;
pub const Z_UTIL_INC_3371: u32 = 3372;
pub const Z_UTIL_INC_3372: u32 = 3373;
pub const Z_UTIL_INC_3373: u32 = 3374;
pub const Z_UTIL_INC_3374: u32 = 3375;
pub const Z_UTIL_INC_3375: u32 = 3376;
pub const Z_UTIL_INC_3376: u32 = 3377;
pub const Z_UTIL_INC_3377: u32 = 3378;
pub const Z_UTIL_INC_3378: u32 = 3379;
pub const Z_UTIL_INC_3379: u32 = 3380;
pub const Z_UTIL_INC_3380: u32 = 3381;
pub const Z_UTIL_INC_3381: u32 = 3382;
pub const Z_UTIL_INC_3382: u32 = 3383;
pub const Z_UTIL_INC_3383: u32 = 3384;
pub const Z_UTIL_INC_3384: u32 = 3385;
pub const Z_UTIL_INC_3385: u32 = 3386;
pub const Z_UTIL_INC_3386: u32 = 3387;
pub const Z_UTIL_INC_3387: u32 = 3388;
pub const Z_UTIL_INC_3388: u32 = 3389;
pub const Z_UTIL_INC_3389: u32 = 3390;
pub const Z_UTIL_INC_3390: u32 = 3391;
pub const Z_UTIL_INC_3391: u32 = 3392;
pub const Z_UTIL_INC_3392: u32 = 3393;
pub const Z_UTIL_INC_3393: u32 = 3394;
pub const Z_UTIL_INC_3394: u32 = 3395;
pub const Z_UTIL_INC_3395: u32 = 3396;
pub const Z_UTIL_INC_3396: u32 = 3397;
pub const Z_UTIL_INC_3397: u32 = 3398;
pub const Z_UTIL_INC_3398: u32 = 3399;
pub const Z_UTIL_INC_3399: u32 = 3400;
pub const Z_UTIL_INC_3400: u32 = 3401;
pub const Z_UTIL_INC_3401: u32 = 3402;
pub const Z_UTIL_INC_3402: u32 = 3403;
pub const Z_UTIL_INC_3403: u32 = 3404;
pub const Z_UTIL_INC_3404: u32 = 3405;
pub const Z_UTIL_INC_3405: u32 = 3406;
pub const Z_UTIL_INC_3406: u32 = 3407;
pub const Z_UTIL_INC_3407: u32 = 3408;
pub const Z_UTIL_INC_3408: u32 = 3409;
pub const Z_UTIL_INC_3409: u32 = 3410;
pub const Z_UTIL_INC_3410: u32 = 3411;
pub const Z_UTIL_INC_3411: u32 = 3412;
pub const Z_UTIL_INC_3412: u32 = 3413;
pub const Z_UTIL_INC_3413: u32 = 3414;
pub const Z_UTIL_INC_3414: u32 = 3415;
pub const Z_UTIL_INC_3415: u32 = 3416;
pub const Z_UTIL_INC_3416: u32 = 3417;
pub const Z_UTIL_INC_3417: u32 = 3418;
pub const Z_UTIL_INC_3418: u32 = 3419;
pub const Z_UTIL_INC_3419: u32 = 3420;
pub const Z_UTIL_INC_3420: u32 = 3421;
pub const Z_UTIL_INC_3421: u32 = 3422;
pub const Z_UTIL_INC_3422: u32 = 3423;
pub const Z_UTIL_INC_3423: u32 = 3424;
pub const Z_UTIL_INC_3424: u32 = 3425;
pub const Z_UTIL_INC_3425: u32 = 3426;
pub const Z_UTIL_INC_3426: u32 = 3427;
pub const Z_UTIL_INC_3427: u32 = 3428;
pub const Z_UTIL_INC_3428: u32 = 3429;
pub const Z_UTIL_INC_3429: u32 = 3430;
pub const Z_UTIL_INC_3430: u32 = 3431;
pub const Z_UTIL_INC_3431: u32 = 3432;
pub const Z_UTIL_INC_3432: u32 = 3433;
pub const Z_UTIL_INC_3433: u32 = 3434;
pub const Z_UTIL_INC_3434: u32 = 3435;
pub const Z_UTIL_INC_3435: u32 = 3436;
pub const Z_UTIL_INC_3436: u32 = 3437;
pub const Z_UTIL_INC_3437: u32 = 3438;
pub const Z_UTIL_INC_3438: u32 = 3439;
pub const Z_UTIL_INC_3439: u32 = 3440;
pub const Z_UTIL_INC_3440: u32 = 3441;
pub const Z_UTIL_INC_3441: u32 = 3442;
pub const Z_UTIL_INC_3442: u32 = 3443;
pub const Z_UTIL_INC_3443: u32 = 3444;
pub const Z_UTIL_INC_3444: u32 = 3445;
pub const Z_UTIL_INC_3445: u32 = 3446;
pub const Z_UTIL_INC_3446: u32 = 3447;
pub const Z_UTIL_INC_3447: u32 = 3448;
pub const Z_UTIL_INC_3448: u32 = 3449;
pub const Z_UTIL_INC_3449: u32 = 3450;
pub const Z_UTIL_INC_3450: u32 = 3451;
pub const Z_UTIL_INC_3451: u32 = 3452;
pub const Z_UTIL_INC_3452: u32 = 3453;
pub const Z_UTIL_INC_3453: u32 = 3454;
pub const Z_UTIL_INC_3454: u32 = 3455;
pub const Z_UTIL_INC_3455: u32 = 3456;
pub const Z_UTIL_INC_3456: u32 = 3457;
pub const Z_UTIL_INC_3457: u32 = 3458;
pub const Z_UTIL_INC_3458: u32 = 3459;
pub const Z_UTIL_INC_3459: u32 = 3460;
pub const Z_UTIL_INC_3460: u32 = 3461;
pub const Z_UTIL_INC_3461: u32 = 3462;
pub const Z_UTIL_INC_3462: u32 = 3463;
pub const Z_UTIL_INC_3463: u32 = 3464;
pub const Z_UTIL_INC_3464: u32 = 3465;
pub const Z_UTIL_INC_3465: u32 = 3466;
pub const Z_UTIL_INC_3466: u32 = 3467;
pub const Z_UTIL_INC_3467: u32 = 3468;
pub const Z_UTIL_INC_3468: u32 = 3469;
pub const Z_UTIL_INC_3469: u32 = 3470;
pub const Z_UTIL_INC_3470: u32 = 3471;
pub const Z_UTIL_INC_3471: u32 = 3472;
pub const Z_UTIL_INC_3472: u32 = 3473;
pub const Z_UTIL_INC_3473: u32 = 3474;
pub const Z_UTIL_INC_3474: u32 = 3475;
pub const Z_UTIL_INC_3475: u32 = 3476;
pub const Z_UTIL_INC_3476: u32 = 3477;
pub const Z_UTIL_INC_3477: u32 = 3478;
pub const Z_UTIL_INC_3478: u32 = 3479;
pub const Z_UTIL_INC_3479: u32 = 3480;
pub const Z_UTIL_INC_3480: u32 = 3481;
pub const Z_UTIL_INC_3481: u32 = 3482;
pub const Z_UTIL_INC_3482: u32 = 3483;
pub const Z_UTIL_INC_3483: u32 = 3484;
pub const Z_UTIL_INC_3484: u32 = 3485;
pub const Z_UTIL_INC_3485: u32 = 3486;
pub const Z_UTIL_INC_3486: u32 = 3487;
pub const Z_UTIL_INC_3487: u32 = 3488;
pub const Z_UTIL_INC_3488: u32 = 3489;
pub const Z_UTIL_INC_3489: u32 = 3490;
pub const Z_UTIL_INC_3490: u32 = 3491;
pub const Z_UTIL_INC_3491: u32 = 3492;
pub const Z_UTIL_INC_3492: u32 = 3493;
pub const Z_UTIL_INC_3493: u32 = 3494;
pub const Z_UTIL_INC_3494: u32 = 3495;
pub const Z_UTIL_INC_3495: u32 = 3496;
pub const Z_UTIL_INC_3496: u32 = 3497;
pub const Z_UTIL_INC_3497: u32 = 3498;
pub const Z_UTIL_INC_3498: u32 = 3499;
pub const Z_UTIL_INC_3499: u32 = 3500;
pub const Z_UTIL_INC_3500: u32 = 3501;
pub const Z_UTIL_INC_3501: u32 = 3502;
pub const Z_UTIL_INC_3502: u32 = 3503;
pub const Z_UTIL_INC_3503: u32 = 3504;
pub const Z_UTIL_INC_3504: u32 = 3505;
pub const Z_UTIL_INC_3505: u32 = 3506;
pub const Z_UTIL_INC_3506: u32 = 3507;
pub const Z_UTIL_INC_3507: u32 = 3508;
pub const Z_UTIL_INC_3508: u32 = 3509;
pub const Z_UTIL_INC_3509: u32 = 3510;
pub const Z_UTIL_INC_3510: u32 = 3511;
pub const Z_UTIL_INC_3511: u32 = 3512;
pub const Z_UTIL_INC_3512: u32 = 3513;
pub const Z_UTIL_INC_3513: u32 = 3514;
pub const Z_UTIL_INC_3514: u32 = 3515;
pub const Z_UTIL_INC_3515: u32 = 3516;
pub const Z_UTIL_INC_3516: u32 = 3517;
pub const Z_UTIL_INC_3517: u32 = 3518;
pub const Z_UTIL_INC_3518: u32 = 3519;
pub const Z_UTIL_INC_3519: u32 = 3520;
pub const Z_UTIL_INC_3520: u32 = 3521;
pub const Z_UTIL_INC_3521: u32 = 3522;
pub const Z_UTIL_INC_3522: u32 = 3523;
pub const Z_UTIL_INC_3523: u32 = 3524;
pub const Z_UTIL_INC_3524: u32 = 3525;
pub const Z_UTIL_INC_3525: u32 = 3526;
pub const Z_UTIL_INC_3526: u32 = 3527;
pub const Z_UTIL_INC_3527: u32 = 3528;
pub const Z_UTIL_INC_3528: u32 = 3529;
pub const Z_UTIL_INC_3529: u32 = 3530;
pub const Z_UTIL_INC_3530: u32 = 3531;
pub const Z_UTIL_INC_3531: u32 = 3532;
pub const Z_UTIL_INC_3532: u32 = 3533;
pub const Z_UTIL_INC_3533: u32 = 3534;
pub const Z_UTIL_INC_3534: u32 = 3535;
pub const Z_UTIL_INC_3535: u32 = 3536;
pub const Z_UTIL_INC_3536: u32 = 3537;
pub const Z_UTIL_INC_3537: u32 = 3538;
pub const Z_UTIL_INC_3538: u32 = 3539;
pub const Z_UTIL_INC_3539: u32 = 3540;
pub const Z_UTIL_INC_3540: u32 = 3541;
pub const Z_UTIL_INC_3541: u32 = 3542;
pub const Z_UTIL_INC_3542: u32 = 3543;
pub const Z_UTIL_INC_3543: u32 = 3544;
pub const Z_UTIL_INC_3544: u32 = 3545;
pub const Z_UTIL_INC_3545: u32 = 3546;
pub const Z_UTIL_INC_3546: u32 = 3547;
pub const Z_UTIL_INC_3547: u32 = 3548;
pub const Z_UTIL_INC_3548: u32 = 3549;
pub const Z_UTIL_INC_3549: u32 = 3550;
pub const Z_UTIL_INC_3550: u32 = 3551;
pub const Z_UTIL_INC_3551: u32 = 3552;
pub const Z_UTIL_INC_3552: u32 = 3553;
pub const Z_UTIL_INC_3553: u32 = 3554;
pub const Z_UTIL_INC_3554: u32 = 3555;
pub const Z_UTIL_INC_3555: u32 = 3556;
pub const Z_UTIL_INC_3556: u32 = 3557;
pub const Z_UTIL_INC_3557: u32 = 3558;
pub const Z_UTIL_INC_3558: u32 = 3559;
pub const Z_UTIL_INC_3559: u32 = 3560;
pub const Z_UTIL_INC_3560: u32 = 3561;
pub const Z_UTIL_INC_3561: u32 = 3562;
pub const Z_UTIL_INC_3562: u32 = 3563;
pub const Z_UTIL_INC_3563: u32 = 3564;
pub const Z_UTIL_INC_3564: u32 = 3565;
pub const Z_UTIL_INC_3565: u32 = 3566;
pub const Z_UTIL_INC_3566: u32 = 3567;
pub const Z_UTIL_INC_3567: u32 = 3568;
pub const Z_UTIL_INC_3568: u32 = 3569;
pub const Z_UTIL_INC_3569: u32 = 3570;
pub const Z_UTIL_INC_3570: u32 = 3571;
pub const Z_UTIL_INC_3571: u32 = 3572;
pub const Z_UTIL_INC_3572: u32 = 3573;
pub const Z_UTIL_INC_3573: u32 = 3574;
pub const Z_UTIL_INC_3574: u32 = 3575;
pub const Z_UTIL_INC_3575: u32 = 3576;
pub const Z_UTIL_INC_3576: u32 = 3577;
pub const Z_UTIL_INC_3577: u32 = 3578;
pub const Z_UTIL_INC_3578: u32 = 3579;
pub const Z_UTIL_INC_3579: u32 = 3580;
pub const Z_UTIL_INC_3580: u32 = 3581;
pub const Z_UTIL_INC_3581: u32 = 3582;
pub const Z_UTIL_INC_3582: u32 = 3583;
pub const Z_UTIL_INC_3583: u32 = 3584;
pub const Z_UTIL_INC_3584: u32 = 3585;
pub const Z_UTIL_INC_3585: u32 = 3586;
pub const Z_UTIL_INC_3586: u32 = 3587;
pub const Z_UTIL_INC_3587: u32 = 3588;
pub const Z_UTIL_INC_3588: u32 = 3589;
pub const Z_UTIL_INC_3589: u32 = 3590;
pub const Z_UTIL_INC_3590: u32 = 3591;
pub const Z_UTIL_INC_3591: u32 = 3592;
pub const Z_UTIL_INC_3592: u32 = 3593;
pub const Z_UTIL_INC_3593: u32 = 3594;
pub const Z_UTIL_INC_3594: u32 = 3595;
pub const Z_UTIL_INC_3595: u32 = 3596;
pub const Z_UTIL_INC_3596: u32 = 3597;
pub const Z_UTIL_INC_3597: u32 = 3598;
pub const Z_UTIL_INC_3598: u32 = 3599;
pub const Z_UTIL_INC_3599: u32 = 3600;
pub const Z_UTIL_INC_3600: u32 = 3601;
pub const Z_UTIL_INC_3601: u32 = 3602;
pub const Z_UTIL_INC_3602: u32 = 3603;
pub const Z_UTIL_INC_3603: u32 = 3604;
pub const Z_UTIL_INC_3604: u32 = 3605;
pub const Z_UTIL_INC_3605: u32 = 3606;
pub const Z_UTIL_INC_3606: u32 = 3607;
pub const Z_UTIL_INC_3607: u32 = 3608;
pub const Z_UTIL_INC_3608: u32 = 3609;
pub const Z_UTIL_INC_3609: u32 = 3610;
pub const Z_UTIL_INC_3610: u32 = 3611;
pub const Z_UTIL_INC_3611: u32 = 3612;
pub const Z_UTIL_INC_3612: u32 = 3613;
pub const Z_UTIL_INC_3613: u32 = 3614;
pub const Z_UTIL_INC_3614: u32 = 3615;
pub const Z_UTIL_INC_3615: u32 = 3616;
pub const Z_UTIL_INC_3616: u32 = 3617;
pub const Z_UTIL_INC_3617: u32 = 3618;
pub const Z_UTIL_INC_3618: u32 = 3619;
pub const Z_UTIL_INC_3619: u32 = 3620;
pub const Z_UTIL_INC_3620: u32 = 3621;
pub const Z_UTIL_INC_3621: u32 = 3622;
pub const Z_UTIL_INC_3622: u32 = 3623;
pub const Z_UTIL_INC_3623: u32 = 3624;
pub const Z_UTIL_INC_3624: u32 = 3625;
pub const Z_UTIL_INC_3625: u32 = 3626;
pub const Z_UTIL_INC_3626: u32 = 3627;
pub const Z_UTIL_INC_3627: u32 = 3628;
pub const Z_UTIL_INC_3628: u32 = 3629;
pub const Z_UTIL_INC_3629: u32 = 3630;
pub const Z_UTIL_INC_3630: u32 = 3631;
pub const Z_UTIL_INC_3631: u32 = 3632;
pub const Z_UTIL_INC_3632: u32 = 3633;
pub const Z_UTIL_INC_3633: u32 = 3634;
pub const Z_UTIL_INC_3634: u32 = 3635;
pub const Z_UTIL_INC_3635: u32 = 3636;
pub const Z_UTIL_INC_3636: u32 = 3637;
pub const Z_UTIL_INC_3637: u32 = 3638;
pub const Z_UTIL_INC_3638: u32 = 3639;
pub const Z_UTIL_INC_3639: u32 = 3640;
pub const Z_UTIL_INC_3640: u32 = 3641;
pub const Z_UTIL_INC_3641: u32 = 3642;
pub const Z_UTIL_INC_3642: u32 = 3643;
pub const Z_UTIL_INC_3643: u32 = 3644;
pub const Z_UTIL_INC_3644: u32 = 3645;
pub const Z_UTIL_INC_3645: u32 = 3646;
pub const Z_UTIL_INC_3646: u32 = 3647;
pub const Z_UTIL_INC_3647: u32 = 3648;
pub const Z_UTIL_INC_3648: u32 = 3649;
pub const Z_UTIL_INC_3649: u32 = 3650;
pub const Z_UTIL_INC_3650: u32 = 3651;
pub const Z_UTIL_INC_3651: u32 = 3652;
pub const Z_UTIL_INC_3652: u32 = 3653;
pub const Z_UTIL_INC_3653: u32 = 3654;
pub const Z_UTIL_INC_3654: u32 = 3655;
pub const Z_UTIL_INC_3655: u32 = 3656;
pub const Z_UTIL_INC_3656: u32 = 3657;
pub const Z_UTIL_INC_3657: u32 = 3658;
pub const Z_UTIL_INC_3658: u32 = 3659;
pub const Z_UTIL_INC_3659: u32 = 3660;
pub const Z_UTIL_INC_3660: u32 = 3661;
pub const Z_UTIL_INC_3661: u32 = 3662;
pub const Z_UTIL_INC_3662: u32 = 3663;
pub const Z_UTIL_INC_3663: u32 = 3664;
pub const Z_UTIL_INC_3664: u32 = 3665;
pub const Z_UTIL_INC_3665: u32 = 3666;
pub const Z_UTIL_INC_3666: u32 = 3667;
pub const Z_UTIL_INC_3667: u32 = 3668;
pub const Z_UTIL_INC_3668: u32 = 3669;
pub const Z_UTIL_INC_3669: u32 = 3670;
pub const Z_UTIL_INC_3670: u32 = 3671;
pub const Z_UTIL_INC_3671: u32 = 3672;
pub const Z_UTIL_INC_3672: u32 = 3673;
pub const Z_UTIL_INC_3673: u32 = 3674;
pub const Z_UTIL_INC_3674: u32 = 3675;
pub const Z_UTIL_INC_3675: u32 = 3676;
pub const Z_UTIL_INC_3676: u32 = 3677;
pub const Z_UTIL_INC_3677: u32 = 3678;
pub const Z_UTIL_INC_3678: u32 = 3679;
pub const Z_UTIL_INC_3679: u32 = 3680;
pub const Z_UTIL_INC_3680: u32 = 3681;
pub const Z_UTIL_INC_3681: u32 = 3682;
pub const Z_UTIL_INC_3682: u32 = 3683;
pub const Z_UTIL_INC_3683: u32 = 3684;
pub const Z_UTIL_INC_3684: u32 = 3685;
pub const Z_UTIL_INC_3685: u32 = 3686;
pub const Z_UTIL_INC_3686: u32 = 3687;
pub const Z_UTIL_INC_3687: u32 = 3688;
pub const Z_UTIL_INC_3688: u32 = 3689;
pub const Z_UTIL_INC_3689: u32 = 3690;
pub const Z_UTIL_INC_3690: u32 = 3691;
pub const Z_UTIL_INC_3691: u32 = 3692;
pub const Z_UTIL_INC_3692: u32 = 3693;
pub const Z_UTIL_INC_3693: u32 = 3694;
pub const Z_UTIL_INC_3694: u32 = 3695;
pub const Z_UTIL_INC_3695: u32 = 3696;
pub const Z_UTIL_INC_3696: u32 = 3697;
pub const Z_UTIL_INC_3697: u32 = 3698;
pub const Z_UTIL_INC_3698: u32 = 3699;
pub const Z_UTIL_INC_3699: u32 = 3700;
pub const Z_UTIL_INC_3700: u32 = 3701;
pub const Z_UTIL_INC_3701: u32 = 3702;
pub const Z_UTIL_INC_3702: u32 = 3703;
pub const Z_UTIL_INC_3703: u32 = 3704;
pub const Z_UTIL_INC_3704: u32 = 3705;
pub const Z_UTIL_INC_3705: u32 = 3706;
pub const Z_UTIL_INC_3706: u32 = 3707;
pub const Z_UTIL_INC_3707: u32 = 3708;
pub const Z_UTIL_INC_3708: u32 = 3709;
pub const Z_UTIL_INC_3709: u32 = 3710;
pub const Z_UTIL_INC_3710: u32 = 3711;
pub const Z_UTIL_INC_3711: u32 = 3712;
pub const Z_UTIL_INC_3712: u32 = 3713;
pub const Z_UTIL_INC_3713: u32 = 3714;
pub const Z_UTIL_INC_3714: u32 = 3715;
pub const Z_UTIL_INC_3715: u32 = 3716;
pub const Z_UTIL_INC_3716: u32 = 3717;
pub const Z_UTIL_INC_3717: u32 = 3718;
pub const Z_UTIL_INC_3718: u32 = 3719;
pub const Z_UTIL_INC_3719: u32 = 3720;
pub const Z_UTIL_INC_3720: u32 = 3721;
pub const Z_UTIL_INC_3721: u32 = 3722;
pub const Z_UTIL_INC_3722: u32 = 3723;
pub const Z_UTIL_INC_3723: u32 = 3724;
pub const Z_UTIL_INC_3724: u32 = 3725;
pub const Z_UTIL_INC_3725: u32 = 3726;
pub const Z_UTIL_INC_3726: u32 = 3727;
pub const Z_UTIL_INC_3727: u32 = 3728;
pub const Z_UTIL_INC_3728: u32 = 3729;
pub const Z_UTIL_INC_3729: u32 = 3730;
pub const Z_UTIL_INC_3730: u32 = 3731;
pub const Z_UTIL_INC_3731: u32 = 3732;
pub const Z_UTIL_INC_3732: u32 = 3733;
pub const Z_UTIL_INC_3733: u32 = 3734;
pub const Z_UTIL_INC_3734: u32 = 3735;
pub const Z_UTIL_INC_3735: u32 = 3736;
pub const Z_UTIL_INC_3736: u32 = 3737;
pub const Z_UTIL_INC_3737: u32 = 3738;
pub const Z_UTIL_INC_3738: u32 = 3739;
pub const Z_UTIL_INC_3739: u32 = 3740;
pub const Z_UTIL_INC_3740: u32 = 3741;
pub const Z_UTIL_INC_3741: u32 = 3742;
pub const Z_UTIL_INC_3742: u32 = 3743;
pub const Z_UTIL_INC_3743: u32 = 3744;
pub const Z_UTIL_INC_3744: u32 = 3745;
pub const Z_UTIL_INC_3745: u32 = 3746;
pub const Z_UTIL_INC_3746: u32 = 3747;
pub const Z_UTIL_INC_3747: u32 = 3748;
pub const Z_UTIL_INC_3748: u32 = 3749;
pub const Z_UTIL_INC_3749: u32 = 3750;
pub const Z_UTIL_INC_3750: u32 = 3751;
pub const Z_UTIL_INC_3751: u32 = 3752;
pub const Z_UTIL_INC_3752: u32 = 3753;
pub const Z_UTIL_INC_3753: u32 = 3754;
pub const Z_UTIL_INC_3754: u32 = 3755;
pub const Z_UTIL_INC_3755: u32 = 3756;
pub const Z_UTIL_INC_3756: u32 = 3757;
pub const Z_UTIL_INC_3757: u32 = 3758;
pub const Z_UTIL_INC_3758: u32 = 3759;
pub const Z_UTIL_INC_3759: u32 = 3760;
pub const Z_UTIL_INC_3760: u32 = 3761;
pub const Z_UTIL_INC_3761: u32 = 3762;
pub const Z_UTIL_INC_3762: u32 = 3763;
pub const Z_UTIL_INC_3763: u32 = 3764;
pub const Z_UTIL_INC_3764: u32 = 3765;
pub const Z_UTIL_INC_3765: u32 = 3766;
pub const Z_UTIL_INC_3766: u32 = 3767;
pub const Z_UTIL_INC_3767: u32 = 3768;
pub const Z_UTIL_INC_3768: u32 = 3769;
pub const Z_UTIL_INC_3769: u32 = 3770;
pub const Z_UTIL_INC_3770: u32 = 3771;
pub const Z_UTIL_INC_3771: u32 = 3772;
pub const Z_UTIL_INC_3772: u32 = 3773;
pub const Z_UTIL_INC_3773: u32 = 3774;
pub const Z_UTIL_INC_3774: u32 = 3775;
pub const Z_UTIL_INC_3775: u32 = 3776;
pub const Z_UTIL_INC_3776: u32 = 3777;
pub const Z_UTIL_INC_3777: u32 = 3778;
pub const Z_UTIL_INC_3778: u32 = 3779;
pub const Z_UTIL_INC_3779: u32 = 3780;
pub const Z_UTIL_INC_3780: u32 = 3781;
pub const Z_UTIL_INC_3781: u32 = 3782;
pub const Z_UTIL_INC_3782: u32 = 3783;
pub const Z_UTIL_INC_3783: u32 = 3784;
pub const Z_UTIL_INC_3784: u32 = 3785;
pub const Z_UTIL_INC_3785: u32 = 3786;
pub const Z_UTIL_INC_3786: u32 = 3787;
pub const Z_UTIL_INC_3787: u32 = 3788;
pub const Z_UTIL_INC_3788: u32 = 3789;
pub const Z_UTIL_INC_3789: u32 = 3790;
pub const Z_UTIL_INC_3790: u32 = 3791;
pub const Z_UTIL_INC_3791: u32 = 3792;
pub const Z_UTIL_INC_3792: u32 = 3793;
pub const Z_UTIL_INC_3793: u32 = 3794;
pub const Z_UTIL_INC_3794: u32 = 3795;
pub const Z_UTIL_INC_3795: u32 = 3796;
pub const Z_UTIL_INC_3796: u32 = 3797;
pub const Z_UTIL_INC_3797: u32 = 3798;
pub const Z_UTIL_INC_3798: u32 = 3799;
pub const Z_UTIL_INC_3799: u32 = 3800;
pub const Z_UTIL_INC_3800: u32 = 3801;
pub const Z_UTIL_INC_3801: u32 = 3802;
pub const Z_UTIL_INC_3802: u32 = 3803;
pub const Z_UTIL_INC_3803: u32 = 3804;
pub const Z_UTIL_INC_3804: u32 = 3805;
pub const Z_UTIL_INC_3805: u32 = 3806;
pub const Z_UTIL_INC_3806: u32 = 3807;
pub const Z_UTIL_INC_3807: u32 = 3808;
pub const Z_UTIL_INC_3808: u32 = 3809;
pub const Z_UTIL_INC_3809: u32 = 3810;
pub const Z_UTIL_INC_3810: u32 = 3811;
pub const Z_UTIL_INC_3811: u32 = 3812;
pub const Z_UTIL_INC_3812: u32 = 3813;
pub const Z_UTIL_INC_3813: u32 = 3814;
pub const Z_UTIL_INC_3814: u32 = 3815;
pub const Z_UTIL_INC_3815: u32 = 3816;
pub const Z_UTIL_INC_3816: u32 = 3817;
pub const Z_UTIL_INC_3817: u32 = 3818;
pub const Z_UTIL_INC_3818: u32 = 3819;
pub const Z_UTIL_INC_3819: u32 = 3820;
pub const Z_UTIL_INC_3820: u32 = 3821;
pub const Z_UTIL_INC_3821: u32 = 3822;
pub const Z_UTIL_INC_3822: u32 = 3823;
pub const Z_UTIL_INC_3823: u32 = 3824;
pub const Z_UTIL_INC_3824: u32 = 3825;
pub const Z_UTIL_INC_3825: u32 = 3826;
pub const Z_UTIL_INC_3826: u32 = 3827;
pub const Z_UTIL_INC_3827: u32 = 3828;
pub const Z_UTIL_INC_3828: u32 = 3829;
pub const Z_UTIL_INC_3829: u32 = 3830;
pub const Z_UTIL_INC_3830: u32 = 3831;
pub const Z_UTIL_INC_3831: u32 = 3832;
pub const Z_UTIL_INC_3832: u32 = 3833;
pub const Z_UTIL_INC_3833: u32 = 3834;
pub const Z_UTIL_INC_3834: u32 = 3835;
pub const Z_UTIL_INC_3835: u32 = 3836;
pub const Z_UTIL_INC_3836: u32 = 3837;
pub const Z_UTIL_INC_3837: u32 = 3838;
pub const Z_UTIL_INC_3838: u32 = 3839;
pub const Z_UTIL_INC_3839: u32 = 3840;
pub const Z_UTIL_INC_3840: u32 = 3841;
pub const Z_UTIL_INC_3841: u32 = 3842;
pub const Z_UTIL_INC_3842: u32 = 3843;
pub const Z_UTIL_INC_3843: u32 = 3844;
pub const Z_UTIL_INC_3844: u32 = 3845;
pub const Z_UTIL_INC_3845: u32 = 3846;
pub const Z_UTIL_INC_3846: u32 = 3847;
pub const Z_UTIL_INC_3847: u32 = 3848;
pub const Z_UTIL_INC_3848: u32 = 3849;
pub const Z_UTIL_INC_3849: u32 = 3850;
pub const Z_UTIL_INC_3850: u32 = 3851;
pub const Z_UTIL_INC_3851: u32 = 3852;
pub const Z_UTIL_INC_3852: u32 = 3853;
pub const Z_UTIL_INC_3853: u32 = 3854;
pub const Z_UTIL_INC_3854: u32 = 3855;
pub const Z_UTIL_INC_3855: u32 = 3856;
pub const Z_UTIL_INC_3856: u32 = 3857;
pub const Z_UTIL_INC_3857: u32 = 3858;
pub const Z_UTIL_INC_3858: u32 = 3859;
pub const Z_UTIL_INC_3859: u32 = 3860;
pub const Z_UTIL_INC_3860: u32 = 3861;
pub const Z_UTIL_INC_3861: u32 = 3862;
pub const Z_UTIL_INC_3862: u32 = 3863;
pub const Z_UTIL_INC_3863: u32 = 3864;
pub const Z_UTIL_INC_3864: u32 = 3865;
pub const Z_UTIL_INC_3865: u32 = 3866;
pub const Z_UTIL_INC_3866: u32 = 3867;
pub const Z_UTIL_INC_3867: u32 = 3868;
pub const Z_UTIL_INC_3868: u32 = 3869;
pub const Z_UTIL_INC_3869: u32 = 3870;
pub const Z_UTIL_INC_3870: u32 = 3871;
pub const Z_UTIL_INC_3871: u32 = 3872;
pub const Z_UTIL_INC_3872: u32 = 3873;
pub const Z_UTIL_INC_3873: u32 = 3874;
pub const Z_UTIL_INC_3874: u32 = 3875;
pub const Z_UTIL_INC_3875: u32 = 3876;
pub const Z_UTIL_INC_3876: u32 = 3877;
pub const Z_UTIL_INC_3877: u32 = 3878;
pub const Z_UTIL_INC_3878: u32 = 3879;
pub const Z_UTIL_INC_3879: u32 = 3880;
pub const Z_UTIL_INC_3880: u32 = 3881;
pub const Z_UTIL_INC_3881: u32 = 3882;
pub const Z_UTIL_INC_3882: u32 = 3883;
pub const Z_UTIL_INC_3883: u32 = 3884;
pub const Z_UTIL_INC_3884: u32 = 3885;
pub const Z_UTIL_INC_3885: u32 = 3886;
pub const Z_UTIL_INC_3886: u32 = 3887;
pub const Z_UTIL_INC_3887: u32 = 3888;
pub const Z_UTIL_INC_3888: u32 = 3889;
pub const Z_UTIL_INC_3889: u32 = 3890;
pub const Z_UTIL_INC_3890: u32 = 3891;
pub const Z_UTIL_INC_3891: u32 = 3892;
pub const Z_UTIL_INC_3892: u32 = 3893;
pub const Z_UTIL_INC_3893: u32 = 3894;
pub const Z_UTIL_INC_3894: u32 = 3895;
pub const Z_UTIL_INC_3895: u32 = 3896;
pub const Z_UTIL_INC_3896: u32 = 3897;
pub const Z_UTIL_INC_3897: u32 = 3898;
pub const Z_UTIL_INC_3898: u32 = 3899;
pub const Z_UTIL_INC_3899: u32 = 3900;
pub const Z_UTIL_INC_3900: u32 = 3901;
pub const Z_UTIL_INC_3901: u32 = 3902;
pub const Z_UTIL_INC_3902: u32 = 3903;
pub const Z_UTIL_INC_3903: u32 = 3904;
pub const Z_UTIL_INC_3904: u32 = 3905;
pub const Z_UTIL_INC_3905: u32 = 3906;
pub const Z_UTIL_INC_3906: u32 = 3907;
pub const Z_UTIL_INC_3907: u32 = 3908;
pub const Z_UTIL_INC_3908: u32 = 3909;
pub const Z_UTIL_INC_3909: u32 = 3910;
pub const Z_UTIL_INC_3910: u32 = 3911;
pub const Z_UTIL_INC_3911: u32 = 3912;
pub const Z_UTIL_INC_3912: u32 = 3913;
pub const Z_UTIL_INC_3913: u32 = 3914;
pub const Z_UTIL_INC_3914: u32 = 3915;
pub const Z_UTIL_INC_3915: u32 = 3916;
pub const Z_UTIL_INC_3916: u32 = 3917;
pub const Z_UTIL_INC_3917: u32 = 3918;
pub const Z_UTIL_INC_3918: u32 = 3919;
pub const Z_UTIL_INC_3919: u32 = 3920;
pub const Z_UTIL_INC_3920: u32 = 3921;
pub const Z_UTIL_INC_3921: u32 = 3922;
pub const Z_UTIL_INC_3922: u32 = 3923;
pub const Z_UTIL_INC_3923: u32 = 3924;
pub const Z_UTIL_INC_3924: u32 = 3925;
pub const Z_UTIL_INC_3925: u32 = 3926;
pub const Z_UTIL_INC_3926: u32 = 3927;
pub const Z_UTIL_INC_3927: u32 = 3928;
pub const Z_UTIL_INC_3928: u32 = 3929;
pub const Z_UTIL_INC_3929: u32 = 3930;
pub const Z_UTIL_INC_3930: u32 = 3931;
pub const Z_UTIL_INC_3931: u32 = 3932;
pub const Z_UTIL_INC_3932: u32 = 3933;
pub const Z_UTIL_INC_3933: u32 = 3934;
pub const Z_UTIL_INC_3934: u32 = 3935;
pub const Z_UTIL_INC_3935: u32 = 3936;
pub const Z_UTIL_INC_3936: u32 = 3937;
pub const Z_UTIL_INC_3937: u32 = 3938;
pub const Z_UTIL_INC_3938: u32 = 3939;
pub const Z_UTIL_INC_3939: u32 = 3940;
pub const Z_UTIL_INC_3940: u32 = 3941;
pub const Z_UTIL_INC_3941: u32 = 3942;
pub const Z_UTIL_INC_3942: u32 = 3943;
pub const Z_UTIL_INC_3943: u32 = 3944;
pub const Z_UTIL_INC_3944: u32 = 3945;
pub const Z_UTIL_INC_3945: u32 = 3946;
pub const Z_UTIL_INC_3946: u32 = 3947;
pub const Z_UTIL_INC_3947: u32 = 3948;
pub const Z_UTIL_INC_3948: u32 = 3949;
pub const Z_UTIL_INC_3949: u32 = 3950;
pub const Z_UTIL_INC_3950: u32 = 3951;
pub const Z_UTIL_INC_3951: u32 = 3952;
pub const Z_UTIL_INC_3952: u32 = 3953;
pub const Z_UTIL_INC_3953: u32 = 3954;
pub const Z_UTIL_INC_3954: u32 = 3955;
pub const Z_UTIL_INC_3955: u32 = 3956;
pub const Z_UTIL_INC_3956: u32 = 3957;
pub const Z_UTIL_INC_3957: u32 = 3958;
pub const Z_UTIL_INC_3958: u32 = 3959;
pub const Z_UTIL_INC_3959: u32 = 3960;
pub const Z_UTIL_INC_3960: u32 = 3961;
pub const Z_UTIL_INC_3961: u32 = 3962;
pub const Z_UTIL_INC_3962: u32 = 3963;
pub const Z_UTIL_INC_3963: u32 = 3964;
pub const Z_UTIL_INC_3964: u32 = 3965;
pub const Z_UTIL_INC_3965: u32 = 3966;
pub const Z_UTIL_INC_3966: u32 = 3967;
pub const Z_UTIL_INC_3967: u32 = 3968;
pub const Z_UTIL_INC_3968: u32 = 3969;
pub const Z_UTIL_INC_3969: u32 = 3970;
pub const Z_UTIL_INC_3970: u32 = 3971;
pub const Z_UTIL_INC_3971: u32 = 3972;
pub const Z_UTIL_INC_3972: u32 = 3973;
pub const Z_UTIL_INC_3973: u32 = 3974;
pub const Z_UTIL_INC_3974: u32 = 3975;
pub const Z_UTIL_INC_3975: u32 = 3976;
pub const Z_UTIL_INC_3976: u32 = 3977;
pub const Z_UTIL_INC_3977: u32 = 3978;
pub const Z_UTIL_INC_3978: u32 = 3979;
pub const Z_UTIL_INC_3979: u32 = 3980;
pub const Z_UTIL_INC_3980: u32 = 3981;
pub const Z_UTIL_INC_3981: u32 = 3982;
pub const Z_UTIL_INC_3982: u32 = 3983;
pub const Z_UTIL_INC_3983: u32 = 3984;
pub const Z_UTIL_INC_3984: u32 = 3985;
pub const Z_UTIL_INC_3985: u32 = 3986;
pub const Z_UTIL_INC_3986: u32 = 3987;
pub const Z_UTIL_INC_3987: u32 = 3988;
pub const Z_UTIL_INC_3988: u32 = 3989;
pub const Z_UTIL_INC_3989: u32 = 3990;
pub const Z_UTIL_INC_3990: u32 = 3991;
pub const Z_UTIL_INC_3991: u32 = 3992;
pub const Z_UTIL_INC_3992: u32 = 3993;
pub const Z_UTIL_INC_3993: u32 = 3994;
pub const Z_UTIL_INC_3994: u32 = 3995;
pub const Z_UTIL_INC_3995: u32 = 3996;
pub const Z_UTIL_INC_3996: u32 = 3997;
pub const Z_UTIL_INC_3997: u32 = 3998;
pub const Z_UTIL_INC_3998: u32 = 3999;
pub const Z_UTIL_INC_3999: u32 = 4000;
pub const Z_UTIL_INC_4000: u32 = 4001;
pub const Z_UTIL_INC_4001: u32 = 4002;
pub const Z_UTIL_INC_4002: u32 = 4003;
pub const Z_UTIL_INC_4003: u32 = 4004;
pub const Z_UTIL_INC_4004: u32 = 4005;
pub const Z_UTIL_INC_4005: u32 = 4006;
pub const Z_UTIL_INC_4006: u32 = 4007;
pub const Z_UTIL_INC_4007: u32 = 4008;
pub const Z_UTIL_INC_4008: u32 = 4009;
pub const Z_UTIL_INC_4009: u32 = 4010;
pub const Z_UTIL_INC_4010: u32 = 4011;
pub const Z_UTIL_INC_4011: u32 = 4012;
pub const Z_UTIL_INC_4012: u32 = 4013;
pub const Z_UTIL_INC_4013: u32 = 4014;
pub const Z_UTIL_INC_4014: u32 = 4015;
pub const Z_UTIL_INC_4015: u32 = 4016;
pub const Z_UTIL_INC_4016: u32 = 4017;
pub const Z_UTIL_INC_4017: u32 = 4018;
pub const Z_UTIL_INC_4018: u32 = 4019;
pub const Z_UTIL_INC_4019: u32 = 4020;
pub const Z_UTIL_INC_4020: u32 = 4021;
pub const Z_UTIL_INC_4021: u32 = 4022;
pub const Z_UTIL_INC_4022: u32 = 4023;
pub const Z_UTIL_INC_4023: u32 = 4024;
pub const Z_UTIL_INC_4024: u32 = 4025;
pub const Z_UTIL_INC_4025: u32 = 4026;
pub const Z_UTIL_INC_4026: u32 = 4027;
pub const Z_UTIL_INC_4027: u32 = 4028;
pub const Z_UTIL_INC_4028: u32 = 4029;
pub const Z_UTIL_INC_4029: u32 = 4030;
pub const Z_UTIL_INC_4030: u32 = 4031;
pub const Z_UTIL_INC_4031: u32 = 4032;
pub const Z_UTIL_INC_4032: u32 = 4033;
pub const Z_UTIL_INC_4033: u32 = 4034;
pub const Z_UTIL_INC_4034: u32 = 4035;
pub const Z_UTIL_INC_4035: u32 = 4036;
pub const Z_UTIL_INC_4036: u32 = 4037;
pub const Z_UTIL_INC_4037: u32 = 4038;
pub const Z_UTIL_INC_4038: u32 = 4039;
pub const Z_UTIL_INC_4039: u32 = 4040;
pub const Z_UTIL_INC_4040: u32 = 4041;
pub const Z_UTIL_INC_4041: u32 = 4042;
pub const Z_UTIL_INC_4042: u32 = 4043;
pub const Z_UTIL_INC_4043: u32 = 4044;
pub const Z_UTIL_INC_4044: u32 = 4045;
pub const Z_UTIL_INC_4045: u32 = 4046;
pub const Z_UTIL_INC_4046: u32 = 4047;
pub const Z_UTIL_INC_4047: u32 = 4048;
pub const Z_UTIL_INC_4048: u32 = 4049;
pub const Z_UTIL_INC_4049: u32 = 4050;
pub const Z_UTIL_INC_4050: u32 = 4051;
pub const Z_UTIL_INC_4051: u32 = 4052;
pub const Z_UTIL_INC_4052: u32 = 4053;
pub const Z_UTIL_INC_4053: u32 = 4054;
pub const Z_UTIL_INC_4054: u32 = 4055;
pub const Z_UTIL_INC_4055: u32 = 4056;
pub const Z_UTIL_INC_4056: u32 = 4057;
pub const Z_UTIL_INC_4057: u32 = 4058;
pub const Z_UTIL_INC_4058: u32 = 4059;
pub const Z_UTIL_INC_4059: u32 = 4060;
pub const Z_UTIL_INC_4060: u32 = 4061;
pub const Z_UTIL_INC_4061: u32 = 4062;
pub const Z_UTIL_INC_4062: u32 = 4063;
pub const Z_UTIL_INC_4063: u32 = 4064;
pub const Z_UTIL_INC_4064: u32 = 4065;
pub const Z_UTIL_INC_4065: u32 = 4066;
pub const Z_UTIL_INC_4066: u32 = 4067;
pub const Z_UTIL_INC_4067: u32 = 4068;
pub const Z_UTIL_INC_4068: u32 = 4069;
pub const Z_UTIL_INC_4069: u32 = 4070;
pub const Z_UTIL_INC_4070: u32 = 4071;
pub const Z_UTIL_INC_4071: u32 = 4072;
pub const Z_UTIL_INC_4072: u32 = 4073;
pub const Z_UTIL_INC_4073: u32 = 4074;
pub const Z_UTIL_INC_4074: u32 = 4075;
pub const Z_UTIL_INC_4075: u32 = 4076;
pub const Z_UTIL_INC_4076: u32 = 4077;
pub const Z_UTIL_INC_4077: u32 = 4078;
pub const Z_UTIL_INC_4078: u32 = 4079;
pub const Z_UTIL_INC_4079: u32 = 4080;
pub const Z_UTIL_INC_4080: u32 = 4081;
pub const Z_UTIL_INC_4081: u32 = 4082;
pub const Z_UTIL_INC_4082: u32 = 4083;
pub const Z_UTIL_INC_4083: u32 = 4084;
pub const Z_UTIL_INC_4084: u32 = 4085;
pub const Z_UTIL_INC_4085: u32 = 4086;
pub const Z_UTIL_INC_4086: u32 = 4087;
pub const Z_UTIL_INC_4087: u32 = 4088;
pub const Z_UTIL_INC_4088: u32 = 4089;
pub const Z_UTIL_INC_4089: u32 = 4090;
pub const Z_UTIL_INC_4090: u32 = 4091;
pub const Z_UTIL_INC_4091: u32 = 4092;
pub const Z_UTIL_INC_4092: u32 = 4093;
pub const Z_UTIL_INC_4093: u32 = 4094;
pub const Z_UTIL_INC_4094: u32 = 4095;
pub const Z_UTIL_INC_4095: u32 = 4096;
pub const Z_UTIL_INC_4096: u32 = 4097;
pub const Z_UTIL_DEC_0: u32 = 0;
pub const Z_UTIL_DEC_1: u32 = 0;
pub const Z_UTIL_DEC_2: u32 = 1;
pub const Z_UTIL_DEC_3: u32 = 2;
pub const Z_UTIL_DEC_4: u32 = 3;
pub const Z_UTIL_DEC_5: u32 = 4;
pub const Z_UTIL_DEC_6: u32 = 5;
pub const Z_UTIL_DEC_7: u32 = 6;
pub const Z_UTIL_DEC_8: u32 = 7;
pub const Z_UTIL_DEC_9: u32 = 8;
pub const Z_UTIL_DEC_10: u32 = 9;
pub const Z_UTIL_DEC_11: u32 = 10;
pub const Z_UTIL_DEC_12: u32 = 11;
pub const Z_UTIL_DEC_13: u32 = 12;
pub const Z_UTIL_DEC_14: u32 = 13;
pub const Z_UTIL_DEC_15: u32 = 14;
pub const Z_UTIL_DEC_16: u32 = 15;
pub const Z_UTIL_DEC_17: u32 = 16;
pub const Z_UTIL_DEC_18: u32 = 17;
pub const Z_UTIL_DEC_19: u32 = 18;
pub const Z_UTIL_DEC_20: u32 = 19;
pub const Z_UTIL_DEC_21: u32 = 20;
pub const Z_UTIL_DEC_22: u32 = 21;
pub const Z_UTIL_DEC_23: u32 = 22;
pub const Z_UTIL_DEC_24: u32 = 23;
pub const Z_UTIL_DEC_25: u32 = 24;
pub const Z_UTIL_DEC_26: u32 = 25;
pub const Z_UTIL_DEC_27: u32 = 26;
pub const Z_UTIL_DEC_28: u32 = 27;
pub const Z_UTIL_DEC_29: u32 = 28;
pub const Z_UTIL_DEC_30: u32 = 29;
pub const Z_UTIL_DEC_31: u32 = 30;
pub const Z_UTIL_DEC_32: u32 = 31;
pub const Z_UTIL_DEC_33: u32 = 32;
pub const Z_UTIL_DEC_34: u32 = 33;
pub const Z_UTIL_DEC_35: u32 = 34;
pub const Z_UTIL_DEC_36: u32 = 35;
pub const Z_UTIL_DEC_37: u32 = 36;
pub const Z_UTIL_DEC_38: u32 = 37;
pub const Z_UTIL_DEC_39: u32 = 38;
pub const Z_UTIL_DEC_40: u32 = 39;
pub const Z_UTIL_DEC_41: u32 = 40;
pub const Z_UTIL_DEC_42: u32 = 41;
pub const Z_UTIL_DEC_43: u32 = 42;
pub const Z_UTIL_DEC_44: u32 = 43;
pub const Z_UTIL_DEC_45: u32 = 44;
pub const Z_UTIL_DEC_46: u32 = 45;
pub const Z_UTIL_DEC_47: u32 = 46;
pub const Z_UTIL_DEC_48: u32 = 47;
pub const Z_UTIL_DEC_49: u32 = 48;
pub const Z_UTIL_DEC_50: u32 = 49;
pub const Z_UTIL_DEC_51: u32 = 50;
pub const Z_UTIL_DEC_52: u32 = 51;
pub const Z_UTIL_DEC_53: u32 = 52;
pub const Z_UTIL_DEC_54: u32 = 53;
pub const Z_UTIL_DEC_55: u32 = 54;
pub const Z_UTIL_DEC_56: u32 = 55;
pub const Z_UTIL_DEC_57: u32 = 56;
pub const Z_UTIL_DEC_58: u32 = 57;
pub const Z_UTIL_DEC_59: u32 = 58;
pub const Z_UTIL_DEC_60: u32 = 59;
pub const Z_UTIL_DEC_61: u32 = 60;
pub const Z_UTIL_DEC_62: u32 = 61;
pub const Z_UTIL_DEC_63: u32 = 62;
pub const Z_UTIL_DEC_64: u32 = 63;
pub const Z_UTIL_DEC_65: u32 = 64;
pub const Z_UTIL_DEC_66: u32 = 65;
pub const Z_UTIL_DEC_67: u32 = 66;
pub const Z_UTIL_DEC_68: u32 = 67;
pub const Z_UTIL_DEC_69: u32 = 68;
pub const Z_UTIL_DEC_70: u32 = 69;
pub const Z_UTIL_DEC_71: u32 = 70;
pub const Z_UTIL_DEC_72: u32 = 71;
pub const Z_UTIL_DEC_73: u32 = 72;
pub const Z_UTIL_DEC_74: u32 = 73;
pub const Z_UTIL_DEC_75: u32 = 74;
pub const Z_UTIL_DEC_76: u32 = 75;
pub const Z_UTIL_DEC_77: u32 = 76;
pub const Z_UTIL_DEC_78: u32 = 77;
pub const Z_UTIL_DEC_79: u32 = 78;
pub const Z_UTIL_DEC_80: u32 = 79;
pub const Z_UTIL_DEC_81: u32 = 80;
pub const Z_UTIL_DEC_82: u32 = 81;
pub const Z_UTIL_DEC_83: u32 = 82;
pub const Z_UTIL_DEC_84: u32 = 83;
pub const Z_UTIL_DEC_85: u32 = 84;
pub const Z_UTIL_DEC_86: u32 = 85;
pub const Z_UTIL_DEC_87: u32 = 86;
pub const Z_UTIL_DEC_88: u32 = 87;
pub const Z_UTIL_DEC_89: u32 = 88;
pub const Z_UTIL_DEC_90: u32 = 89;
pub const Z_UTIL_DEC_91: u32 = 90;
pub const Z_UTIL_DEC_92: u32 = 91;
pub const Z_UTIL_DEC_93: u32 = 92;
pub const Z_UTIL_DEC_94: u32 = 93;
pub const Z_UTIL_DEC_95: u32 = 94;
pub const Z_UTIL_DEC_96: u32 = 95;
pub const Z_UTIL_DEC_97: u32 = 96;
pub const Z_UTIL_DEC_98: u32 = 97;
pub const Z_UTIL_DEC_99: u32 = 98;
pub const Z_UTIL_DEC_100: u32 = 99;
pub const Z_UTIL_DEC_101: u32 = 100;
pub const Z_UTIL_DEC_102: u32 = 101;
pub const Z_UTIL_DEC_103: u32 = 102;
pub const Z_UTIL_DEC_104: u32 = 103;
pub const Z_UTIL_DEC_105: u32 = 104;
pub const Z_UTIL_DEC_106: u32 = 105;
pub const Z_UTIL_DEC_107: u32 = 106;
pub const Z_UTIL_DEC_108: u32 = 107;
pub const Z_UTIL_DEC_109: u32 = 108;
pub const Z_UTIL_DEC_110: u32 = 109;
pub const Z_UTIL_DEC_111: u32 = 110;
pub const Z_UTIL_DEC_112: u32 = 111;
pub const Z_UTIL_DEC_113: u32 = 112;
pub const Z_UTIL_DEC_114: u32 = 113;
pub const Z_UTIL_DEC_115: u32 = 114;
pub const Z_UTIL_DEC_116: u32 = 115;
pub const Z_UTIL_DEC_117: u32 = 116;
pub const Z_UTIL_DEC_118: u32 = 117;
pub const Z_UTIL_DEC_119: u32 = 118;
pub const Z_UTIL_DEC_120: u32 = 119;
pub const Z_UTIL_DEC_121: u32 = 120;
pub const Z_UTIL_DEC_122: u32 = 121;
pub const Z_UTIL_DEC_123: u32 = 122;
pub const Z_UTIL_DEC_124: u32 = 123;
pub const Z_UTIL_DEC_125: u32 = 124;
pub const Z_UTIL_DEC_126: u32 = 125;
pub const Z_UTIL_DEC_127: u32 = 126;
pub const Z_UTIL_DEC_128: u32 = 127;
pub const Z_UTIL_DEC_129: u32 = 128;
pub const Z_UTIL_DEC_130: u32 = 129;
pub const Z_UTIL_DEC_131: u32 = 130;
pub const Z_UTIL_DEC_132: u32 = 131;
pub const Z_UTIL_DEC_133: u32 = 132;
pub const Z_UTIL_DEC_134: u32 = 133;
pub const Z_UTIL_DEC_135: u32 = 134;
pub const Z_UTIL_DEC_136: u32 = 135;
pub const Z_UTIL_DEC_137: u32 = 136;
pub const Z_UTIL_DEC_138: u32 = 137;
pub const Z_UTIL_DEC_139: u32 = 138;
pub const Z_UTIL_DEC_140: u32 = 139;
pub const Z_UTIL_DEC_141: u32 = 140;
pub const Z_UTIL_DEC_142: u32 = 141;
pub const Z_UTIL_DEC_143: u32 = 142;
pub const Z_UTIL_DEC_144: u32 = 143;
pub const Z_UTIL_DEC_145: u32 = 144;
pub const Z_UTIL_DEC_146: u32 = 145;
pub const Z_UTIL_DEC_147: u32 = 146;
pub const Z_UTIL_DEC_148: u32 = 147;
pub const Z_UTIL_DEC_149: u32 = 148;
pub const Z_UTIL_DEC_150: u32 = 149;
pub const Z_UTIL_DEC_151: u32 = 150;
pub const Z_UTIL_DEC_152: u32 = 151;
pub const Z_UTIL_DEC_153: u32 = 152;
pub const Z_UTIL_DEC_154: u32 = 153;
pub const Z_UTIL_DEC_155: u32 = 154;
pub const Z_UTIL_DEC_156: u32 = 155;
pub const Z_UTIL_DEC_157: u32 = 156;
pub const Z_UTIL_DEC_158: u32 = 157;
pub const Z_UTIL_DEC_159: u32 = 158;
pub const Z_UTIL_DEC_160: u32 = 159;
pub const Z_UTIL_DEC_161: u32 = 160;
pub const Z_UTIL_DEC_162: u32 = 161;
pub const Z_UTIL_DEC_163: u32 = 162;
pub const Z_UTIL_DEC_164: u32 = 163;
pub const Z_UTIL_DEC_165: u32 = 164;
pub const Z_UTIL_DEC_166: u32 = 165;
pub const Z_UTIL_DEC_167: u32 = 166;
pub const Z_UTIL_DEC_168: u32 = 167;
pub const Z_UTIL_DEC_169: u32 = 168;
pub const Z_UTIL_DEC_170: u32 = 169;
pub const Z_UTIL_DEC_171: u32 = 170;
pub const Z_UTIL_DEC_172: u32 = 171;
pub const Z_UTIL_DEC_173: u32 = 172;
pub const Z_UTIL_DEC_174: u32 = 173;
pub const Z_UTIL_DEC_175: u32 = 174;
pub const Z_UTIL_DEC_176: u32 = 175;
pub const Z_UTIL_DEC_177: u32 = 176;
pub const Z_UTIL_DEC_178: u32 = 177;
pub const Z_UTIL_DEC_179: u32 = 178;
pub const Z_UTIL_DEC_180: u32 = 179;
pub const Z_UTIL_DEC_181: u32 = 180;
pub const Z_UTIL_DEC_182: u32 = 181;
pub const Z_UTIL_DEC_183: u32 = 182;
pub const Z_UTIL_DEC_184: u32 = 183;
pub const Z_UTIL_DEC_185: u32 = 184;
pub const Z_UTIL_DEC_186: u32 = 185;
pub const Z_UTIL_DEC_187: u32 = 186;
pub const Z_UTIL_DEC_188: u32 = 187;
pub const Z_UTIL_DEC_189: u32 = 188;
pub const Z_UTIL_DEC_190: u32 = 189;
pub const Z_UTIL_DEC_191: u32 = 190;
pub const Z_UTIL_DEC_192: u32 = 191;
pub const Z_UTIL_DEC_193: u32 = 192;
pub const Z_UTIL_DEC_194: u32 = 193;
pub const Z_UTIL_DEC_195: u32 = 194;
pub const Z_UTIL_DEC_196: u32 = 195;
pub const Z_UTIL_DEC_197: u32 = 196;
pub const Z_UTIL_DEC_198: u32 = 197;
pub const Z_UTIL_DEC_199: u32 = 198;
pub const Z_UTIL_DEC_200: u32 = 199;
pub const Z_UTIL_DEC_201: u32 = 200;
pub const Z_UTIL_DEC_202: u32 = 201;
pub const Z_UTIL_DEC_203: u32 = 202;
pub const Z_UTIL_DEC_204: u32 = 203;
pub const Z_UTIL_DEC_205: u32 = 204;
pub const Z_UTIL_DEC_206: u32 = 205;
pub const Z_UTIL_DEC_207: u32 = 206;
pub const Z_UTIL_DEC_208: u32 = 207;
pub const Z_UTIL_DEC_209: u32 = 208;
pub const Z_UTIL_DEC_210: u32 = 209;
pub const Z_UTIL_DEC_211: u32 = 210;
pub const Z_UTIL_DEC_212: u32 = 211;
pub const Z_UTIL_DEC_213: u32 = 212;
pub const Z_UTIL_DEC_214: u32 = 213;
pub const Z_UTIL_DEC_215: u32 = 214;
pub const Z_UTIL_DEC_216: u32 = 215;
pub const Z_UTIL_DEC_217: u32 = 216;
pub const Z_UTIL_DEC_218: u32 = 217;
pub const Z_UTIL_DEC_219: u32 = 218;
pub const Z_UTIL_DEC_220: u32 = 219;
pub const Z_UTIL_DEC_221: u32 = 220;
pub const Z_UTIL_DEC_222: u32 = 221;
pub const Z_UTIL_DEC_223: u32 = 222;
pub const Z_UTIL_DEC_224: u32 = 223;
pub const Z_UTIL_DEC_225: u32 = 224;
pub const Z_UTIL_DEC_226: u32 = 225;
pub const Z_UTIL_DEC_227: u32 = 226;
pub const Z_UTIL_DEC_228: u32 = 227;
pub const Z_UTIL_DEC_229: u32 = 228;
pub const Z_UTIL_DEC_230: u32 = 229;
pub const Z_UTIL_DEC_231: u32 = 230;
pub const Z_UTIL_DEC_232: u32 = 231;
pub const Z_UTIL_DEC_233: u32 = 232;
pub const Z_UTIL_DEC_234: u32 = 233;
pub const Z_UTIL_DEC_235: u32 = 234;
pub const Z_UTIL_DEC_236: u32 = 235;
pub const Z_UTIL_DEC_237: u32 = 236;
pub const Z_UTIL_DEC_238: u32 = 237;
pub const Z_UTIL_DEC_239: u32 = 238;
pub const Z_UTIL_DEC_240: u32 = 239;
pub const Z_UTIL_DEC_241: u32 = 240;
pub const Z_UTIL_DEC_242: u32 = 241;
pub const Z_UTIL_DEC_243: u32 = 242;
pub const Z_UTIL_DEC_244: u32 = 243;
pub const Z_UTIL_DEC_245: u32 = 244;
pub const Z_UTIL_DEC_246: u32 = 245;
pub const Z_UTIL_DEC_247: u32 = 246;
pub const Z_UTIL_DEC_248: u32 = 247;
pub const Z_UTIL_DEC_249: u32 = 248;
pub const Z_UTIL_DEC_250: u32 = 249;
pub const Z_UTIL_DEC_251: u32 = 250;
pub const Z_UTIL_DEC_252: u32 = 251;
pub const Z_UTIL_DEC_253: u32 = 252;
pub const Z_UTIL_DEC_254: u32 = 253;
pub const Z_UTIL_DEC_255: u32 = 254;
pub const Z_UTIL_DEC_256: u32 = 255;
pub const Z_UTIL_DEC_257: u32 = 256;
pub const Z_UTIL_DEC_258: u32 = 257;
pub const Z_UTIL_DEC_259: u32 = 258;
pub const Z_UTIL_DEC_260: u32 = 259;
pub const Z_UTIL_DEC_261: u32 = 260;
pub const Z_UTIL_DEC_262: u32 = 261;
pub const Z_UTIL_DEC_263: u32 = 262;
pub const Z_UTIL_DEC_264: u32 = 263;
pub const Z_UTIL_DEC_265: u32 = 264;
pub const Z_UTIL_DEC_266: u32 = 265;
pub const Z_UTIL_DEC_267: u32 = 266;
pub const Z_UTIL_DEC_268: u32 = 267;
pub const Z_UTIL_DEC_269: u32 = 268;
pub const Z_UTIL_DEC_270: u32 = 269;
pub const Z_UTIL_DEC_271: u32 = 270;
pub const Z_UTIL_DEC_272: u32 = 271;
pub const Z_UTIL_DEC_273: u32 = 272;
pub const Z_UTIL_DEC_274: u32 = 273;
pub const Z_UTIL_DEC_275: u32 = 274;
pub const Z_UTIL_DEC_276: u32 = 275;
pub const Z_UTIL_DEC_277: u32 = 276;
pub const Z_UTIL_DEC_278: u32 = 277;
pub const Z_UTIL_DEC_279: u32 = 278;
pub const Z_UTIL_DEC_280: u32 = 279;
pub const Z_UTIL_DEC_281: u32 = 280;
pub const Z_UTIL_DEC_282: u32 = 281;
pub const Z_UTIL_DEC_283: u32 = 282;
pub const Z_UTIL_DEC_284: u32 = 283;
pub const Z_UTIL_DEC_285: u32 = 284;
pub const Z_UTIL_DEC_286: u32 = 285;
pub const Z_UTIL_DEC_287: u32 = 286;
pub const Z_UTIL_DEC_288: u32 = 287;
pub const Z_UTIL_DEC_289: u32 = 288;
pub const Z_UTIL_DEC_290: u32 = 289;
pub const Z_UTIL_DEC_291: u32 = 290;
pub const Z_UTIL_DEC_292: u32 = 291;
pub const Z_UTIL_DEC_293: u32 = 292;
pub const Z_UTIL_DEC_294: u32 = 293;
pub const Z_UTIL_DEC_295: u32 = 294;
pub const Z_UTIL_DEC_296: u32 = 295;
pub const Z_UTIL_DEC_297: u32 = 296;
pub const Z_UTIL_DEC_298: u32 = 297;
pub const Z_UTIL_DEC_299: u32 = 298;
pub const Z_UTIL_DEC_300: u32 = 299;
pub const Z_UTIL_DEC_301: u32 = 300;
pub const Z_UTIL_DEC_302: u32 = 301;
pub const Z_UTIL_DEC_303: u32 = 302;
pub const Z_UTIL_DEC_304: u32 = 303;
pub const Z_UTIL_DEC_305: u32 = 304;
pub const Z_UTIL_DEC_306: u32 = 305;
pub const Z_UTIL_DEC_307: u32 = 306;
pub const Z_UTIL_DEC_308: u32 = 307;
pub const Z_UTIL_DEC_309: u32 = 308;
pub const Z_UTIL_DEC_310: u32 = 309;
pub const Z_UTIL_DEC_311: u32 = 310;
pub const Z_UTIL_DEC_312: u32 = 311;
pub const Z_UTIL_DEC_313: u32 = 312;
pub const Z_UTIL_DEC_314: u32 = 313;
pub const Z_UTIL_DEC_315: u32 = 314;
pub const Z_UTIL_DEC_316: u32 = 315;
pub const Z_UTIL_DEC_317: u32 = 316;
pub const Z_UTIL_DEC_318: u32 = 317;
pub const Z_UTIL_DEC_319: u32 = 318;
pub const Z_UTIL_DEC_320: u32 = 319;
pub const Z_UTIL_DEC_321: u32 = 320;
pub const Z_UTIL_DEC_322: u32 = 321;
pub const Z_UTIL_DEC_323: u32 = 322;
pub const Z_UTIL_DEC_324: u32 = 323;
pub const Z_UTIL_DEC_325: u32 = 324;
pub const Z_UTIL_DEC_326: u32 = 325;
pub const Z_UTIL_DEC_327: u32 = 326;
pub const Z_UTIL_DEC_328: u32 = 327;
pub const Z_UTIL_DEC_329: u32 = 328;
pub const Z_UTIL_DEC_330: u32 = 329;
pub const Z_UTIL_DEC_331: u32 = 330;
pub const Z_UTIL_DEC_332: u32 = 331;
pub const Z_UTIL_DEC_333: u32 = 332;
pub const Z_UTIL_DEC_334: u32 = 333;
pub const Z_UTIL_DEC_335: u32 = 334;
pub const Z_UTIL_DEC_336: u32 = 335;
pub const Z_UTIL_DEC_337: u32 = 336;
pub const Z_UTIL_DEC_338: u32 = 337;
pub const Z_UTIL_DEC_339: u32 = 338;
pub const Z_UTIL_DEC_340: u32 = 339;
pub const Z_UTIL_DEC_341: u32 = 340;
pub const Z_UTIL_DEC_342: u32 = 341;
pub const Z_UTIL_DEC_343: u32 = 342;
pub const Z_UTIL_DEC_344: u32 = 343;
pub const Z_UTIL_DEC_345: u32 = 344;
pub const Z_UTIL_DEC_346: u32 = 345;
pub const Z_UTIL_DEC_347: u32 = 346;
pub const Z_UTIL_DEC_348: u32 = 347;
pub const Z_UTIL_DEC_349: u32 = 348;
pub const Z_UTIL_DEC_350: u32 = 349;
pub const Z_UTIL_DEC_351: u32 = 350;
pub const Z_UTIL_DEC_352: u32 = 351;
pub const Z_UTIL_DEC_353: u32 = 352;
pub const Z_UTIL_DEC_354: u32 = 353;
pub const Z_UTIL_DEC_355: u32 = 354;
pub const Z_UTIL_DEC_356: u32 = 355;
pub const Z_UTIL_DEC_357: u32 = 356;
pub const Z_UTIL_DEC_358: u32 = 357;
pub const Z_UTIL_DEC_359: u32 = 358;
pub const Z_UTIL_DEC_360: u32 = 359;
pub const Z_UTIL_DEC_361: u32 = 360;
pub const Z_UTIL_DEC_362: u32 = 361;
pub const Z_UTIL_DEC_363: u32 = 362;
pub const Z_UTIL_DEC_364: u32 = 363;
pub const Z_UTIL_DEC_365: u32 = 364;
pub const Z_UTIL_DEC_366: u32 = 365;
pub const Z_UTIL_DEC_367: u32 = 366;
pub const Z_UTIL_DEC_368: u32 = 367;
pub const Z_UTIL_DEC_369: u32 = 368;
pub const Z_UTIL_DEC_370: u32 = 369;
pub const Z_UTIL_DEC_371: u32 = 370;
pub const Z_UTIL_DEC_372: u32 = 371;
pub const Z_UTIL_DEC_373: u32 = 372;
pub const Z_UTIL_DEC_374: u32 = 373;
pub const Z_UTIL_DEC_375: u32 = 374;
pub const Z_UTIL_DEC_376: u32 = 375;
pub const Z_UTIL_DEC_377: u32 = 376;
pub const Z_UTIL_DEC_378: u32 = 377;
pub const Z_UTIL_DEC_379: u32 = 378;
pub const Z_UTIL_DEC_380: u32 = 379;
pub const Z_UTIL_DEC_381: u32 = 380;
pub const Z_UTIL_DEC_382: u32 = 381;
pub const Z_UTIL_DEC_383: u32 = 382;
pub const Z_UTIL_DEC_384: u32 = 383;
pub const Z_UTIL_DEC_385: u32 = 384;
pub const Z_UTIL_DEC_386: u32 = 385;
pub const Z_UTIL_DEC_387: u32 = 386;
pub const Z_UTIL_DEC_388: u32 = 387;
pub const Z_UTIL_DEC_389: u32 = 388;
pub const Z_UTIL_DEC_390: u32 = 389;
pub const Z_UTIL_DEC_391: u32 = 390;
pub const Z_UTIL_DEC_392: u32 = 391;
pub const Z_UTIL_DEC_393: u32 = 392;
pub const Z_UTIL_DEC_394: u32 = 393;
pub const Z_UTIL_DEC_395: u32 = 394;
pub const Z_UTIL_DEC_396: u32 = 395;
pub const Z_UTIL_DEC_397: u32 = 396;
pub const Z_UTIL_DEC_398: u32 = 397;
pub const Z_UTIL_DEC_399: u32 = 398;
pub const Z_UTIL_DEC_400: u32 = 399;
pub const Z_UTIL_DEC_401: u32 = 400;
pub const Z_UTIL_DEC_402: u32 = 401;
pub const Z_UTIL_DEC_403: u32 = 402;
pub const Z_UTIL_DEC_404: u32 = 403;
pub const Z_UTIL_DEC_405: u32 = 404;
pub const Z_UTIL_DEC_406: u32 = 405;
pub const Z_UTIL_DEC_407: u32 = 406;
pub const Z_UTIL_DEC_408: u32 = 407;
pub const Z_UTIL_DEC_409: u32 = 408;
pub const Z_UTIL_DEC_410: u32 = 409;
pub const Z_UTIL_DEC_411: u32 = 410;
pub const Z_UTIL_DEC_412: u32 = 411;
pub const Z_UTIL_DEC_413: u32 = 412;
pub const Z_UTIL_DEC_414: u32 = 413;
pub const Z_UTIL_DEC_415: u32 = 414;
pub const Z_UTIL_DEC_416: u32 = 415;
pub const Z_UTIL_DEC_417: u32 = 416;
pub const Z_UTIL_DEC_418: u32 = 417;
pub const Z_UTIL_DEC_419: u32 = 418;
pub const Z_UTIL_DEC_420: u32 = 419;
pub const Z_UTIL_DEC_421: u32 = 420;
pub const Z_UTIL_DEC_422: u32 = 421;
pub const Z_UTIL_DEC_423: u32 = 422;
pub const Z_UTIL_DEC_424: u32 = 423;
pub const Z_UTIL_DEC_425: u32 = 424;
pub const Z_UTIL_DEC_426: u32 = 425;
pub const Z_UTIL_DEC_427: u32 = 426;
pub const Z_UTIL_DEC_428: u32 = 427;
pub const Z_UTIL_DEC_429: u32 = 428;
pub const Z_UTIL_DEC_430: u32 = 429;
pub const Z_UTIL_DEC_431: u32 = 430;
pub const Z_UTIL_DEC_432: u32 = 431;
pub const Z_UTIL_DEC_433: u32 = 432;
pub const Z_UTIL_DEC_434: u32 = 433;
pub const Z_UTIL_DEC_435: u32 = 434;
pub const Z_UTIL_DEC_436: u32 = 435;
pub const Z_UTIL_DEC_437: u32 = 436;
pub const Z_UTIL_DEC_438: u32 = 437;
pub const Z_UTIL_DEC_439: u32 = 438;
pub const Z_UTIL_DEC_440: u32 = 439;
pub const Z_UTIL_DEC_441: u32 = 440;
pub const Z_UTIL_DEC_442: u32 = 441;
pub const Z_UTIL_DEC_443: u32 = 442;
pub const Z_UTIL_DEC_444: u32 = 443;
pub const Z_UTIL_DEC_445: u32 = 444;
pub const Z_UTIL_DEC_446: u32 = 445;
pub const Z_UTIL_DEC_447: u32 = 446;
pub const Z_UTIL_DEC_448: u32 = 447;
pub const Z_UTIL_DEC_449: u32 = 448;
pub const Z_UTIL_DEC_450: u32 = 449;
pub const Z_UTIL_DEC_451: u32 = 450;
pub const Z_UTIL_DEC_452: u32 = 451;
pub const Z_UTIL_DEC_453: u32 = 452;
pub const Z_UTIL_DEC_454: u32 = 453;
pub const Z_UTIL_DEC_455: u32 = 454;
pub const Z_UTIL_DEC_456: u32 = 455;
pub const Z_UTIL_DEC_457: u32 = 456;
pub const Z_UTIL_DEC_458: u32 = 457;
pub const Z_UTIL_DEC_459: u32 = 458;
pub const Z_UTIL_DEC_460: u32 = 459;
pub const Z_UTIL_DEC_461: u32 = 460;
pub const Z_UTIL_DEC_462: u32 = 461;
pub const Z_UTIL_DEC_463: u32 = 462;
pub const Z_UTIL_DEC_464: u32 = 463;
pub const Z_UTIL_DEC_465: u32 = 464;
pub const Z_UTIL_DEC_466: u32 = 465;
pub const Z_UTIL_DEC_467: u32 = 466;
pub const Z_UTIL_DEC_468: u32 = 467;
pub const Z_UTIL_DEC_469: u32 = 468;
pub const Z_UTIL_DEC_470: u32 = 469;
pub const Z_UTIL_DEC_471: u32 = 470;
pub const Z_UTIL_DEC_472: u32 = 471;
pub const Z_UTIL_DEC_473: u32 = 472;
pub const Z_UTIL_DEC_474: u32 = 473;
pub const Z_UTIL_DEC_475: u32 = 474;
pub const Z_UTIL_DEC_476: u32 = 475;
pub const Z_UTIL_DEC_477: u32 = 476;
pub const Z_UTIL_DEC_478: u32 = 477;
pub const Z_UTIL_DEC_479: u32 = 478;
pub const Z_UTIL_DEC_480: u32 = 479;
pub const Z_UTIL_DEC_481: u32 = 480;
pub const Z_UTIL_DEC_482: u32 = 481;
pub const Z_UTIL_DEC_483: u32 = 482;
pub const Z_UTIL_DEC_484: u32 = 483;
pub const Z_UTIL_DEC_485: u32 = 484;
pub const Z_UTIL_DEC_486: u32 = 485;
pub const Z_UTIL_DEC_487: u32 = 486;
pub const Z_UTIL_DEC_488: u32 = 487;
pub const Z_UTIL_DEC_489: u32 = 488;
pub const Z_UTIL_DEC_490: u32 = 489;
pub const Z_UTIL_DEC_491: u32 = 490;
pub const Z_UTIL_DEC_492: u32 = 491;
pub const Z_UTIL_DEC_493: u32 = 492;
pub const Z_UTIL_DEC_494: u32 = 493;
pub const Z_UTIL_DEC_495: u32 = 494;
pub const Z_UTIL_DEC_496: u32 = 495;
pub const Z_UTIL_DEC_497: u32 = 496;
pub const Z_UTIL_DEC_498: u32 = 497;
pub const Z_UTIL_DEC_499: u32 = 498;
pub const Z_UTIL_DEC_500: u32 = 499;
pub const Z_UTIL_DEC_501: u32 = 500;
pub const Z_UTIL_DEC_502: u32 = 501;
pub const Z_UTIL_DEC_503: u32 = 502;
pub const Z_UTIL_DEC_504: u32 = 503;
pub const Z_UTIL_DEC_505: u32 = 504;
pub const Z_UTIL_DEC_506: u32 = 505;
pub const Z_UTIL_DEC_507: u32 = 506;
pub const Z_UTIL_DEC_508: u32 = 507;
pub const Z_UTIL_DEC_509: u32 = 508;
pub const Z_UTIL_DEC_510: u32 = 509;
pub const Z_UTIL_DEC_511: u32 = 510;
pub const Z_UTIL_DEC_512: u32 = 511;
pub const Z_UTIL_DEC_513: u32 = 512;
pub const Z_UTIL_DEC_514: u32 = 513;
pub const Z_UTIL_DEC_515: u32 = 514;
pub const Z_UTIL_DEC_516: u32 = 515;
pub const Z_UTIL_DEC_517: u32 = 516;
pub const Z_UTIL_DEC_518: u32 = 517;
pub const Z_UTIL_DEC_519: u32 = 518;
pub const Z_UTIL_DEC_520: u32 = 519;
pub const Z_UTIL_DEC_521: u32 = 520;
pub const Z_UTIL_DEC_522: u32 = 521;
pub const Z_UTIL_DEC_523: u32 = 522;
pub const Z_UTIL_DEC_524: u32 = 523;
pub const Z_UTIL_DEC_525: u32 = 524;
pub const Z_UTIL_DEC_526: u32 = 525;
pub const Z_UTIL_DEC_527: u32 = 526;
pub const Z_UTIL_DEC_528: u32 = 527;
pub const Z_UTIL_DEC_529: u32 = 528;
pub const Z_UTIL_DEC_530: u32 = 529;
pub const Z_UTIL_DEC_531: u32 = 530;
pub const Z_UTIL_DEC_532: u32 = 531;
pub const Z_UTIL_DEC_533: u32 = 532;
pub const Z_UTIL_DEC_534: u32 = 533;
pub const Z_UTIL_DEC_535: u32 = 534;
pub const Z_UTIL_DEC_536: u32 = 535;
pub const Z_UTIL_DEC_537: u32 = 536;
pub const Z_UTIL_DEC_538: u32 = 537;
pub const Z_UTIL_DEC_539: u32 = 538;
pub const Z_UTIL_DEC_540: u32 = 539;
pub const Z_UTIL_DEC_541: u32 = 540;
pub const Z_UTIL_DEC_542: u32 = 541;
pub const Z_UTIL_DEC_543: u32 = 542;
pub const Z_UTIL_DEC_544: u32 = 543;
pub const Z_UTIL_DEC_545: u32 = 544;
pub const Z_UTIL_DEC_546: u32 = 545;
pub const Z_UTIL_DEC_547: u32 = 546;
pub const Z_UTIL_DEC_548: u32 = 547;
pub const Z_UTIL_DEC_549: u32 = 548;
pub const Z_UTIL_DEC_550: u32 = 549;
pub const Z_UTIL_DEC_551: u32 = 550;
pub const Z_UTIL_DEC_552: u32 = 551;
pub const Z_UTIL_DEC_553: u32 = 552;
pub const Z_UTIL_DEC_554: u32 = 553;
pub const Z_UTIL_DEC_555: u32 = 554;
pub const Z_UTIL_DEC_556: u32 = 555;
pub const Z_UTIL_DEC_557: u32 = 556;
pub const Z_UTIL_DEC_558: u32 = 557;
pub const Z_UTIL_DEC_559: u32 = 558;
pub const Z_UTIL_DEC_560: u32 = 559;
pub const Z_UTIL_DEC_561: u32 = 560;
pub const Z_UTIL_DEC_562: u32 = 561;
pub const Z_UTIL_DEC_563: u32 = 562;
pub const Z_UTIL_DEC_564: u32 = 563;
pub const Z_UTIL_DEC_565: u32 = 564;
pub const Z_UTIL_DEC_566: u32 = 565;
pub const Z_UTIL_DEC_567: u32 = 566;
pub const Z_UTIL_DEC_568: u32 = 567;
pub const Z_UTIL_DEC_569: u32 = 568;
pub const Z_UTIL_DEC_570: u32 = 569;
pub const Z_UTIL_DEC_571: u32 = 570;
pub const Z_UTIL_DEC_572: u32 = 571;
pub const Z_UTIL_DEC_573: u32 = 572;
pub const Z_UTIL_DEC_574: u32 = 573;
pub const Z_UTIL_DEC_575: u32 = 574;
pub const Z_UTIL_DEC_576: u32 = 575;
pub const Z_UTIL_DEC_577: u32 = 576;
pub const Z_UTIL_DEC_578: u32 = 577;
pub const Z_UTIL_DEC_579: u32 = 578;
pub const Z_UTIL_DEC_580: u32 = 579;
pub const Z_UTIL_DEC_581: u32 = 580;
pub const Z_UTIL_DEC_582: u32 = 581;
pub const Z_UTIL_DEC_583: u32 = 582;
pub const Z_UTIL_DEC_584: u32 = 583;
pub const Z_UTIL_DEC_585: u32 = 584;
pub const Z_UTIL_DEC_586: u32 = 585;
pub const Z_UTIL_DEC_587: u32 = 586;
pub const Z_UTIL_DEC_588: u32 = 587;
pub const Z_UTIL_DEC_589: u32 = 588;
pub const Z_UTIL_DEC_590: u32 = 589;
pub const Z_UTIL_DEC_591: u32 = 590;
pub const Z_UTIL_DEC_592: u32 = 591;
pub const Z_UTIL_DEC_593: u32 = 592;
pub const Z_UTIL_DEC_594: u32 = 593;
pub const Z_UTIL_DEC_595: u32 = 594;
pub const Z_UTIL_DEC_596: u32 = 595;
pub const Z_UTIL_DEC_597: u32 = 596;
pub const Z_UTIL_DEC_598: u32 = 597;
pub const Z_UTIL_DEC_599: u32 = 598;
pub const Z_UTIL_DEC_600: u32 = 599;
pub const Z_UTIL_DEC_601: u32 = 600;
pub const Z_UTIL_DEC_602: u32 = 601;
pub const Z_UTIL_DEC_603: u32 = 602;
pub const Z_UTIL_DEC_604: u32 = 603;
pub const Z_UTIL_DEC_605: u32 = 604;
pub const Z_UTIL_DEC_606: u32 = 605;
pub const Z_UTIL_DEC_607: u32 = 606;
pub const Z_UTIL_DEC_608: u32 = 607;
pub const Z_UTIL_DEC_609: u32 = 608;
pub const Z_UTIL_DEC_610: u32 = 609;
pub const Z_UTIL_DEC_611: u32 = 610;
pub const Z_UTIL_DEC_612: u32 = 611;
pub const Z_UTIL_DEC_613: u32 = 612;
pub const Z_UTIL_DEC_614: u32 = 613;
pub const Z_UTIL_DEC_615: u32 = 614;
pub const Z_UTIL_DEC_616: u32 = 615;
pub const Z_UTIL_DEC_617: u32 = 616;
pub const Z_UTIL_DEC_618: u32 = 617;
pub const Z_UTIL_DEC_619: u32 = 618;
pub const Z_UTIL_DEC_620: u32 = 619;
pub const Z_UTIL_DEC_621: u32 = 620;
pub const Z_UTIL_DEC_622: u32 = 621;
pub const Z_UTIL_DEC_623: u32 = 622;
pub const Z_UTIL_DEC_624: u32 = 623;
pub const Z_UTIL_DEC_625: u32 = 624;
pub const Z_UTIL_DEC_626: u32 = 625;
pub const Z_UTIL_DEC_627: u32 = 626;
pub const Z_UTIL_DEC_628: u32 = 627;
pub const Z_UTIL_DEC_629: u32 = 628;
pub const Z_UTIL_DEC_630: u32 = 629;
pub const Z_UTIL_DEC_631: u32 = 630;
pub const Z_UTIL_DEC_632: u32 = 631;
pub const Z_UTIL_DEC_633: u32 = 632;
pub const Z_UTIL_DEC_634: u32 = 633;
pub const Z_UTIL_DEC_635: u32 = 634;
pub const Z_UTIL_DEC_636: u32 = 635;
pub const Z_UTIL_DEC_637: u32 = 636;
pub const Z_UTIL_DEC_638: u32 = 637;
pub const Z_UTIL_DEC_639: u32 = 638;
pub const Z_UTIL_DEC_640: u32 = 639;
pub const Z_UTIL_DEC_641: u32 = 640;
pub const Z_UTIL_DEC_642: u32 = 641;
pub const Z_UTIL_DEC_643: u32 = 642;
pub const Z_UTIL_DEC_644: u32 = 643;
pub const Z_UTIL_DEC_645: u32 = 644;
pub const Z_UTIL_DEC_646: u32 = 645;
pub const Z_UTIL_DEC_647: u32 = 646;
pub const Z_UTIL_DEC_648: u32 = 647;
pub const Z_UTIL_DEC_649: u32 = 648;
pub const Z_UTIL_DEC_650: u32 = 649;
pub const Z_UTIL_DEC_651: u32 = 650;
pub const Z_UTIL_DEC_652: u32 = 651;
pub const Z_UTIL_DEC_653: u32 = 652;
pub const Z_UTIL_DEC_654: u32 = 653;
pub const Z_UTIL_DEC_655: u32 = 654;
pub const Z_UTIL_DEC_656: u32 = 655;
pub const Z_UTIL_DEC_657: u32 = 656;
pub const Z_UTIL_DEC_658: u32 = 657;
pub const Z_UTIL_DEC_659: u32 = 658;
pub const Z_UTIL_DEC_660: u32 = 659;
pub const Z_UTIL_DEC_661: u32 = 660;
pub const Z_UTIL_DEC_662: u32 = 661;
pub const Z_UTIL_DEC_663: u32 = 662;
pub const Z_UTIL_DEC_664: u32 = 663;
pub const Z_UTIL_DEC_665: u32 = 664;
pub const Z_UTIL_DEC_666: u32 = 665;
pub const Z_UTIL_DEC_667: u32 = 666;
pub const Z_UTIL_DEC_668: u32 = 667;
pub const Z_UTIL_DEC_669: u32 = 668;
pub const Z_UTIL_DEC_670: u32 = 669;
pub const Z_UTIL_DEC_671: u32 = 670;
pub const Z_UTIL_DEC_672: u32 = 671;
pub const Z_UTIL_DEC_673: u32 = 672;
pub const Z_UTIL_DEC_674: u32 = 673;
pub const Z_UTIL_DEC_675: u32 = 674;
pub const Z_UTIL_DEC_676: u32 = 675;
pub const Z_UTIL_DEC_677: u32 = 676;
pub const Z_UTIL_DEC_678: u32 = 677;
pub const Z_UTIL_DEC_679: u32 = 678;
pub const Z_UTIL_DEC_680: u32 = 679;
pub const Z_UTIL_DEC_681: u32 = 680;
pub const Z_UTIL_DEC_682: u32 = 681;
pub const Z_UTIL_DEC_683: u32 = 682;
pub const Z_UTIL_DEC_684: u32 = 683;
pub const Z_UTIL_DEC_685: u32 = 684;
pub const Z_UTIL_DEC_686: u32 = 685;
pub const Z_UTIL_DEC_687: u32 = 686;
pub const Z_UTIL_DEC_688: u32 = 687;
pub const Z_UTIL_DEC_689: u32 = 688;
pub const Z_UTIL_DEC_690: u32 = 689;
pub const Z_UTIL_DEC_691: u32 = 690;
pub const Z_UTIL_DEC_692: u32 = 691;
pub const Z_UTIL_DEC_693: u32 = 692;
pub const Z_UTIL_DEC_694: u32 = 693;
pub const Z_UTIL_DEC_695: u32 = 694;
pub const Z_UTIL_DEC_696: u32 = 695;
pub const Z_UTIL_DEC_697: u32 = 696;
pub const Z_UTIL_DEC_698: u32 = 697;
pub const Z_UTIL_DEC_699: u32 = 698;
pub const Z_UTIL_DEC_700: u32 = 699;
pub const Z_UTIL_DEC_701: u32 = 700;
pub const Z_UTIL_DEC_702: u32 = 701;
pub const Z_UTIL_DEC_703: u32 = 702;
pub const Z_UTIL_DEC_704: u32 = 703;
pub const Z_UTIL_DEC_705: u32 = 704;
pub const Z_UTIL_DEC_706: u32 = 705;
pub const Z_UTIL_DEC_707: u32 = 706;
pub const Z_UTIL_DEC_708: u32 = 707;
pub const Z_UTIL_DEC_709: u32 = 708;
pub const Z_UTIL_DEC_710: u32 = 709;
pub const Z_UTIL_DEC_711: u32 = 710;
pub const Z_UTIL_DEC_712: u32 = 711;
pub const Z_UTIL_DEC_713: u32 = 712;
pub const Z_UTIL_DEC_714: u32 = 713;
pub const Z_UTIL_DEC_715: u32 = 714;
pub const Z_UTIL_DEC_716: u32 = 715;
pub const Z_UTIL_DEC_717: u32 = 716;
pub const Z_UTIL_DEC_718: u32 = 717;
pub const Z_UTIL_DEC_719: u32 = 718;
pub const Z_UTIL_DEC_720: u32 = 719;
pub const Z_UTIL_DEC_721: u32 = 720;
pub const Z_UTIL_DEC_722: u32 = 721;
pub const Z_UTIL_DEC_723: u32 = 722;
pub const Z_UTIL_DEC_724: u32 = 723;
pub const Z_UTIL_DEC_725: u32 = 724;
pub const Z_UTIL_DEC_726: u32 = 725;
pub const Z_UTIL_DEC_727: u32 = 726;
pub const Z_UTIL_DEC_728: u32 = 727;
pub const Z_UTIL_DEC_729: u32 = 728;
pub const Z_UTIL_DEC_730: u32 = 729;
pub const Z_UTIL_DEC_731: u32 = 730;
pub const Z_UTIL_DEC_732: u32 = 731;
pub const Z_UTIL_DEC_733: u32 = 732;
pub const Z_UTIL_DEC_734: u32 = 733;
pub const Z_UTIL_DEC_735: u32 = 734;
pub const Z_UTIL_DEC_736: u32 = 735;
pub const Z_UTIL_DEC_737: u32 = 736;
pub const Z_UTIL_DEC_738: u32 = 737;
pub const Z_UTIL_DEC_739: u32 = 738;
pub const Z_UTIL_DEC_740: u32 = 739;
pub const Z_UTIL_DEC_741: u32 = 740;
pub const Z_UTIL_DEC_742: u32 = 741;
pub const Z_UTIL_DEC_743: u32 = 742;
pub const Z_UTIL_DEC_744: u32 = 743;
pub const Z_UTIL_DEC_745: u32 = 744;
pub const Z_UTIL_DEC_746: u32 = 745;
pub const Z_UTIL_DEC_747: u32 = 746;
pub const Z_UTIL_DEC_748: u32 = 747;
pub const Z_UTIL_DEC_749: u32 = 748;
pub const Z_UTIL_DEC_750: u32 = 749;
pub const Z_UTIL_DEC_751: u32 = 750;
pub const Z_UTIL_DEC_752: u32 = 751;
pub const Z_UTIL_DEC_753: u32 = 752;
pub const Z_UTIL_DEC_754: u32 = 753;
pub const Z_UTIL_DEC_755: u32 = 754;
pub const Z_UTIL_DEC_756: u32 = 755;
pub const Z_UTIL_DEC_757: u32 = 756;
pub const Z_UTIL_DEC_758: u32 = 757;
pub const Z_UTIL_DEC_759: u32 = 758;
pub const Z_UTIL_DEC_760: u32 = 759;
pub const Z_UTIL_DEC_761: u32 = 760;
pub const Z_UTIL_DEC_762: u32 = 761;
pub const Z_UTIL_DEC_763: u32 = 762;
pub const Z_UTIL_DEC_764: u32 = 763;
pub const Z_UTIL_DEC_765: u32 = 764;
pub const Z_UTIL_DEC_766: u32 = 765;
pub const Z_UTIL_DEC_767: u32 = 766;
pub const Z_UTIL_DEC_768: u32 = 767;
pub const Z_UTIL_DEC_769: u32 = 768;
pub const Z_UTIL_DEC_770: u32 = 769;
pub const Z_UTIL_DEC_771: u32 = 770;
pub const Z_UTIL_DEC_772: u32 = 771;
pub const Z_UTIL_DEC_773: u32 = 772;
pub const Z_UTIL_DEC_774: u32 = 773;
pub const Z_UTIL_DEC_775: u32 = 774;
pub const Z_UTIL_DEC_776: u32 = 775;
pub const Z_UTIL_DEC_777: u32 = 776;
pub const Z_UTIL_DEC_778: u32 = 777;
pub const Z_UTIL_DEC_779: u32 = 778;
pub const Z_UTIL_DEC_780: u32 = 779;
pub const Z_UTIL_DEC_781: u32 = 780;
pub const Z_UTIL_DEC_782: u32 = 781;
pub const Z_UTIL_DEC_783: u32 = 782;
pub const Z_UTIL_DEC_784: u32 = 783;
pub const Z_UTIL_DEC_785: u32 = 784;
pub const Z_UTIL_DEC_786: u32 = 785;
pub const Z_UTIL_DEC_787: u32 = 786;
pub const Z_UTIL_DEC_788: u32 = 787;
pub const Z_UTIL_DEC_789: u32 = 788;
pub const Z_UTIL_DEC_790: u32 = 789;
pub const Z_UTIL_DEC_791: u32 = 790;
pub const Z_UTIL_DEC_792: u32 = 791;
pub const Z_UTIL_DEC_793: u32 = 792;
pub const Z_UTIL_DEC_794: u32 = 793;
pub const Z_UTIL_DEC_795: u32 = 794;
pub const Z_UTIL_DEC_796: u32 = 795;
pub const Z_UTIL_DEC_797: u32 = 796;
pub const Z_UTIL_DEC_798: u32 = 797;
pub const Z_UTIL_DEC_799: u32 = 798;
pub const Z_UTIL_DEC_800: u32 = 799;
pub const Z_UTIL_DEC_801: u32 = 800;
pub const Z_UTIL_DEC_802: u32 = 801;
pub const Z_UTIL_DEC_803: u32 = 802;
pub const Z_UTIL_DEC_804: u32 = 803;
pub const Z_UTIL_DEC_805: u32 = 804;
pub const Z_UTIL_DEC_806: u32 = 805;
pub const Z_UTIL_DEC_807: u32 = 806;
pub const Z_UTIL_DEC_808: u32 = 807;
pub const Z_UTIL_DEC_809: u32 = 808;
pub const Z_UTIL_DEC_810: u32 = 809;
pub const Z_UTIL_DEC_811: u32 = 810;
pub const Z_UTIL_DEC_812: u32 = 811;
pub const Z_UTIL_DEC_813: u32 = 812;
pub const Z_UTIL_DEC_814: u32 = 813;
pub const Z_UTIL_DEC_815: u32 = 814;
pub const Z_UTIL_DEC_816: u32 = 815;
pub const Z_UTIL_DEC_817: u32 = 816;
pub const Z_UTIL_DEC_818: u32 = 817;
pub const Z_UTIL_DEC_819: u32 = 818;
pub const Z_UTIL_DEC_820: u32 = 819;
pub const Z_UTIL_DEC_821: u32 = 820;
pub const Z_UTIL_DEC_822: u32 = 821;
pub const Z_UTIL_DEC_823: u32 = 822;
pub const Z_UTIL_DEC_824: u32 = 823;
pub const Z_UTIL_DEC_825: u32 = 824;
pub const Z_UTIL_DEC_826: u32 = 825;
pub const Z_UTIL_DEC_827: u32 = 826;
pub const Z_UTIL_DEC_828: u32 = 827;
pub const Z_UTIL_DEC_829: u32 = 828;
pub const Z_UTIL_DEC_830: u32 = 829;
pub const Z_UTIL_DEC_831: u32 = 830;
pub const Z_UTIL_DEC_832: u32 = 831;
pub const Z_UTIL_DEC_833: u32 = 832;
pub const Z_UTIL_DEC_834: u32 = 833;
pub const Z_UTIL_DEC_835: u32 = 834;
pub const Z_UTIL_DEC_836: u32 = 835;
pub const Z_UTIL_DEC_837: u32 = 836;
pub const Z_UTIL_DEC_838: u32 = 837;
pub const Z_UTIL_DEC_839: u32 = 838;
pub const Z_UTIL_DEC_840: u32 = 839;
pub const Z_UTIL_DEC_841: u32 = 840;
pub const Z_UTIL_DEC_842: u32 = 841;
pub const Z_UTIL_DEC_843: u32 = 842;
pub const Z_UTIL_DEC_844: u32 = 843;
pub const Z_UTIL_DEC_845: u32 = 844;
pub const Z_UTIL_DEC_846: u32 = 845;
pub const Z_UTIL_DEC_847: u32 = 846;
pub const Z_UTIL_DEC_848: u32 = 847;
pub const Z_UTIL_DEC_849: u32 = 848;
pub const Z_UTIL_DEC_850: u32 = 849;
pub const Z_UTIL_DEC_851: u32 = 850;
pub const Z_UTIL_DEC_852: u32 = 851;
pub const Z_UTIL_DEC_853: u32 = 852;
pub const Z_UTIL_DEC_854: u32 = 853;
pub const Z_UTIL_DEC_855: u32 = 854;
pub const Z_UTIL_DEC_856: u32 = 855;
pub const Z_UTIL_DEC_857: u32 = 856;
pub const Z_UTIL_DEC_858: u32 = 857;
pub const Z_UTIL_DEC_859: u32 = 858;
pub const Z_UTIL_DEC_860: u32 = 859;
pub const Z_UTIL_DEC_861: u32 = 860;
pub const Z_UTIL_DEC_862: u32 = 861;
pub const Z_UTIL_DEC_863: u32 = 862;
pub const Z_UTIL_DEC_864: u32 = 863;
pub const Z_UTIL_DEC_865: u32 = 864;
pub const Z_UTIL_DEC_866: u32 = 865;
pub const Z_UTIL_DEC_867: u32 = 866;
pub const Z_UTIL_DEC_868: u32 = 867;
pub const Z_UTIL_DEC_869: u32 = 868;
pub const Z_UTIL_DEC_870: u32 = 869;
pub const Z_UTIL_DEC_871: u32 = 870;
pub const Z_UTIL_DEC_872: u32 = 871;
pub const Z_UTIL_DEC_873: u32 = 872;
pub const Z_UTIL_DEC_874: u32 = 873;
pub const Z_UTIL_DEC_875: u32 = 874;
pub const Z_UTIL_DEC_876: u32 = 875;
pub const Z_UTIL_DEC_877: u32 = 876;
pub const Z_UTIL_DEC_878: u32 = 877;
pub const Z_UTIL_DEC_879: u32 = 878;
pub const Z_UTIL_DEC_880: u32 = 879;
pub const Z_UTIL_DEC_881: u32 = 880;
pub const Z_UTIL_DEC_882: u32 = 881;
pub const Z_UTIL_DEC_883: u32 = 882;
pub const Z_UTIL_DEC_884: u32 = 883;
pub const Z_UTIL_DEC_885: u32 = 884;
pub const Z_UTIL_DEC_886: u32 = 885;
pub const Z_UTIL_DEC_887: u32 = 886;
pub const Z_UTIL_DEC_888: u32 = 887;
pub const Z_UTIL_DEC_889: u32 = 888;
pub const Z_UTIL_DEC_890: u32 = 889;
pub const Z_UTIL_DEC_891: u32 = 890;
pub const Z_UTIL_DEC_892: u32 = 891;
pub const Z_UTIL_DEC_893: u32 = 892;
pub const Z_UTIL_DEC_894: u32 = 893;
pub const Z_UTIL_DEC_895: u32 = 894;
pub const Z_UTIL_DEC_896: u32 = 895;
pub const Z_UTIL_DEC_897: u32 = 896;
pub const Z_UTIL_DEC_898: u32 = 897;
pub const Z_UTIL_DEC_899: u32 = 898;
pub const Z_UTIL_DEC_900: u32 = 899;
pub const Z_UTIL_DEC_901: u32 = 900;
pub const Z_UTIL_DEC_902: u32 = 901;
pub const Z_UTIL_DEC_903: u32 = 902;
pub const Z_UTIL_DEC_904: u32 = 903;
pub const Z_UTIL_DEC_905: u32 = 904;
pub const Z_UTIL_DEC_906: u32 = 905;
pub const Z_UTIL_DEC_907: u32 = 906;
pub const Z_UTIL_DEC_908: u32 = 907;
pub const Z_UTIL_DEC_909: u32 = 908;
pub const Z_UTIL_DEC_910: u32 = 909;
pub const Z_UTIL_DEC_911: u32 = 910;
pub const Z_UTIL_DEC_912: u32 = 911;
pub const Z_UTIL_DEC_913: u32 = 912;
pub const Z_UTIL_DEC_914: u32 = 913;
pub const Z_UTIL_DEC_915: u32 = 914;
pub const Z_UTIL_DEC_916: u32 = 915;
pub const Z_UTIL_DEC_917: u32 = 916;
pub const Z_UTIL_DEC_918: u32 = 917;
pub const Z_UTIL_DEC_919: u32 = 918;
pub const Z_UTIL_DEC_920: u32 = 919;
pub const Z_UTIL_DEC_921: u32 = 920;
pub const Z_UTIL_DEC_922: u32 = 921;
pub const Z_UTIL_DEC_923: u32 = 922;
pub const Z_UTIL_DEC_924: u32 = 923;
pub const Z_UTIL_DEC_925: u32 = 924;
pub const Z_UTIL_DEC_926: u32 = 925;
pub const Z_UTIL_DEC_927: u32 = 926;
pub const Z_UTIL_DEC_928: u32 = 927;
pub const Z_UTIL_DEC_929: u32 = 928;
pub const Z_UTIL_DEC_930: u32 = 929;
pub const Z_UTIL_DEC_931: u32 = 930;
pub const Z_UTIL_DEC_932: u32 = 931;
pub const Z_UTIL_DEC_933: u32 = 932;
pub const Z_UTIL_DEC_934: u32 = 933;
pub const Z_UTIL_DEC_935: u32 = 934;
pub const Z_UTIL_DEC_936: u32 = 935;
pub const Z_UTIL_DEC_937: u32 = 936;
pub const Z_UTIL_DEC_938: u32 = 937;
pub const Z_UTIL_DEC_939: u32 = 938;
pub const Z_UTIL_DEC_940: u32 = 939;
pub const Z_UTIL_DEC_941: u32 = 940;
pub const Z_UTIL_DEC_942: u32 = 941;
pub const Z_UTIL_DEC_943: u32 = 942;
pub const Z_UTIL_DEC_944: u32 = 943;
pub const Z_UTIL_DEC_945: u32 = 944;
pub const Z_UTIL_DEC_946: u32 = 945;
pub const Z_UTIL_DEC_947: u32 = 946;
pub const Z_UTIL_DEC_948: u32 = 947;
pub const Z_UTIL_DEC_949: u32 = 948;
pub const Z_UTIL_DEC_950: u32 = 949;
pub const Z_UTIL_DEC_951: u32 = 950;
pub const Z_UTIL_DEC_952: u32 = 951;
pub const Z_UTIL_DEC_953: u32 = 952;
pub const Z_UTIL_DEC_954: u32 = 953;
pub const Z_UTIL_DEC_955: u32 = 954;
pub const Z_UTIL_DEC_956: u32 = 955;
pub const Z_UTIL_DEC_957: u32 = 956;
pub const Z_UTIL_DEC_958: u32 = 957;
pub const Z_UTIL_DEC_959: u32 = 958;
pub const Z_UTIL_DEC_960: u32 = 959;
pub const Z_UTIL_DEC_961: u32 = 960;
pub const Z_UTIL_DEC_962: u32 = 961;
pub const Z_UTIL_DEC_963: u32 = 962;
pub const Z_UTIL_DEC_964: u32 = 963;
pub const Z_UTIL_DEC_965: u32 = 964;
pub const Z_UTIL_DEC_966: u32 = 965;
pub const Z_UTIL_DEC_967: u32 = 966;
pub const Z_UTIL_DEC_968: u32 = 967;
pub const Z_UTIL_DEC_969: u32 = 968;
pub const Z_UTIL_DEC_970: u32 = 969;
pub const Z_UTIL_DEC_971: u32 = 970;
pub const Z_UTIL_DEC_972: u32 = 971;
pub const Z_UTIL_DEC_973: u32 = 972;
pub const Z_UTIL_DEC_974: u32 = 973;
pub const Z_UTIL_DEC_975: u32 = 974;
pub const Z_UTIL_DEC_976: u32 = 975;
pub const Z_UTIL_DEC_977: u32 = 976;
pub const Z_UTIL_DEC_978: u32 = 977;
pub const Z_UTIL_DEC_979: u32 = 978;
pub const Z_UTIL_DEC_980: u32 = 979;
pub const Z_UTIL_DEC_981: u32 = 980;
pub const Z_UTIL_DEC_982: u32 = 981;
pub const Z_UTIL_DEC_983: u32 = 982;
pub const Z_UTIL_DEC_984: u32 = 983;
pub const Z_UTIL_DEC_985: u32 = 984;
pub const Z_UTIL_DEC_986: u32 = 985;
pub const Z_UTIL_DEC_987: u32 = 986;
pub const Z_UTIL_DEC_988: u32 = 987;
pub const Z_UTIL_DEC_989: u32 = 988;
pub const Z_UTIL_DEC_990: u32 = 989;
pub const Z_UTIL_DEC_991: u32 = 990;
pub const Z_UTIL_DEC_992: u32 = 991;
pub const Z_UTIL_DEC_993: u32 = 992;
pub const Z_UTIL_DEC_994: u32 = 993;
pub const Z_UTIL_DEC_995: u32 = 994;
pub const Z_UTIL_DEC_996: u32 = 995;
pub const Z_UTIL_DEC_997: u32 = 996;
pub const Z_UTIL_DEC_998: u32 = 997;
pub const Z_UTIL_DEC_999: u32 = 998;
pub const Z_UTIL_DEC_1000: u32 = 999;
pub const Z_UTIL_DEC_1001: u32 = 1000;
pub const Z_UTIL_DEC_1002: u32 = 1001;
pub const Z_UTIL_DEC_1003: u32 = 1002;
pub const Z_UTIL_DEC_1004: u32 = 1003;
pub const Z_UTIL_DEC_1005: u32 = 1004;
pub const Z_UTIL_DEC_1006: u32 = 1005;
pub const Z_UTIL_DEC_1007: u32 = 1006;
pub const Z_UTIL_DEC_1008: u32 = 1007;
pub const Z_UTIL_DEC_1009: u32 = 1008;
pub const Z_UTIL_DEC_1010: u32 = 1009;
pub const Z_UTIL_DEC_1011: u32 = 1010;
pub const Z_UTIL_DEC_1012: u32 = 1011;
pub const Z_UTIL_DEC_1013: u32 = 1012;
pub const Z_UTIL_DEC_1014: u32 = 1013;
pub const Z_UTIL_DEC_1015: u32 = 1014;
pub const Z_UTIL_DEC_1016: u32 = 1015;
pub const Z_UTIL_DEC_1017: u32 = 1016;
pub const Z_UTIL_DEC_1018: u32 = 1017;
pub const Z_UTIL_DEC_1019: u32 = 1018;
pub const Z_UTIL_DEC_1020: u32 = 1019;
pub const Z_UTIL_DEC_1021: u32 = 1020;
pub const Z_UTIL_DEC_1022: u32 = 1021;
pub const Z_UTIL_DEC_1023: u32 = 1022;
pub const Z_UTIL_DEC_1024: u32 = 1023;
pub const Z_UTIL_DEC_1025: u32 = 1024;
pub const Z_UTIL_DEC_1026: u32 = 1025;
pub const Z_UTIL_DEC_1027: u32 = 1026;
pub const Z_UTIL_DEC_1028: u32 = 1027;
pub const Z_UTIL_DEC_1029: u32 = 1028;
pub const Z_UTIL_DEC_1030: u32 = 1029;
pub const Z_UTIL_DEC_1031: u32 = 1030;
pub const Z_UTIL_DEC_1032: u32 = 1031;
pub const Z_UTIL_DEC_1033: u32 = 1032;
pub const Z_UTIL_DEC_1034: u32 = 1033;
pub const Z_UTIL_DEC_1035: u32 = 1034;
pub const Z_UTIL_DEC_1036: u32 = 1035;
pub const Z_UTIL_DEC_1037: u32 = 1036;
pub const Z_UTIL_DEC_1038: u32 = 1037;
pub const Z_UTIL_DEC_1039: u32 = 1038;
pub const Z_UTIL_DEC_1040: u32 = 1039;
pub const Z_UTIL_DEC_1041: u32 = 1040;
pub const Z_UTIL_DEC_1042: u32 = 1041;
pub const Z_UTIL_DEC_1043: u32 = 1042;
pub const Z_UTIL_DEC_1044: u32 = 1043;
pub const Z_UTIL_DEC_1045: u32 = 1044;
pub const Z_UTIL_DEC_1046: u32 = 1045;
pub const Z_UTIL_DEC_1047: u32 = 1046;
pub const Z_UTIL_DEC_1048: u32 = 1047;
pub const Z_UTIL_DEC_1049: u32 = 1048;
pub const Z_UTIL_DEC_1050: u32 = 1049;
pub const Z_UTIL_DEC_1051: u32 = 1050;
pub const Z_UTIL_DEC_1052: u32 = 1051;
pub const Z_UTIL_DEC_1053: u32 = 1052;
pub const Z_UTIL_DEC_1054: u32 = 1053;
pub const Z_UTIL_DEC_1055: u32 = 1054;
pub const Z_UTIL_DEC_1056: u32 = 1055;
pub const Z_UTIL_DEC_1057: u32 = 1056;
pub const Z_UTIL_DEC_1058: u32 = 1057;
pub const Z_UTIL_DEC_1059: u32 = 1058;
pub const Z_UTIL_DEC_1060: u32 = 1059;
pub const Z_UTIL_DEC_1061: u32 = 1060;
pub const Z_UTIL_DEC_1062: u32 = 1061;
pub const Z_UTIL_DEC_1063: u32 = 1062;
pub const Z_UTIL_DEC_1064: u32 = 1063;
pub const Z_UTIL_DEC_1065: u32 = 1064;
pub const Z_UTIL_DEC_1066: u32 = 1065;
pub const Z_UTIL_DEC_1067: u32 = 1066;
pub const Z_UTIL_DEC_1068: u32 = 1067;
pub const Z_UTIL_DEC_1069: u32 = 1068;
pub const Z_UTIL_DEC_1070: u32 = 1069;
pub const Z_UTIL_DEC_1071: u32 = 1070;
pub const Z_UTIL_DEC_1072: u32 = 1071;
pub const Z_UTIL_DEC_1073: u32 = 1072;
pub const Z_UTIL_DEC_1074: u32 = 1073;
pub const Z_UTIL_DEC_1075: u32 = 1074;
pub const Z_UTIL_DEC_1076: u32 = 1075;
pub const Z_UTIL_DEC_1077: u32 = 1076;
pub const Z_UTIL_DEC_1078: u32 = 1077;
pub const Z_UTIL_DEC_1079: u32 = 1078;
pub const Z_UTIL_DEC_1080: u32 = 1079;
pub const Z_UTIL_DEC_1081: u32 = 1080;
pub const Z_UTIL_DEC_1082: u32 = 1081;
pub const Z_UTIL_DEC_1083: u32 = 1082;
pub const Z_UTIL_DEC_1084: u32 = 1083;
pub const Z_UTIL_DEC_1085: u32 = 1084;
pub const Z_UTIL_DEC_1086: u32 = 1085;
pub const Z_UTIL_DEC_1087: u32 = 1086;
pub const Z_UTIL_DEC_1088: u32 = 1087;
pub const Z_UTIL_DEC_1089: u32 = 1088;
pub const Z_UTIL_DEC_1090: u32 = 1089;
pub const Z_UTIL_DEC_1091: u32 = 1090;
pub const Z_UTIL_DEC_1092: u32 = 1091;
pub const Z_UTIL_DEC_1093: u32 = 1092;
pub const Z_UTIL_DEC_1094: u32 = 1093;
pub const Z_UTIL_DEC_1095: u32 = 1094;
pub const Z_UTIL_DEC_1096: u32 = 1095;
pub const Z_UTIL_DEC_1097: u32 = 1096;
pub const Z_UTIL_DEC_1098: u32 = 1097;
pub const Z_UTIL_DEC_1099: u32 = 1098;
pub const Z_UTIL_DEC_1100: u32 = 1099;
pub const Z_UTIL_DEC_1101: u32 = 1100;
pub const Z_UTIL_DEC_1102: u32 = 1101;
pub const Z_UTIL_DEC_1103: u32 = 1102;
pub const Z_UTIL_DEC_1104: u32 = 1103;
pub const Z_UTIL_DEC_1105: u32 = 1104;
pub const Z_UTIL_DEC_1106: u32 = 1105;
pub const Z_UTIL_DEC_1107: u32 = 1106;
pub const Z_UTIL_DEC_1108: u32 = 1107;
pub const Z_UTIL_DEC_1109: u32 = 1108;
pub const Z_UTIL_DEC_1110: u32 = 1109;
pub const Z_UTIL_DEC_1111: u32 = 1110;
pub const Z_UTIL_DEC_1112: u32 = 1111;
pub const Z_UTIL_DEC_1113: u32 = 1112;
pub const Z_UTIL_DEC_1114: u32 = 1113;
pub const Z_UTIL_DEC_1115: u32 = 1114;
pub const Z_UTIL_DEC_1116: u32 = 1115;
pub const Z_UTIL_DEC_1117: u32 = 1116;
pub const Z_UTIL_DEC_1118: u32 = 1117;
pub const Z_UTIL_DEC_1119: u32 = 1118;
pub const Z_UTIL_DEC_1120: u32 = 1119;
pub const Z_UTIL_DEC_1121: u32 = 1120;
pub const Z_UTIL_DEC_1122: u32 = 1121;
pub const Z_UTIL_DEC_1123: u32 = 1122;
pub const Z_UTIL_DEC_1124: u32 = 1123;
pub const Z_UTIL_DEC_1125: u32 = 1124;
pub const Z_UTIL_DEC_1126: u32 = 1125;
pub const Z_UTIL_DEC_1127: u32 = 1126;
pub const Z_UTIL_DEC_1128: u32 = 1127;
pub const Z_UTIL_DEC_1129: u32 = 1128;
pub const Z_UTIL_DEC_1130: u32 = 1129;
pub const Z_UTIL_DEC_1131: u32 = 1130;
pub const Z_UTIL_DEC_1132: u32 = 1131;
pub const Z_UTIL_DEC_1133: u32 = 1132;
pub const Z_UTIL_DEC_1134: u32 = 1133;
pub const Z_UTIL_DEC_1135: u32 = 1134;
pub const Z_UTIL_DEC_1136: u32 = 1135;
pub const Z_UTIL_DEC_1137: u32 = 1136;
pub const Z_UTIL_DEC_1138: u32 = 1137;
pub const Z_UTIL_DEC_1139: u32 = 1138;
pub const Z_UTIL_DEC_1140: u32 = 1139;
pub const Z_UTIL_DEC_1141: u32 = 1140;
pub const Z_UTIL_DEC_1142: u32 = 1141;
pub const Z_UTIL_DEC_1143: u32 = 1142;
pub const Z_UTIL_DEC_1144: u32 = 1143;
pub const Z_UTIL_DEC_1145: u32 = 1144;
pub const Z_UTIL_DEC_1146: u32 = 1145;
pub const Z_UTIL_DEC_1147: u32 = 1146;
pub const Z_UTIL_DEC_1148: u32 = 1147;
pub const Z_UTIL_DEC_1149: u32 = 1148;
pub const Z_UTIL_DEC_1150: u32 = 1149;
pub const Z_UTIL_DEC_1151: u32 = 1150;
pub const Z_UTIL_DEC_1152: u32 = 1151;
pub const Z_UTIL_DEC_1153: u32 = 1152;
pub const Z_UTIL_DEC_1154: u32 = 1153;
pub const Z_UTIL_DEC_1155: u32 = 1154;
pub const Z_UTIL_DEC_1156: u32 = 1155;
pub const Z_UTIL_DEC_1157: u32 = 1156;
pub const Z_UTIL_DEC_1158: u32 = 1157;
pub const Z_UTIL_DEC_1159: u32 = 1158;
pub const Z_UTIL_DEC_1160: u32 = 1159;
pub const Z_UTIL_DEC_1161: u32 = 1160;
pub const Z_UTIL_DEC_1162: u32 = 1161;
pub const Z_UTIL_DEC_1163: u32 = 1162;
pub const Z_UTIL_DEC_1164: u32 = 1163;
pub const Z_UTIL_DEC_1165: u32 = 1164;
pub const Z_UTIL_DEC_1166: u32 = 1165;
pub const Z_UTIL_DEC_1167: u32 = 1166;
pub const Z_UTIL_DEC_1168: u32 = 1167;
pub const Z_UTIL_DEC_1169: u32 = 1168;
pub const Z_UTIL_DEC_1170: u32 = 1169;
pub const Z_UTIL_DEC_1171: u32 = 1170;
pub const Z_UTIL_DEC_1172: u32 = 1171;
pub const Z_UTIL_DEC_1173: u32 = 1172;
pub const Z_UTIL_DEC_1174: u32 = 1173;
pub const Z_UTIL_DEC_1175: u32 = 1174;
pub const Z_UTIL_DEC_1176: u32 = 1175;
pub const Z_UTIL_DEC_1177: u32 = 1176;
pub const Z_UTIL_DEC_1178: u32 = 1177;
pub const Z_UTIL_DEC_1179: u32 = 1178;
pub const Z_UTIL_DEC_1180: u32 = 1179;
pub const Z_UTIL_DEC_1181: u32 = 1180;
pub const Z_UTIL_DEC_1182: u32 = 1181;
pub const Z_UTIL_DEC_1183: u32 = 1182;
pub const Z_UTIL_DEC_1184: u32 = 1183;
pub const Z_UTIL_DEC_1185: u32 = 1184;
pub const Z_UTIL_DEC_1186: u32 = 1185;
pub const Z_UTIL_DEC_1187: u32 = 1186;
pub const Z_UTIL_DEC_1188: u32 = 1187;
pub const Z_UTIL_DEC_1189: u32 = 1188;
pub const Z_UTIL_DEC_1190: u32 = 1189;
pub const Z_UTIL_DEC_1191: u32 = 1190;
pub const Z_UTIL_DEC_1192: u32 = 1191;
pub const Z_UTIL_DEC_1193: u32 = 1192;
pub const Z_UTIL_DEC_1194: u32 = 1193;
pub const Z_UTIL_DEC_1195: u32 = 1194;
pub const Z_UTIL_DEC_1196: u32 = 1195;
pub const Z_UTIL_DEC_1197: u32 = 1196;
pub const Z_UTIL_DEC_1198: u32 = 1197;
pub const Z_UTIL_DEC_1199: u32 = 1198;
pub const Z_UTIL_DEC_1200: u32 = 1199;
pub const Z_UTIL_DEC_1201: u32 = 1200;
pub const Z_UTIL_DEC_1202: u32 = 1201;
pub const Z_UTIL_DEC_1203: u32 = 1202;
pub const Z_UTIL_DEC_1204: u32 = 1203;
pub const Z_UTIL_DEC_1205: u32 = 1204;
pub const Z_UTIL_DEC_1206: u32 = 1205;
pub const Z_UTIL_DEC_1207: u32 = 1206;
pub const Z_UTIL_DEC_1208: u32 = 1207;
pub const Z_UTIL_DEC_1209: u32 = 1208;
pub const Z_UTIL_DEC_1210: u32 = 1209;
pub const Z_UTIL_DEC_1211: u32 = 1210;
pub const Z_UTIL_DEC_1212: u32 = 1211;
pub const Z_UTIL_DEC_1213: u32 = 1212;
pub const Z_UTIL_DEC_1214: u32 = 1213;
pub const Z_UTIL_DEC_1215: u32 = 1214;
pub const Z_UTIL_DEC_1216: u32 = 1215;
pub const Z_UTIL_DEC_1217: u32 = 1216;
pub const Z_UTIL_DEC_1218: u32 = 1217;
pub const Z_UTIL_DEC_1219: u32 = 1218;
pub const Z_UTIL_DEC_1220: u32 = 1219;
pub const Z_UTIL_DEC_1221: u32 = 1220;
pub const Z_UTIL_DEC_1222: u32 = 1221;
pub const Z_UTIL_DEC_1223: u32 = 1222;
pub const Z_UTIL_DEC_1224: u32 = 1223;
pub const Z_UTIL_DEC_1225: u32 = 1224;
pub const Z_UTIL_DEC_1226: u32 = 1225;
pub const Z_UTIL_DEC_1227: u32 = 1226;
pub const Z_UTIL_DEC_1228: u32 = 1227;
pub const Z_UTIL_DEC_1229: u32 = 1228;
pub const Z_UTIL_DEC_1230: u32 = 1229;
pub const Z_UTIL_DEC_1231: u32 = 1230;
pub const Z_UTIL_DEC_1232: u32 = 1231;
pub const Z_UTIL_DEC_1233: u32 = 1232;
pub const Z_UTIL_DEC_1234: u32 = 1233;
pub const Z_UTIL_DEC_1235: u32 = 1234;
pub const Z_UTIL_DEC_1236: u32 = 1235;
pub const Z_UTIL_DEC_1237: u32 = 1236;
pub const Z_UTIL_DEC_1238: u32 = 1237;
pub const Z_UTIL_DEC_1239: u32 = 1238;
pub const Z_UTIL_DEC_1240: u32 = 1239;
pub const Z_UTIL_DEC_1241: u32 = 1240;
pub const Z_UTIL_DEC_1242: u32 = 1241;
pub const Z_UTIL_DEC_1243: u32 = 1242;
pub const Z_UTIL_DEC_1244: u32 = 1243;
pub const Z_UTIL_DEC_1245: u32 = 1244;
pub const Z_UTIL_DEC_1246: u32 = 1245;
pub const Z_UTIL_DEC_1247: u32 = 1246;
pub const Z_UTIL_DEC_1248: u32 = 1247;
pub const Z_UTIL_DEC_1249: u32 = 1248;
pub const Z_UTIL_DEC_1250: u32 = 1249;
pub const Z_UTIL_DEC_1251: u32 = 1250;
pub const Z_UTIL_DEC_1252: u32 = 1251;
pub const Z_UTIL_DEC_1253: u32 = 1252;
pub const Z_UTIL_DEC_1254: u32 = 1253;
pub const Z_UTIL_DEC_1255: u32 = 1254;
pub const Z_UTIL_DEC_1256: u32 = 1255;
pub const Z_UTIL_DEC_1257: u32 = 1256;
pub const Z_UTIL_DEC_1258: u32 = 1257;
pub const Z_UTIL_DEC_1259: u32 = 1258;
pub const Z_UTIL_DEC_1260: u32 = 1259;
pub const Z_UTIL_DEC_1261: u32 = 1260;
pub const Z_UTIL_DEC_1262: u32 = 1261;
pub const Z_UTIL_DEC_1263: u32 = 1262;
pub const Z_UTIL_DEC_1264: u32 = 1263;
pub const Z_UTIL_DEC_1265: u32 = 1264;
pub const Z_UTIL_DEC_1266: u32 = 1265;
pub const Z_UTIL_DEC_1267: u32 = 1266;
pub const Z_UTIL_DEC_1268: u32 = 1267;
pub const Z_UTIL_DEC_1269: u32 = 1268;
pub const Z_UTIL_DEC_1270: u32 = 1269;
pub const Z_UTIL_DEC_1271: u32 = 1270;
pub const Z_UTIL_DEC_1272: u32 = 1271;
pub const Z_UTIL_DEC_1273: u32 = 1272;
pub const Z_UTIL_DEC_1274: u32 = 1273;
pub const Z_UTIL_DEC_1275: u32 = 1274;
pub const Z_UTIL_DEC_1276: u32 = 1275;
pub const Z_UTIL_DEC_1277: u32 = 1276;
pub const Z_UTIL_DEC_1278: u32 = 1277;
pub const Z_UTIL_DEC_1279: u32 = 1278;
pub const Z_UTIL_DEC_1280: u32 = 1279;
pub const Z_UTIL_DEC_1281: u32 = 1280;
pub const Z_UTIL_DEC_1282: u32 = 1281;
pub const Z_UTIL_DEC_1283: u32 = 1282;
pub const Z_UTIL_DEC_1284: u32 = 1283;
pub const Z_UTIL_DEC_1285: u32 = 1284;
pub const Z_UTIL_DEC_1286: u32 = 1285;
pub const Z_UTIL_DEC_1287: u32 = 1286;
pub const Z_UTIL_DEC_1288: u32 = 1287;
pub const Z_UTIL_DEC_1289: u32 = 1288;
pub const Z_UTIL_DEC_1290: u32 = 1289;
pub const Z_UTIL_DEC_1291: u32 = 1290;
pub const Z_UTIL_DEC_1292: u32 = 1291;
pub const Z_UTIL_DEC_1293: u32 = 1292;
pub const Z_UTIL_DEC_1294: u32 = 1293;
pub const Z_UTIL_DEC_1295: u32 = 1294;
pub const Z_UTIL_DEC_1296: u32 = 1295;
pub const Z_UTIL_DEC_1297: u32 = 1296;
pub const Z_UTIL_DEC_1298: u32 = 1297;
pub const Z_UTIL_DEC_1299: u32 = 1298;
pub const Z_UTIL_DEC_1300: u32 = 1299;
pub const Z_UTIL_DEC_1301: u32 = 1300;
pub const Z_UTIL_DEC_1302: u32 = 1301;
pub const Z_UTIL_DEC_1303: u32 = 1302;
pub const Z_UTIL_DEC_1304: u32 = 1303;
pub const Z_UTIL_DEC_1305: u32 = 1304;
pub const Z_UTIL_DEC_1306: u32 = 1305;
pub const Z_UTIL_DEC_1307: u32 = 1306;
pub const Z_UTIL_DEC_1308: u32 = 1307;
pub const Z_UTIL_DEC_1309: u32 = 1308;
pub const Z_UTIL_DEC_1310: u32 = 1309;
pub const Z_UTIL_DEC_1311: u32 = 1310;
pub const Z_UTIL_DEC_1312: u32 = 1311;
pub const Z_UTIL_DEC_1313: u32 = 1312;
pub const Z_UTIL_DEC_1314: u32 = 1313;
pub const Z_UTIL_DEC_1315: u32 = 1314;
pub const Z_UTIL_DEC_1316: u32 = 1315;
pub const Z_UTIL_DEC_1317: u32 = 1316;
pub const Z_UTIL_DEC_1318: u32 = 1317;
pub const Z_UTIL_DEC_1319: u32 = 1318;
pub const Z_UTIL_DEC_1320: u32 = 1319;
pub const Z_UTIL_DEC_1321: u32 = 1320;
pub const Z_UTIL_DEC_1322: u32 = 1321;
pub const Z_UTIL_DEC_1323: u32 = 1322;
pub const Z_UTIL_DEC_1324: u32 = 1323;
pub const Z_UTIL_DEC_1325: u32 = 1324;
pub const Z_UTIL_DEC_1326: u32 = 1325;
pub const Z_UTIL_DEC_1327: u32 = 1326;
pub const Z_UTIL_DEC_1328: u32 = 1327;
pub const Z_UTIL_DEC_1329: u32 = 1328;
pub const Z_UTIL_DEC_1330: u32 = 1329;
pub const Z_UTIL_DEC_1331: u32 = 1330;
pub const Z_UTIL_DEC_1332: u32 = 1331;
pub const Z_UTIL_DEC_1333: u32 = 1332;
pub const Z_UTIL_DEC_1334: u32 = 1333;
pub const Z_UTIL_DEC_1335: u32 = 1334;
pub const Z_UTIL_DEC_1336: u32 = 1335;
pub const Z_UTIL_DEC_1337: u32 = 1336;
pub const Z_UTIL_DEC_1338: u32 = 1337;
pub const Z_UTIL_DEC_1339: u32 = 1338;
pub const Z_UTIL_DEC_1340: u32 = 1339;
pub const Z_UTIL_DEC_1341: u32 = 1340;
pub const Z_UTIL_DEC_1342: u32 = 1341;
pub const Z_UTIL_DEC_1343: u32 = 1342;
pub const Z_UTIL_DEC_1344: u32 = 1343;
pub const Z_UTIL_DEC_1345: u32 = 1344;
pub const Z_UTIL_DEC_1346: u32 = 1345;
pub const Z_UTIL_DEC_1347: u32 = 1346;
pub const Z_UTIL_DEC_1348: u32 = 1347;
pub const Z_UTIL_DEC_1349: u32 = 1348;
pub const Z_UTIL_DEC_1350: u32 = 1349;
pub const Z_UTIL_DEC_1351: u32 = 1350;
pub const Z_UTIL_DEC_1352: u32 = 1351;
pub const Z_UTIL_DEC_1353: u32 = 1352;
pub const Z_UTIL_DEC_1354: u32 = 1353;
pub const Z_UTIL_DEC_1355: u32 = 1354;
pub const Z_UTIL_DEC_1356: u32 = 1355;
pub const Z_UTIL_DEC_1357: u32 = 1356;
pub const Z_UTIL_DEC_1358: u32 = 1357;
pub const Z_UTIL_DEC_1359: u32 = 1358;
pub const Z_UTIL_DEC_1360: u32 = 1359;
pub const Z_UTIL_DEC_1361: u32 = 1360;
pub const Z_UTIL_DEC_1362: u32 = 1361;
pub const Z_UTIL_DEC_1363: u32 = 1362;
pub const Z_UTIL_DEC_1364: u32 = 1363;
pub const Z_UTIL_DEC_1365: u32 = 1364;
pub const Z_UTIL_DEC_1366: u32 = 1365;
pub const Z_UTIL_DEC_1367: u32 = 1366;
pub const Z_UTIL_DEC_1368: u32 = 1367;
pub const Z_UTIL_DEC_1369: u32 = 1368;
pub const Z_UTIL_DEC_1370: u32 = 1369;
pub const Z_UTIL_DEC_1371: u32 = 1370;
pub const Z_UTIL_DEC_1372: u32 = 1371;
pub const Z_UTIL_DEC_1373: u32 = 1372;
pub const Z_UTIL_DEC_1374: u32 = 1373;
pub const Z_UTIL_DEC_1375: u32 = 1374;
pub const Z_UTIL_DEC_1376: u32 = 1375;
pub const Z_UTIL_DEC_1377: u32 = 1376;
pub const Z_UTIL_DEC_1378: u32 = 1377;
pub const Z_UTIL_DEC_1379: u32 = 1378;
pub const Z_UTIL_DEC_1380: u32 = 1379;
pub const Z_UTIL_DEC_1381: u32 = 1380;
pub const Z_UTIL_DEC_1382: u32 = 1381;
pub const Z_UTIL_DEC_1383: u32 = 1382;
pub const Z_UTIL_DEC_1384: u32 = 1383;
pub const Z_UTIL_DEC_1385: u32 = 1384;
pub const Z_UTIL_DEC_1386: u32 = 1385;
pub const Z_UTIL_DEC_1387: u32 = 1386;
pub const Z_UTIL_DEC_1388: u32 = 1387;
pub const Z_UTIL_DEC_1389: u32 = 1388;
pub const Z_UTIL_DEC_1390: u32 = 1389;
pub const Z_UTIL_DEC_1391: u32 = 1390;
pub const Z_UTIL_DEC_1392: u32 = 1391;
pub const Z_UTIL_DEC_1393: u32 = 1392;
pub const Z_UTIL_DEC_1394: u32 = 1393;
pub const Z_UTIL_DEC_1395: u32 = 1394;
pub const Z_UTIL_DEC_1396: u32 = 1395;
pub const Z_UTIL_DEC_1397: u32 = 1396;
pub const Z_UTIL_DEC_1398: u32 = 1397;
pub const Z_UTIL_DEC_1399: u32 = 1398;
pub const Z_UTIL_DEC_1400: u32 = 1399;
pub const Z_UTIL_DEC_1401: u32 = 1400;
pub const Z_UTIL_DEC_1402: u32 = 1401;
pub const Z_UTIL_DEC_1403: u32 = 1402;
pub const Z_UTIL_DEC_1404: u32 = 1403;
pub const Z_UTIL_DEC_1405: u32 = 1404;
pub const Z_UTIL_DEC_1406: u32 = 1405;
pub const Z_UTIL_DEC_1407: u32 = 1406;
pub const Z_UTIL_DEC_1408: u32 = 1407;
pub const Z_UTIL_DEC_1409: u32 = 1408;
pub const Z_UTIL_DEC_1410: u32 = 1409;
pub const Z_UTIL_DEC_1411: u32 = 1410;
pub const Z_UTIL_DEC_1412: u32 = 1411;
pub const Z_UTIL_DEC_1413: u32 = 1412;
pub const Z_UTIL_DEC_1414: u32 = 1413;
pub const Z_UTIL_DEC_1415: u32 = 1414;
pub const Z_UTIL_DEC_1416: u32 = 1415;
pub const Z_UTIL_DEC_1417: u32 = 1416;
pub const Z_UTIL_DEC_1418: u32 = 1417;
pub const Z_UTIL_DEC_1419: u32 = 1418;
pub const Z_UTIL_DEC_1420: u32 = 1419;
pub const Z_UTIL_DEC_1421: u32 = 1420;
pub const Z_UTIL_DEC_1422: u32 = 1421;
pub const Z_UTIL_DEC_1423: u32 = 1422;
pub const Z_UTIL_DEC_1424: u32 = 1423;
pub const Z_UTIL_DEC_1425: u32 = 1424;
pub const Z_UTIL_DEC_1426: u32 = 1425;
pub const Z_UTIL_DEC_1427: u32 = 1426;
pub const Z_UTIL_DEC_1428: u32 = 1427;
pub const Z_UTIL_DEC_1429: u32 = 1428;
pub const Z_UTIL_DEC_1430: u32 = 1429;
pub const Z_UTIL_DEC_1431: u32 = 1430;
pub const Z_UTIL_DEC_1432: u32 = 1431;
pub const Z_UTIL_DEC_1433: u32 = 1432;
pub const Z_UTIL_DEC_1434: u32 = 1433;
pub const Z_UTIL_DEC_1435: u32 = 1434;
pub const Z_UTIL_DEC_1436: u32 = 1435;
pub const Z_UTIL_DEC_1437: u32 = 1436;
pub const Z_UTIL_DEC_1438: u32 = 1437;
pub const Z_UTIL_DEC_1439: u32 = 1438;
pub const Z_UTIL_DEC_1440: u32 = 1439;
pub const Z_UTIL_DEC_1441: u32 = 1440;
pub const Z_UTIL_DEC_1442: u32 = 1441;
pub const Z_UTIL_DEC_1443: u32 = 1442;
pub const Z_UTIL_DEC_1444: u32 = 1443;
pub const Z_UTIL_DEC_1445: u32 = 1444;
pub const Z_UTIL_DEC_1446: u32 = 1445;
pub const Z_UTIL_DEC_1447: u32 = 1446;
pub const Z_UTIL_DEC_1448: u32 = 1447;
pub const Z_UTIL_DEC_1449: u32 = 1448;
pub const Z_UTIL_DEC_1450: u32 = 1449;
pub const Z_UTIL_DEC_1451: u32 = 1450;
pub const Z_UTIL_DEC_1452: u32 = 1451;
pub const Z_UTIL_DEC_1453: u32 = 1452;
pub const Z_UTIL_DEC_1454: u32 = 1453;
pub const Z_UTIL_DEC_1455: u32 = 1454;
pub const Z_UTIL_DEC_1456: u32 = 1455;
pub const Z_UTIL_DEC_1457: u32 = 1456;
pub const Z_UTIL_DEC_1458: u32 = 1457;
pub const Z_UTIL_DEC_1459: u32 = 1458;
pub const Z_UTIL_DEC_1460: u32 = 1459;
pub const Z_UTIL_DEC_1461: u32 = 1460;
pub const Z_UTIL_DEC_1462: u32 = 1461;
pub const Z_UTIL_DEC_1463: u32 = 1462;
pub const Z_UTIL_DEC_1464: u32 = 1463;
pub const Z_UTIL_DEC_1465: u32 = 1464;
pub const Z_UTIL_DEC_1466: u32 = 1465;
pub const Z_UTIL_DEC_1467: u32 = 1466;
pub const Z_UTIL_DEC_1468: u32 = 1467;
pub const Z_UTIL_DEC_1469: u32 = 1468;
pub const Z_UTIL_DEC_1470: u32 = 1469;
pub const Z_UTIL_DEC_1471: u32 = 1470;
pub const Z_UTIL_DEC_1472: u32 = 1471;
pub const Z_UTIL_DEC_1473: u32 = 1472;
pub const Z_UTIL_DEC_1474: u32 = 1473;
pub const Z_UTIL_DEC_1475: u32 = 1474;
pub const Z_UTIL_DEC_1476: u32 = 1475;
pub const Z_UTIL_DEC_1477: u32 = 1476;
pub const Z_UTIL_DEC_1478: u32 = 1477;
pub const Z_UTIL_DEC_1479: u32 = 1478;
pub const Z_UTIL_DEC_1480: u32 = 1479;
pub const Z_UTIL_DEC_1481: u32 = 1480;
pub const Z_UTIL_DEC_1482: u32 = 1481;
pub const Z_UTIL_DEC_1483: u32 = 1482;
pub const Z_UTIL_DEC_1484: u32 = 1483;
pub const Z_UTIL_DEC_1485: u32 = 1484;
pub const Z_UTIL_DEC_1486: u32 = 1485;
pub const Z_UTIL_DEC_1487: u32 = 1486;
pub const Z_UTIL_DEC_1488: u32 = 1487;
pub const Z_UTIL_DEC_1489: u32 = 1488;
pub const Z_UTIL_DEC_1490: u32 = 1489;
pub const Z_UTIL_DEC_1491: u32 = 1490;
pub const Z_UTIL_DEC_1492: u32 = 1491;
pub const Z_UTIL_DEC_1493: u32 = 1492;
pub const Z_UTIL_DEC_1494: u32 = 1493;
pub const Z_UTIL_DEC_1495: u32 = 1494;
pub const Z_UTIL_DEC_1496: u32 = 1495;
pub const Z_UTIL_DEC_1497: u32 = 1496;
pub const Z_UTIL_DEC_1498: u32 = 1497;
pub const Z_UTIL_DEC_1499: u32 = 1498;
pub const Z_UTIL_DEC_1500: u32 = 1499;
pub const Z_UTIL_DEC_1501: u32 = 1500;
pub const Z_UTIL_DEC_1502: u32 = 1501;
pub const Z_UTIL_DEC_1503: u32 = 1502;
pub const Z_UTIL_DEC_1504: u32 = 1503;
pub const Z_UTIL_DEC_1505: u32 = 1504;
pub const Z_UTIL_DEC_1506: u32 = 1505;
pub const Z_UTIL_DEC_1507: u32 = 1506;
pub const Z_UTIL_DEC_1508: u32 = 1507;
pub const Z_UTIL_DEC_1509: u32 = 1508;
pub const Z_UTIL_DEC_1510: u32 = 1509;
pub const Z_UTIL_DEC_1511: u32 = 1510;
pub const Z_UTIL_DEC_1512: u32 = 1511;
pub const Z_UTIL_DEC_1513: u32 = 1512;
pub const Z_UTIL_DEC_1514: u32 = 1513;
pub const Z_UTIL_DEC_1515: u32 = 1514;
pub const Z_UTIL_DEC_1516: u32 = 1515;
pub const Z_UTIL_DEC_1517: u32 = 1516;
pub const Z_UTIL_DEC_1518: u32 = 1517;
pub const Z_UTIL_DEC_1519: u32 = 1518;
pub const Z_UTIL_DEC_1520: u32 = 1519;
pub const Z_UTIL_DEC_1521: u32 = 1520;
pub const Z_UTIL_DEC_1522: u32 = 1521;
pub const Z_UTIL_DEC_1523: u32 = 1522;
pub const Z_UTIL_DEC_1524: u32 = 1523;
pub const Z_UTIL_DEC_1525: u32 = 1524;
pub const Z_UTIL_DEC_1526: u32 = 1525;
pub const Z_UTIL_DEC_1527: u32 = 1526;
pub const Z_UTIL_DEC_1528: u32 = 1527;
pub const Z_UTIL_DEC_1529: u32 = 1528;
pub const Z_UTIL_DEC_1530: u32 = 1529;
pub const Z_UTIL_DEC_1531: u32 = 1530;
pub const Z_UTIL_DEC_1532: u32 = 1531;
pub const Z_UTIL_DEC_1533: u32 = 1532;
pub const Z_UTIL_DEC_1534: u32 = 1533;
pub const Z_UTIL_DEC_1535: u32 = 1534;
pub const Z_UTIL_DEC_1536: u32 = 1535;
pub const Z_UTIL_DEC_1537: u32 = 1536;
pub const Z_UTIL_DEC_1538: u32 = 1537;
pub const Z_UTIL_DEC_1539: u32 = 1538;
pub const Z_UTIL_DEC_1540: u32 = 1539;
pub const Z_UTIL_DEC_1541: u32 = 1540;
pub const Z_UTIL_DEC_1542: u32 = 1541;
pub const Z_UTIL_DEC_1543: u32 = 1542;
pub const Z_UTIL_DEC_1544: u32 = 1543;
pub const Z_UTIL_DEC_1545: u32 = 1544;
pub const Z_UTIL_DEC_1546: u32 = 1545;
pub const Z_UTIL_DEC_1547: u32 = 1546;
pub const Z_UTIL_DEC_1548: u32 = 1547;
pub const Z_UTIL_DEC_1549: u32 = 1548;
pub const Z_UTIL_DEC_1550: u32 = 1549;
pub const Z_UTIL_DEC_1551: u32 = 1550;
pub const Z_UTIL_DEC_1552: u32 = 1551;
pub const Z_UTIL_DEC_1553: u32 = 1552;
pub const Z_UTIL_DEC_1554: u32 = 1553;
pub const Z_UTIL_DEC_1555: u32 = 1554;
pub const Z_UTIL_DEC_1556: u32 = 1555;
pub const Z_UTIL_DEC_1557: u32 = 1556;
pub const Z_UTIL_DEC_1558: u32 = 1557;
pub const Z_UTIL_DEC_1559: u32 = 1558;
pub const Z_UTIL_DEC_1560: u32 = 1559;
pub const Z_UTIL_DEC_1561: u32 = 1560;
pub const Z_UTIL_DEC_1562: u32 = 1561;
pub const Z_UTIL_DEC_1563: u32 = 1562;
pub const Z_UTIL_DEC_1564: u32 = 1563;
pub const Z_UTIL_DEC_1565: u32 = 1564;
pub const Z_UTIL_DEC_1566: u32 = 1565;
pub const Z_UTIL_DEC_1567: u32 = 1566;
pub const Z_UTIL_DEC_1568: u32 = 1567;
pub const Z_UTIL_DEC_1569: u32 = 1568;
pub const Z_UTIL_DEC_1570: u32 = 1569;
pub const Z_UTIL_DEC_1571: u32 = 1570;
pub const Z_UTIL_DEC_1572: u32 = 1571;
pub const Z_UTIL_DEC_1573: u32 = 1572;
pub const Z_UTIL_DEC_1574: u32 = 1573;
pub const Z_UTIL_DEC_1575: u32 = 1574;
pub const Z_UTIL_DEC_1576: u32 = 1575;
pub const Z_UTIL_DEC_1577: u32 = 1576;
pub const Z_UTIL_DEC_1578: u32 = 1577;
pub const Z_UTIL_DEC_1579: u32 = 1578;
pub const Z_UTIL_DEC_1580: u32 = 1579;
pub const Z_UTIL_DEC_1581: u32 = 1580;
pub const Z_UTIL_DEC_1582: u32 = 1581;
pub const Z_UTIL_DEC_1583: u32 = 1582;
pub const Z_UTIL_DEC_1584: u32 = 1583;
pub const Z_UTIL_DEC_1585: u32 = 1584;
pub const Z_UTIL_DEC_1586: u32 = 1585;
pub const Z_UTIL_DEC_1587: u32 = 1586;
pub const Z_UTIL_DEC_1588: u32 = 1587;
pub const Z_UTIL_DEC_1589: u32 = 1588;
pub const Z_UTIL_DEC_1590: u32 = 1589;
pub const Z_UTIL_DEC_1591: u32 = 1590;
pub const Z_UTIL_DEC_1592: u32 = 1591;
pub const Z_UTIL_DEC_1593: u32 = 1592;
pub const Z_UTIL_DEC_1594: u32 = 1593;
pub const Z_UTIL_DEC_1595: u32 = 1594;
pub const Z_UTIL_DEC_1596: u32 = 1595;
pub const Z_UTIL_DEC_1597: u32 = 1596;
pub const Z_UTIL_DEC_1598: u32 = 1597;
pub const Z_UTIL_DEC_1599: u32 = 1598;
pub const Z_UTIL_DEC_1600: u32 = 1599;
pub const Z_UTIL_DEC_1601: u32 = 1600;
pub const Z_UTIL_DEC_1602: u32 = 1601;
pub const Z_UTIL_DEC_1603: u32 = 1602;
pub const Z_UTIL_DEC_1604: u32 = 1603;
pub const Z_UTIL_DEC_1605: u32 = 1604;
pub const Z_UTIL_DEC_1606: u32 = 1605;
pub const Z_UTIL_DEC_1607: u32 = 1606;
pub const Z_UTIL_DEC_1608: u32 = 1607;
pub const Z_UTIL_DEC_1609: u32 = 1608;
pub const Z_UTIL_DEC_1610: u32 = 1609;
pub const Z_UTIL_DEC_1611: u32 = 1610;
pub const Z_UTIL_DEC_1612: u32 = 1611;
pub const Z_UTIL_DEC_1613: u32 = 1612;
pub const Z_UTIL_DEC_1614: u32 = 1613;
pub const Z_UTIL_DEC_1615: u32 = 1614;
pub const Z_UTIL_DEC_1616: u32 = 1615;
pub const Z_UTIL_DEC_1617: u32 = 1616;
pub const Z_UTIL_DEC_1618: u32 = 1617;
pub const Z_UTIL_DEC_1619: u32 = 1618;
pub const Z_UTIL_DEC_1620: u32 = 1619;
pub const Z_UTIL_DEC_1621: u32 = 1620;
pub const Z_UTIL_DEC_1622: u32 = 1621;
pub const Z_UTIL_DEC_1623: u32 = 1622;
pub const Z_UTIL_DEC_1624: u32 = 1623;
pub const Z_UTIL_DEC_1625: u32 = 1624;
pub const Z_UTIL_DEC_1626: u32 = 1625;
pub const Z_UTIL_DEC_1627: u32 = 1626;
pub const Z_UTIL_DEC_1628: u32 = 1627;
pub const Z_UTIL_DEC_1629: u32 = 1628;
pub const Z_UTIL_DEC_1630: u32 = 1629;
pub const Z_UTIL_DEC_1631: u32 = 1630;
pub const Z_UTIL_DEC_1632: u32 = 1631;
pub const Z_UTIL_DEC_1633: u32 = 1632;
pub const Z_UTIL_DEC_1634: u32 = 1633;
pub const Z_UTIL_DEC_1635: u32 = 1634;
pub const Z_UTIL_DEC_1636: u32 = 1635;
pub const Z_UTIL_DEC_1637: u32 = 1636;
pub const Z_UTIL_DEC_1638: u32 = 1637;
pub const Z_UTIL_DEC_1639: u32 = 1638;
pub const Z_UTIL_DEC_1640: u32 = 1639;
pub const Z_UTIL_DEC_1641: u32 = 1640;
pub const Z_UTIL_DEC_1642: u32 = 1641;
pub const Z_UTIL_DEC_1643: u32 = 1642;
pub const Z_UTIL_DEC_1644: u32 = 1643;
pub const Z_UTIL_DEC_1645: u32 = 1644;
pub const Z_UTIL_DEC_1646: u32 = 1645;
pub const Z_UTIL_DEC_1647: u32 = 1646;
pub const Z_UTIL_DEC_1648: u32 = 1647;
pub const Z_UTIL_DEC_1649: u32 = 1648;
pub const Z_UTIL_DEC_1650: u32 = 1649;
pub const Z_UTIL_DEC_1651: u32 = 1650;
pub const Z_UTIL_DEC_1652: u32 = 1651;
pub const Z_UTIL_DEC_1653: u32 = 1652;
pub const Z_UTIL_DEC_1654: u32 = 1653;
pub const Z_UTIL_DEC_1655: u32 = 1654;
pub const Z_UTIL_DEC_1656: u32 = 1655;
pub const Z_UTIL_DEC_1657: u32 = 1656;
pub const Z_UTIL_DEC_1658: u32 = 1657;
pub const Z_UTIL_DEC_1659: u32 = 1658;
pub const Z_UTIL_DEC_1660: u32 = 1659;
pub const Z_UTIL_DEC_1661: u32 = 1660;
pub const Z_UTIL_DEC_1662: u32 = 1661;
pub const Z_UTIL_DEC_1663: u32 = 1662;
pub const Z_UTIL_DEC_1664: u32 = 1663;
pub const Z_UTIL_DEC_1665: u32 = 1664;
pub const Z_UTIL_DEC_1666: u32 = 1665;
pub const Z_UTIL_DEC_1667: u32 = 1666;
pub const Z_UTIL_DEC_1668: u32 = 1667;
pub const Z_UTIL_DEC_1669: u32 = 1668;
pub const Z_UTIL_DEC_1670: u32 = 1669;
pub const Z_UTIL_DEC_1671: u32 = 1670;
pub const Z_UTIL_DEC_1672: u32 = 1671;
pub const Z_UTIL_DEC_1673: u32 = 1672;
pub const Z_UTIL_DEC_1674: u32 = 1673;
pub const Z_UTIL_DEC_1675: u32 = 1674;
pub const Z_UTIL_DEC_1676: u32 = 1675;
pub const Z_UTIL_DEC_1677: u32 = 1676;
pub const Z_UTIL_DEC_1678: u32 = 1677;
pub const Z_UTIL_DEC_1679: u32 = 1678;
pub const Z_UTIL_DEC_1680: u32 = 1679;
pub const Z_UTIL_DEC_1681: u32 = 1680;
pub const Z_UTIL_DEC_1682: u32 = 1681;
pub const Z_UTIL_DEC_1683: u32 = 1682;
pub const Z_UTIL_DEC_1684: u32 = 1683;
pub const Z_UTIL_DEC_1685: u32 = 1684;
pub const Z_UTIL_DEC_1686: u32 = 1685;
pub const Z_UTIL_DEC_1687: u32 = 1686;
pub const Z_UTIL_DEC_1688: u32 = 1687;
pub const Z_UTIL_DEC_1689: u32 = 1688;
pub const Z_UTIL_DEC_1690: u32 = 1689;
pub const Z_UTIL_DEC_1691: u32 = 1690;
pub const Z_UTIL_DEC_1692: u32 = 1691;
pub const Z_UTIL_DEC_1693: u32 = 1692;
pub const Z_UTIL_DEC_1694: u32 = 1693;
pub const Z_UTIL_DEC_1695: u32 = 1694;
pub const Z_UTIL_DEC_1696: u32 = 1695;
pub const Z_UTIL_DEC_1697: u32 = 1696;
pub const Z_UTIL_DEC_1698: u32 = 1697;
pub const Z_UTIL_DEC_1699: u32 = 1698;
pub const Z_UTIL_DEC_1700: u32 = 1699;
pub const Z_UTIL_DEC_1701: u32 = 1700;
pub const Z_UTIL_DEC_1702: u32 = 1701;
pub const Z_UTIL_DEC_1703: u32 = 1702;
pub const Z_UTIL_DEC_1704: u32 = 1703;
pub const Z_UTIL_DEC_1705: u32 = 1704;
pub const Z_UTIL_DEC_1706: u32 = 1705;
pub const Z_UTIL_DEC_1707: u32 = 1706;
pub const Z_UTIL_DEC_1708: u32 = 1707;
pub const Z_UTIL_DEC_1709: u32 = 1708;
pub const Z_UTIL_DEC_1710: u32 = 1709;
pub const Z_UTIL_DEC_1711: u32 = 1710;
pub const Z_UTIL_DEC_1712: u32 = 1711;
pub const Z_UTIL_DEC_1713: u32 = 1712;
pub const Z_UTIL_DEC_1714: u32 = 1713;
pub const Z_UTIL_DEC_1715: u32 = 1714;
pub const Z_UTIL_DEC_1716: u32 = 1715;
pub const Z_UTIL_DEC_1717: u32 = 1716;
pub const Z_UTIL_DEC_1718: u32 = 1717;
pub const Z_UTIL_DEC_1719: u32 = 1718;
pub const Z_UTIL_DEC_1720: u32 = 1719;
pub const Z_UTIL_DEC_1721: u32 = 1720;
pub const Z_UTIL_DEC_1722: u32 = 1721;
pub const Z_UTIL_DEC_1723: u32 = 1722;
pub const Z_UTIL_DEC_1724: u32 = 1723;
pub const Z_UTIL_DEC_1725: u32 = 1724;
pub const Z_UTIL_DEC_1726: u32 = 1725;
pub const Z_UTIL_DEC_1727: u32 = 1726;
pub const Z_UTIL_DEC_1728: u32 = 1727;
pub const Z_UTIL_DEC_1729: u32 = 1728;
pub const Z_UTIL_DEC_1730: u32 = 1729;
pub const Z_UTIL_DEC_1731: u32 = 1730;
pub const Z_UTIL_DEC_1732: u32 = 1731;
pub const Z_UTIL_DEC_1733: u32 = 1732;
pub const Z_UTIL_DEC_1734: u32 = 1733;
pub const Z_UTIL_DEC_1735: u32 = 1734;
pub const Z_UTIL_DEC_1736: u32 = 1735;
pub const Z_UTIL_DEC_1737: u32 = 1736;
pub const Z_UTIL_DEC_1738: u32 = 1737;
pub const Z_UTIL_DEC_1739: u32 = 1738;
pub const Z_UTIL_DEC_1740: u32 = 1739;
pub const Z_UTIL_DEC_1741: u32 = 1740;
pub const Z_UTIL_DEC_1742: u32 = 1741;
pub const Z_UTIL_DEC_1743: u32 = 1742;
pub const Z_UTIL_DEC_1744: u32 = 1743;
pub const Z_UTIL_DEC_1745: u32 = 1744;
pub const Z_UTIL_DEC_1746: u32 = 1745;
pub const Z_UTIL_DEC_1747: u32 = 1746;
pub const Z_UTIL_DEC_1748: u32 = 1747;
pub const Z_UTIL_DEC_1749: u32 = 1748;
pub const Z_UTIL_DEC_1750: u32 = 1749;
pub const Z_UTIL_DEC_1751: u32 = 1750;
pub const Z_UTIL_DEC_1752: u32 = 1751;
pub const Z_UTIL_DEC_1753: u32 = 1752;
pub const Z_UTIL_DEC_1754: u32 = 1753;
pub const Z_UTIL_DEC_1755: u32 = 1754;
pub const Z_UTIL_DEC_1756: u32 = 1755;
pub const Z_UTIL_DEC_1757: u32 = 1756;
pub const Z_UTIL_DEC_1758: u32 = 1757;
pub const Z_UTIL_DEC_1759: u32 = 1758;
pub const Z_UTIL_DEC_1760: u32 = 1759;
pub const Z_UTIL_DEC_1761: u32 = 1760;
pub const Z_UTIL_DEC_1762: u32 = 1761;
pub const Z_UTIL_DEC_1763: u32 = 1762;
pub const Z_UTIL_DEC_1764: u32 = 1763;
pub const Z_UTIL_DEC_1765: u32 = 1764;
pub const Z_UTIL_DEC_1766: u32 = 1765;
pub const Z_UTIL_DEC_1767: u32 = 1766;
pub const Z_UTIL_DEC_1768: u32 = 1767;
pub const Z_UTIL_DEC_1769: u32 = 1768;
pub const Z_UTIL_DEC_1770: u32 = 1769;
pub const Z_UTIL_DEC_1771: u32 = 1770;
pub const Z_UTIL_DEC_1772: u32 = 1771;
pub const Z_UTIL_DEC_1773: u32 = 1772;
pub const Z_UTIL_DEC_1774: u32 = 1773;
pub const Z_UTIL_DEC_1775: u32 = 1774;
pub const Z_UTIL_DEC_1776: u32 = 1775;
pub const Z_UTIL_DEC_1777: u32 = 1776;
pub const Z_UTIL_DEC_1778: u32 = 1777;
pub const Z_UTIL_DEC_1779: u32 = 1778;
pub const Z_UTIL_DEC_1780: u32 = 1779;
pub const Z_UTIL_DEC_1781: u32 = 1780;
pub const Z_UTIL_DEC_1782: u32 = 1781;
pub const Z_UTIL_DEC_1783: u32 = 1782;
pub const Z_UTIL_DEC_1784: u32 = 1783;
pub const Z_UTIL_DEC_1785: u32 = 1784;
pub const Z_UTIL_DEC_1786: u32 = 1785;
pub const Z_UTIL_DEC_1787: u32 = 1786;
pub const Z_UTIL_DEC_1788: u32 = 1787;
pub const Z_UTIL_DEC_1789: u32 = 1788;
pub const Z_UTIL_DEC_1790: u32 = 1789;
pub const Z_UTIL_DEC_1791: u32 = 1790;
pub const Z_UTIL_DEC_1792: u32 = 1791;
pub const Z_UTIL_DEC_1793: u32 = 1792;
pub const Z_UTIL_DEC_1794: u32 = 1793;
pub const Z_UTIL_DEC_1795: u32 = 1794;
pub const Z_UTIL_DEC_1796: u32 = 1795;
pub const Z_UTIL_DEC_1797: u32 = 1796;
pub const Z_UTIL_DEC_1798: u32 = 1797;
pub const Z_UTIL_DEC_1799: u32 = 1798;
pub const Z_UTIL_DEC_1800: u32 = 1799;
pub const Z_UTIL_DEC_1801: u32 = 1800;
pub const Z_UTIL_DEC_1802: u32 = 1801;
pub const Z_UTIL_DEC_1803: u32 = 1802;
pub const Z_UTIL_DEC_1804: u32 = 1803;
pub const Z_UTIL_DEC_1805: u32 = 1804;
pub const Z_UTIL_DEC_1806: u32 = 1805;
pub const Z_UTIL_DEC_1807: u32 = 1806;
pub const Z_UTIL_DEC_1808: u32 = 1807;
pub const Z_UTIL_DEC_1809: u32 = 1808;
pub const Z_UTIL_DEC_1810: u32 = 1809;
pub const Z_UTIL_DEC_1811: u32 = 1810;
pub const Z_UTIL_DEC_1812: u32 = 1811;
pub const Z_UTIL_DEC_1813: u32 = 1812;
pub const Z_UTIL_DEC_1814: u32 = 1813;
pub const Z_UTIL_DEC_1815: u32 = 1814;
pub const Z_UTIL_DEC_1816: u32 = 1815;
pub const Z_UTIL_DEC_1817: u32 = 1816;
pub const Z_UTIL_DEC_1818: u32 = 1817;
pub const Z_UTIL_DEC_1819: u32 = 1818;
pub const Z_UTIL_DEC_1820: u32 = 1819;
pub const Z_UTIL_DEC_1821: u32 = 1820;
pub const Z_UTIL_DEC_1822: u32 = 1821;
pub const Z_UTIL_DEC_1823: u32 = 1822;
pub const Z_UTIL_DEC_1824: u32 = 1823;
pub const Z_UTIL_DEC_1825: u32 = 1824;
pub const Z_UTIL_DEC_1826: u32 = 1825;
pub const Z_UTIL_DEC_1827: u32 = 1826;
pub const Z_UTIL_DEC_1828: u32 = 1827;
pub const Z_UTIL_DEC_1829: u32 = 1828;
pub const Z_UTIL_DEC_1830: u32 = 1829;
pub const Z_UTIL_DEC_1831: u32 = 1830;
pub const Z_UTIL_DEC_1832: u32 = 1831;
pub const Z_UTIL_DEC_1833: u32 = 1832;
pub const Z_UTIL_DEC_1834: u32 = 1833;
pub const Z_UTIL_DEC_1835: u32 = 1834;
pub const Z_UTIL_DEC_1836: u32 = 1835;
pub const Z_UTIL_DEC_1837: u32 = 1836;
pub const Z_UTIL_DEC_1838: u32 = 1837;
pub const Z_UTIL_DEC_1839: u32 = 1838;
pub const Z_UTIL_DEC_1840: u32 = 1839;
pub const Z_UTIL_DEC_1841: u32 = 1840;
pub const Z_UTIL_DEC_1842: u32 = 1841;
pub const Z_UTIL_DEC_1843: u32 = 1842;
pub const Z_UTIL_DEC_1844: u32 = 1843;
pub const Z_UTIL_DEC_1845: u32 = 1844;
pub const Z_UTIL_DEC_1846: u32 = 1845;
pub const Z_UTIL_DEC_1847: u32 = 1846;
pub const Z_UTIL_DEC_1848: u32 = 1847;
pub const Z_UTIL_DEC_1849: u32 = 1848;
pub const Z_UTIL_DEC_1850: u32 = 1849;
pub const Z_UTIL_DEC_1851: u32 = 1850;
pub const Z_UTIL_DEC_1852: u32 = 1851;
pub const Z_UTIL_DEC_1853: u32 = 1852;
pub const Z_UTIL_DEC_1854: u32 = 1853;
pub const Z_UTIL_DEC_1855: u32 = 1854;
pub const Z_UTIL_DEC_1856: u32 = 1855;
pub const Z_UTIL_DEC_1857: u32 = 1856;
pub const Z_UTIL_DEC_1858: u32 = 1857;
pub const Z_UTIL_DEC_1859: u32 = 1858;
pub const Z_UTIL_DEC_1860: u32 = 1859;
pub const Z_UTIL_DEC_1861: u32 = 1860;
pub const Z_UTIL_DEC_1862: u32 = 1861;
pub const Z_UTIL_DEC_1863: u32 = 1862;
pub const Z_UTIL_DEC_1864: u32 = 1863;
pub const Z_UTIL_DEC_1865: u32 = 1864;
pub const Z_UTIL_DEC_1866: u32 = 1865;
pub const Z_UTIL_DEC_1867: u32 = 1866;
pub const Z_UTIL_DEC_1868: u32 = 1867;
pub const Z_UTIL_DEC_1869: u32 = 1868;
pub const Z_UTIL_DEC_1870: u32 = 1869;
pub const Z_UTIL_DEC_1871: u32 = 1870;
pub const Z_UTIL_DEC_1872: u32 = 1871;
pub const Z_UTIL_DEC_1873: u32 = 1872;
pub const Z_UTIL_DEC_1874: u32 = 1873;
pub const Z_UTIL_DEC_1875: u32 = 1874;
pub const Z_UTIL_DEC_1876: u32 = 1875;
pub const Z_UTIL_DEC_1877: u32 = 1876;
pub const Z_UTIL_DEC_1878: u32 = 1877;
pub const Z_UTIL_DEC_1879: u32 = 1878;
pub const Z_UTIL_DEC_1880: u32 = 1879;
pub const Z_UTIL_DEC_1881: u32 = 1880;
pub const Z_UTIL_DEC_1882: u32 = 1881;
pub const Z_UTIL_DEC_1883: u32 = 1882;
pub const Z_UTIL_DEC_1884: u32 = 1883;
pub const Z_UTIL_DEC_1885: u32 = 1884;
pub const Z_UTIL_DEC_1886: u32 = 1885;
pub const Z_UTIL_DEC_1887: u32 = 1886;
pub const Z_UTIL_DEC_1888: u32 = 1887;
pub const Z_UTIL_DEC_1889: u32 = 1888;
pub const Z_UTIL_DEC_1890: u32 = 1889;
pub const Z_UTIL_DEC_1891: u32 = 1890;
pub const Z_UTIL_DEC_1892: u32 = 1891;
pub const Z_UTIL_DEC_1893: u32 = 1892;
pub const Z_UTIL_DEC_1894: u32 = 1893;
pub const Z_UTIL_DEC_1895: u32 = 1894;
pub const Z_UTIL_DEC_1896: u32 = 1895;
pub const Z_UTIL_DEC_1897: u32 = 1896;
pub const Z_UTIL_DEC_1898: u32 = 1897;
pub const Z_UTIL_DEC_1899: u32 = 1898;
pub const Z_UTIL_DEC_1900: u32 = 1899;
pub const Z_UTIL_DEC_1901: u32 = 1900;
pub const Z_UTIL_DEC_1902: u32 = 1901;
pub const Z_UTIL_DEC_1903: u32 = 1902;
pub const Z_UTIL_DEC_1904: u32 = 1903;
pub const Z_UTIL_DEC_1905: u32 = 1904;
pub const Z_UTIL_DEC_1906: u32 = 1905;
pub const Z_UTIL_DEC_1907: u32 = 1906;
pub const Z_UTIL_DEC_1908: u32 = 1907;
pub const Z_UTIL_DEC_1909: u32 = 1908;
pub const Z_UTIL_DEC_1910: u32 = 1909;
pub const Z_UTIL_DEC_1911: u32 = 1910;
pub const Z_UTIL_DEC_1912: u32 = 1911;
pub const Z_UTIL_DEC_1913: u32 = 1912;
pub const Z_UTIL_DEC_1914: u32 = 1913;
pub const Z_UTIL_DEC_1915: u32 = 1914;
pub const Z_UTIL_DEC_1916: u32 = 1915;
pub const Z_UTIL_DEC_1917: u32 = 1916;
pub const Z_UTIL_DEC_1918: u32 = 1917;
pub const Z_UTIL_DEC_1919: u32 = 1918;
pub const Z_UTIL_DEC_1920: u32 = 1919;
pub const Z_UTIL_DEC_1921: u32 = 1920;
pub const Z_UTIL_DEC_1922: u32 = 1921;
pub const Z_UTIL_DEC_1923: u32 = 1922;
pub const Z_UTIL_DEC_1924: u32 = 1923;
pub const Z_UTIL_DEC_1925: u32 = 1924;
pub const Z_UTIL_DEC_1926: u32 = 1925;
pub const Z_UTIL_DEC_1927: u32 = 1926;
pub const Z_UTIL_DEC_1928: u32 = 1927;
pub const Z_UTIL_DEC_1929: u32 = 1928;
pub const Z_UTIL_DEC_1930: u32 = 1929;
pub const Z_UTIL_DEC_1931: u32 = 1930;
pub const Z_UTIL_DEC_1932: u32 = 1931;
pub const Z_UTIL_DEC_1933: u32 = 1932;
pub const Z_UTIL_DEC_1934: u32 = 1933;
pub const Z_UTIL_DEC_1935: u32 = 1934;
pub const Z_UTIL_DEC_1936: u32 = 1935;
pub const Z_UTIL_DEC_1937: u32 = 1936;
pub const Z_UTIL_DEC_1938: u32 = 1937;
pub const Z_UTIL_DEC_1939: u32 = 1938;
pub const Z_UTIL_DEC_1940: u32 = 1939;
pub const Z_UTIL_DEC_1941: u32 = 1940;
pub const Z_UTIL_DEC_1942: u32 = 1941;
pub const Z_UTIL_DEC_1943: u32 = 1942;
pub const Z_UTIL_DEC_1944: u32 = 1943;
pub const Z_UTIL_DEC_1945: u32 = 1944;
pub const Z_UTIL_DEC_1946: u32 = 1945;
pub const Z_UTIL_DEC_1947: u32 = 1946;
pub const Z_UTIL_DEC_1948: u32 = 1947;
pub const Z_UTIL_DEC_1949: u32 = 1948;
pub const Z_UTIL_DEC_1950: u32 = 1949;
pub const Z_UTIL_DEC_1951: u32 = 1950;
pub const Z_UTIL_DEC_1952: u32 = 1951;
pub const Z_UTIL_DEC_1953: u32 = 1952;
pub const Z_UTIL_DEC_1954: u32 = 1953;
pub const Z_UTIL_DEC_1955: u32 = 1954;
pub const Z_UTIL_DEC_1956: u32 = 1955;
pub const Z_UTIL_DEC_1957: u32 = 1956;
pub const Z_UTIL_DEC_1958: u32 = 1957;
pub const Z_UTIL_DEC_1959: u32 = 1958;
pub const Z_UTIL_DEC_1960: u32 = 1959;
pub const Z_UTIL_DEC_1961: u32 = 1960;
pub const Z_UTIL_DEC_1962: u32 = 1961;
pub const Z_UTIL_DEC_1963: u32 = 1962;
pub const Z_UTIL_DEC_1964: u32 = 1963;
pub const Z_UTIL_DEC_1965: u32 = 1964;
pub const Z_UTIL_DEC_1966: u32 = 1965;
pub const Z_UTIL_DEC_1967: u32 = 1966;
pub const Z_UTIL_DEC_1968: u32 = 1967;
pub const Z_UTIL_DEC_1969: u32 = 1968;
pub const Z_UTIL_DEC_1970: u32 = 1969;
pub const Z_UTIL_DEC_1971: u32 = 1970;
pub const Z_UTIL_DEC_1972: u32 = 1971;
pub const Z_UTIL_DEC_1973: u32 = 1972;
pub const Z_UTIL_DEC_1974: u32 = 1973;
pub const Z_UTIL_DEC_1975: u32 = 1974;
pub const Z_UTIL_DEC_1976: u32 = 1975;
pub const Z_UTIL_DEC_1977: u32 = 1976;
pub const Z_UTIL_DEC_1978: u32 = 1977;
pub const Z_UTIL_DEC_1979: u32 = 1978;
pub const Z_UTIL_DEC_1980: u32 = 1979;
pub const Z_UTIL_DEC_1981: u32 = 1980;
pub const Z_UTIL_DEC_1982: u32 = 1981;
pub const Z_UTIL_DEC_1983: u32 = 1982;
pub const Z_UTIL_DEC_1984: u32 = 1983;
pub const Z_UTIL_DEC_1985: u32 = 1984;
pub const Z_UTIL_DEC_1986: u32 = 1985;
pub const Z_UTIL_DEC_1987: u32 = 1986;
pub const Z_UTIL_DEC_1988: u32 = 1987;
pub const Z_UTIL_DEC_1989: u32 = 1988;
pub const Z_UTIL_DEC_1990: u32 = 1989;
pub const Z_UTIL_DEC_1991: u32 = 1990;
pub const Z_UTIL_DEC_1992: u32 = 1991;
pub const Z_UTIL_DEC_1993: u32 = 1992;
pub const Z_UTIL_DEC_1994: u32 = 1993;
pub const Z_UTIL_DEC_1995: u32 = 1994;
pub const Z_UTIL_DEC_1996: u32 = 1995;
pub const Z_UTIL_DEC_1997: u32 = 1996;
pub const Z_UTIL_DEC_1998: u32 = 1997;
pub const Z_UTIL_DEC_1999: u32 = 1998;
pub const Z_UTIL_DEC_2000: u32 = 1999;
pub const Z_UTIL_DEC_2001: u32 = 2000;
pub const Z_UTIL_DEC_2002: u32 = 2001;
pub const Z_UTIL_DEC_2003: u32 = 2002;
pub const Z_UTIL_DEC_2004: u32 = 2003;
pub const Z_UTIL_DEC_2005: u32 = 2004;
pub const Z_UTIL_DEC_2006: u32 = 2005;
pub const Z_UTIL_DEC_2007: u32 = 2006;
pub const Z_UTIL_DEC_2008: u32 = 2007;
pub const Z_UTIL_DEC_2009: u32 = 2008;
pub const Z_UTIL_DEC_2010: u32 = 2009;
pub const Z_UTIL_DEC_2011: u32 = 2010;
pub const Z_UTIL_DEC_2012: u32 = 2011;
pub const Z_UTIL_DEC_2013: u32 = 2012;
pub const Z_UTIL_DEC_2014: u32 = 2013;
pub const Z_UTIL_DEC_2015: u32 = 2014;
pub const Z_UTIL_DEC_2016: u32 = 2015;
pub const Z_UTIL_DEC_2017: u32 = 2016;
pub const Z_UTIL_DEC_2018: u32 = 2017;
pub const Z_UTIL_DEC_2019: u32 = 2018;
pub const Z_UTIL_DEC_2020: u32 = 2019;
pub const Z_UTIL_DEC_2021: u32 = 2020;
pub const Z_UTIL_DEC_2022: u32 = 2021;
pub const Z_UTIL_DEC_2023: u32 = 2022;
pub const Z_UTIL_DEC_2024: u32 = 2023;
pub const Z_UTIL_DEC_2025: u32 = 2024;
pub const Z_UTIL_DEC_2026: u32 = 2025;
pub const Z_UTIL_DEC_2027: u32 = 2026;
pub const Z_UTIL_DEC_2028: u32 = 2027;
pub const Z_UTIL_DEC_2029: u32 = 2028;
pub const Z_UTIL_DEC_2030: u32 = 2029;
pub const Z_UTIL_DEC_2031: u32 = 2030;
pub const Z_UTIL_DEC_2032: u32 = 2031;
pub const Z_UTIL_DEC_2033: u32 = 2032;
pub const Z_UTIL_DEC_2034: u32 = 2033;
pub const Z_UTIL_DEC_2035: u32 = 2034;
pub const Z_UTIL_DEC_2036: u32 = 2035;
pub const Z_UTIL_DEC_2037: u32 = 2036;
pub const Z_UTIL_DEC_2038: u32 = 2037;
pub const Z_UTIL_DEC_2039: u32 = 2038;
pub const Z_UTIL_DEC_2040: u32 = 2039;
pub const Z_UTIL_DEC_2041: u32 = 2040;
pub const Z_UTIL_DEC_2042: u32 = 2041;
pub const Z_UTIL_DEC_2043: u32 = 2042;
pub const Z_UTIL_DEC_2044: u32 = 2043;
pub const Z_UTIL_DEC_2045: u32 = 2044;
pub const Z_UTIL_DEC_2046: u32 = 2045;
pub const Z_UTIL_DEC_2047: u32 = 2046;
pub const Z_UTIL_DEC_2048: u32 = 2047;
pub const Z_UTIL_DEC_2049: u32 = 2048;
pub const Z_UTIL_DEC_2050: u32 = 2049;
pub const Z_UTIL_DEC_2051: u32 = 2050;
pub const Z_UTIL_DEC_2052: u32 = 2051;
pub const Z_UTIL_DEC_2053: u32 = 2052;
pub const Z_UTIL_DEC_2054: u32 = 2053;
pub const Z_UTIL_DEC_2055: u32 = 2054;
pub const Z_UTIL_DEC_2056: u32 = 2055;
pub const Z_UTIL_DEC_2057: u32 = 2056;
pub const Z_UTIL_DEC_2058: u32 = 2057;
pub const Z_UTIL_DEC_2059: u32 = 2058;
pub const Z_UTIL_DEC_2060: u32 = 2059;
pub const Z_UTIL_DEC_2061: u32 = 2060;
pub const Z_UTIL_DEC_2062: u32 = 2061;
pub const Z_UTIL_DEC_2063: u32 = 2062;
pub const Z_UTIL_DEC_2064: u32 = 2063;
pub const Z_UTIL_DEC_2065: u32 = 2064;
pub const Z_UTIL_DEC_2066: u32 = 2065;
pub const Z_UTIL_DEC_2067: u32 = 2066;
pub const Z_UTIL_DEC_2068: u32 = 2067;
pub const Z_UTIL_DEC_2069: u32 = 2068;
pub const Z_UTIL_DEC_2070: u32 = 2069;
pub const Z_UTIL_DEC_2071: u32 = 2070;
pub const Z_UTIL_DEC_2072: u32 = 2071;
pub const Z_UTIL_DEC_2073: u32 = 2072;
pub const Z_UTIL_DEC_2074: u32 = 2073;
pub const Z_UTIL_DEC_2075: u32 = 2074;
pub const Z_UTIL_DEC_2076: u32 = 2075;
pub const Z_UTIL_DEC_2077: u32 = 2076;
pub const Z_UTIL_DEC_2078: u32 = 2077;
pub const Z_UTIL_DEC_2079: u32 = 2078;
pub const Z_UTIL_DEC_2080: u32 = 2079;
pub const Z_UTIL_DEC_2081: u32 = 2080;
pub const Z_UTIL_DEC_2082: u32 = 2081;
pub const Z_UTIL_DEC_2083: u32 = 2082;
pub const Z_UTIL_DEC_2084: u32 = 2083;
pub const Z_UTIL_DEC_2085: u32 = 2084;
pub const Z_UTIL_DEC_2086: u32 = 2085;
pub const Z_UTIL_DEC_2087: u32 = 2086;
pub const Z_UTIL_DEC_2088: u32 = 2087;
pub const Z_UTIL_DEC_2089: u32 = 2088;
pub const Z_UTIL_DEC_2090: u32 = 2089;
pub const Z_UTIL_DEC_2091: u32 = 2090;
pub const Z_UTIL_DEC_2092: u32 = 2091;
pub const Z_UTIL_DEC_2093: u32 = 2092;
pub const Z_UTIL_DEC_2094: u32 = 2093;
pub const Z_UTIL_DEC_2095: u32 = 2094;
pub const Z_UTIL_DEC_2096: u32 = 2095;
pub const Z_UTIL_DEC_2097: u32 = 2096;
pub const Z_UTIL_DEC_2098: u32 = 2097;
pub const Z_UTIL_DEC_2099: u32 = 2098;
pub const Z_UTIL_DEC_2100: u32 = 2099;
pub const Z_UTIL_DEC_2101: u32 = 2100;
pub const Z_UTIL_DEC_2102: u32 = 2101;
pub const Z_UTIL_DEC_2103: u32 = 2102;
pub const Z_UTIL_DEC_2104: u32 = 2103;
pub const Z_UTIL_DEC_2105: u32 = 2104;
pub const Z_UTIL_DEC_2106: u32 = 2105;
pub const Z_UTIL_DEC_2107: u32 = 2106;
pub const Z_UTIL_DEC_2108: u32 = 2107;
pub const Z_UTIL_DEC_2109: u32 = 2108;
pub const Z_UTIL_DEC_2110: u32 = 2109;
pub const Z_UTIL_DEC_2111: u32 = 2110;
pub const Z_UTIL_DEC_2112: u32 = 2111;
pub const Z_UTIL_DEC_2113: u32 = 2112;
pub const Z_UTIL_DEC_2114: u32 = 2113;
pub const Z_UTIL_DEC_2115: u32 = 2114;
pub const Z_UTIL_DEC_2116: u32 = 2115;
pub const Z_UTIL_DEC_2117: u32 = 2116;
pub const Z_UTIL_DEC_2118: u32 = 2117;
pub const Z_UTIL_DEC_2119: u32 = 2118;
pub const Z_UTIL_DEC_2120: u32 = 2119;
pub const Z_UTIL_DEC_2121: u32 = 2120;
pub const Z_UTIL_DEC_2122: u32 = 2121;
pub const Z_UTIL_DEC_2123: u32 = 2122;
pub const Z_UTIL_DEC_2124: u32 = 2123;
pub const Z_UTIL_DEC_2125: u32 = 2124;
pub const Z_UTIL_DEC_2126: u32 = 2125;
pub const Z_UTIL_DEC_2127: u32 = 2126;
pub const Z_UTIL_DEC_2128: u32 = 2127;
pub const Z_UTIL_DEC_2129: u32 = 2128;
pub const Z_UTIL_DEC_2130: u32 = 2129;
pub const Z_UTIL_DEC_2131: u32 = 2130;
pub const Z_UTIL_DEC_2132: u32 = 2131;
pub const Z_UTIL_DEC_2133: u32 = 2132;
pub const Z_UTIL_DEC_2134: u32 = 2133;
pub const Z_UTIL_DEC_2135: u32 = 2134;
pub const Z_UTIL_DEC_2136: u32 = 2135;
pub const Z_UTIL_DEC_2137: u32 = 2136;
pub const Z_UTIL_DEC_2138: u32 = 2137;
pub const Z_UTIL_DEC_2139: u32 = 2138;
pub const Z_UTIL_DEC_2140: u32 = 2139;
pub const Z_UTIL_DEC_2141: u32 = 2140;
pub const Z_UTIL_DEC_2142: u32 = 2141;
pub const Z_UTIL_DEC_2143: u32 = 2142;
pub const Z_UTIL_DEC_2144: u32 = 2143;
pub const Z_UTIL_DEC_2145: u32 = 2144;
pub const Z_UTIL_DEC_2146: u32 = 2145;
pub const Z_UTIL_DEC_2147: u32 = 2146;
pub const Z_UTIL_DEC_2148: u32 = 2147;
pub const Z_UTIL_DEC_2149: u32 = 2148;
pub const Z_UTIL_DEC_2150: u32 = 2149;
pub const Z_UTIL_DEC_2151: u32 = 2150;
pub const Z_UTIL_DEC_2152: u32 = 2151;
pub const Z_UTIL_DEC_2153: u32 = 2152;
pub const Z_UTIL_DEC_2154: u32 = 2153;
pub const Z_UTIL_DEC_2155: u32 = 2154;
pub const Z_UTIL_DEC_2156: u32 = 2155;
pub const Z_UTIL_DEC_2157: u32 = 2156;
pub const Z_UTIL_DEC_2158: u32 = 2157;
pub const Z_UTIL_DEC_2159: u32 = 2158;
pub const Z_UTIL_DEC_2160: u32 = 2159;
pub const Z_UTIL_DEC_2161: u32 = 2160;
pub const Z_UTIL_DEC_2162: u32 = 2161;
pub const Z_UTIL_DEC_2163: u32 = 2162;
pub const Z_UTIL_DEC_2164: u32 = 2163;
pub const Z_UTIL_DEC_2165: u32 = 2164;
pub const Z_UTIL_DEC_2166: u32 = 2165;
pub const Z_UTIL_DEC_2167: u32 = 2166;
pub const Z_UTIL_DEC_2168: u32 = 2167;
pub const Z_UTIL_DEC_2169: u32 = 2168;
pub const Z_UTIL_DEC_2170: u32 = 2169;
pub const Z_UTIL_DEC_2171: u32 = 2170;
pub const Z_UTIL_DEC_2172: u32 = 2171;
pub const Z_UTIL_DEC_2173: u32 = 2172;
pub const Z_UTIL_DEC_2174: u32 = 2173;
pub const Z_UTIL_DEC_2175: u32 = 2174;
pub const Z_UTIL_DEC_2176: u32 = 2175;
pub const Z_UTIL_DEC_2177: u32 = 2176;
pub const Z_UTIL_DEC_2178: u32 = 2177;
pub const Z_UTIL_DEC_2179: u32 = 2178;
pub const Z_UTIL_DEC_2180: u32 = 2179;
pub const Z_UTIL_DEC_2181: u32 = 2180;
pub const Z_UTIL_DEC_2182: u32 = 2181;
pub const Z_UTIL_DEC_2183: u32 = 2182;
pub const Z_UTIL_DEC_2184: u32 = 2183;
pub const Z_UTIL_DEC_2185: u32 = 2184;
pub const Z_UTIL_DEC_2186: u32 = 2185;
pub const Z_UTIL_DEC_2187: u32 = 2186;
pub const Z_UTIL_DEC_2188: u32 = 2187;
pub const Z_UTIL_DEC_2189: u32 = 2188;
pub const Z_UTIL_DEC_2190: u32 = 2189;
pub const Z_UTIL_DEC_2191: u32 = 2190;
pub const Z_UTIL_DEC_2192: u32 = 2191;
pub const Z_UTIL_DEC_2193: u32 = 2192;
pub const Z_UTIL_DEC_2194: u32 = 2193;
pub const Z_UTIL_DEC_2195: u32 = 2194;
pub const Z_UTIL_DEC_2196: u32 = 2195;
pub const Z_UTIL_DEC_2197: u32 = 2196;
pub const Z_UTIL_DEC_2198: u32 = 2197;
pub const Z_UTIL_DEC_2199: u32 = 2198;
pub const Z_UTIL_DEC_2200: u32 = 2199;
pub const Z_UTIL_DEC_2201: u32 = 2200;
pub const Z_UTIL_DEC_2202: u32 = 2201;
pub const Z_UTIL_DEC_2203: u32 = 2202;
pub const Z_UTIL_DEC_2204: u32 = 2203;
pub const Z_UTIL_DEC_2205: u32 = 2204;
pub const Z_UTIL_DEC_2206: u32 = 2205;
pub const Z_UTIL_DEC_2207: u32 = 2206;
pub const Z_UTIL_DEC_2208: u32 = 2207;
pub const Z_UTIL_DEC_2209: u32 = 2208;
pub const Z_UTIL_DEC_2210: u32 = 2209;
pub const Z_UTIL_DEC_2211: u32 = 2210;
pub const Z_UTIL_DEC_2212: u32 = 2211;
pub const Z_UTIL_DEC_2213: u32 = 2212;
pub const Z_UTIL_DEC_2214: u32 = 2213;
pub const Z_UTIL_DEC_2215: u32 = 2214;
pub const Z_UTIL_DEC_2216: u32 = 2215;
pub const Z_UTIL_DEC_2217: u32 = 2216;
pub const Z_UTIL_DEC_2218: u32 = 2217;
pub const Z_UTIL_DEC_2219: u32 = 2218;
pub const Z_UTIL_DEC_2220: u32 = 2219;
pub const Z_UTIL_DEC_2221: u32 = 2220;
pub const Z_UTIL_DEC_2222: u32 = 2221;
pub const Z_UTIL_DEC_2223: u32 = 2222;
pub const Z_UTIL_DEC_2224: u32 = 2223;
pub const Z_UTIL_DEC_2225: u32 = 2224;
pub const Z_UTIL_DEC_2226: u32 = 2225;
pub const Z_UTIL_DEC_2227: u32 = 2226;
pub const Z_UTIL_DEC_2228: u32 = 2227;
pub const Z_UTIL_DEC_2229: u32 = 2228;
pub const Z_UTIL_DEC_2230: u32 = 2229;
pub const Z_UTIL_DEC_2231: u32 = 2230;
pub const Z_UTIL_DEC_2232: u32 = 2231;
pub const Z_UTIL_DEC_2233: u32 = 2232;
pub const Z_UTIL_DEC_2234: u32 = 2233;
pub const Z_UTIL_DEC_2235: u32 = 2234;
pub const Z_UTIL_DEC_2236: u32 = 2235;
pub const Z_UTIL_DEC_2237: u32 = 2236;
pub const Z_UTIL_DEC_2238: u32 = 2237;
pub const Z_UTIL_DEC_2239: u32 = 2238;
pub const Z_UTIL_DEC_2240: u32 = 2239;
pub const Z_UTIL_DEC_2241: u32 = 2240;
pub const Z_UTIL_DEC_2242: u32 = 2241;
pub const Z_UTIL_DEC_2243: u32 = 2242;
pub const Z_UTIL_DEC_2244: u32 = 2243;
pub const Z_UTIL_DEC_2245: u32 = 2244;
pub const Z_UTIL_DEC_2246: u32 = 2245;
pub const Z_UTIL_DEC_2247: u32 = 2246;
pub const Z_UTIL_DEC_2248: u32 = 2247;
pub const Z_UTIL_DEC_2249: u32 = 2248;
pub const Z_UTIL_DEC_2250: u32 = 2249;
pub const Z_UTIL_DEC_2251: u32 = 2250;
pub const Z_UTIL_DEC_2252: u32 = 2251;
pub const Z_UTIL_DEC_2253: u32 = 2252;
pub const Z_UTIL_DEC_2254: u32 = 2253;
pub const Z_UTIL_DEC_2255: u32 = 2254;
pub const Z_UTIL_DEC_2256: u32 = 2255;
pub const Z_UTIL_DEC_2257: u32 = 2256;
pub const Z_UTIL_DEC_2258: u32 = 2257;
pub const Z_UTIL_DEC_2259: u32 = 2258;
pub const Z_UTIL_DEC_2260: u32 = 2259;
pub const Z_UTIL_DEC_2261: u32 = 2260;
pub const Z_UTIL_DEC_2262: u32 = 2261;
pub const Z_UTIL_DEC_2263: u32 = 2262;
pub const Z_UTIL_DEC_2264: u32 = 2263;
pub const Z_UTIL_DEC_2265: u32 = 2264;
pub const Z_UTIL_DEC_2266: u32 = 2265;
pub const Z_UTIL_DEC_2267: u32 = 2266;
pub const Z_UTIL_DEC_2268: u32 = 2267;
pub const Z_UTIL_DEC_2269: u32 = 2268;
pub const Z_UTIL_DEC_2270: u32 = 2269;
pub const Z_UTIL_DEC_2271: u32 = 2270;
pub const Z_UTIL_DEC_2272: u32 = 2271;
pub const Z_UTIL_DEC_2273: u32 = 2272;
pub const Z_UTIL_DEC_2274: u32 = 2273;
pub const Z_UTIL_DEC_2275: u32 = 2274;
pub const Z_UTIL_DEC_2276: u32 = 2275;
pub const Z_UTIL_DEC_2277: u32 = 2276;
pub const Z_UTIL_DEC_2278: u32 = 2277;
pub const Z_UTIL_DEC_2279: u32 = 2278;
pub const Z_UTIL_DEC_2280: u32 = 2279;
pub const Z_UTIL_DEC_2281: u32 = 2280;
pub const Z_UTIL_DEC_2282: u32 = 2281;
pub const Z_UTIL_DEC_2283: u32 = 2282;
pub const Z_UTIL_DEC_2284: u32 = 2283;
pub const Z_UTIL_DEC_2285: u32 = 2284;
pub const Z_UTIL_DEC_2286: u32 = 2285;
pub const Z_UTIL_DEC_2287: u32 = 2286;
pub const Z_UTIL_DEC_2288: u32 = 2287;
pub const Z_UTIL_DEC_2289: u32 = 2288;
pub const Z_UTIL_DEC_2290: u32 = 2289;
pub const Z_UTIL_DEC_2291: u32 = 2290;
pub const Z_UTIL_DEC_2292: u32 = 2291;
pub const Z_UTIL_DEC_2293: u32 = 2292;
pub const Z_UTIL_DEC_2294: u32 = 2293;
pub const Z_UTIL_DEC_2295: u32 = 2294;
pub const Z_UTIL_DEC_2296: u32 = 2295;
pub const Z_UTIL_DEC_2297: u32 = 2296;
pub const Z_UTIL_DEC_2298: u32 = 2297;
pub const Z_UTIL_DEC_2299: u32 = 2298;
pub const Z_UTIL_DEC_2300: u32 = 2299;
pub const Z_UTIL_DEC_2301: u32 = 2300;
pub const Z_UTIL_DEC_2302: u32 = 2301;
pub const Z_UTIL_DEC_2303: u32 = 2302;
pub const Z_UTIL_DEC_2304: u32 = 2303;
pub const Z_UTIL_DEC_2305: u32 = 2304;
pub const Z_UTIL_DEC_2306: u32 = 2305;
pub const Z_UTIL_DEC_2307: u32 = 2306;
pub const Z_UTIL_DEC_2308: u32 = 2307;
pub const Z_UTIL_DEC_2309: u32 = 2308;
pub const Z_UTIL_DEC_2310: u32 = 2309;
pub const Z_UTIL_DEC_2311: u32 = 2310;
pub const Z_UTIL_DEC_2312: u32 = 2311;
pub const Z_UTIL_DEC_2313: u32 = 2312;
pub const Z_UTIL_DEC_2314: u32 = 2313;
pub const Z_UTIL_DEC_2315: u32 = 2314;
pub const Z_UTIL_DEC_2316: u32 = 2315;
pub const Z_UTIL_DEC_2317: u32 = 2316;
pub const Z_UTIL_DEC_2318: u32 = 2317;
pub const Z_UTIL_DEC_2319: u32 = 2318;
pub const Z_UTIL_DEC_2320: u32 = 2319;
pub const Z_UTIL_DEC_2321: u32 = 2320;
pub const Z_UTIL_DEC_2322: u32 = 2321;
pub const Z_UTIL_DEC_2323: u32 = 2322;
pub const Z_UTIL_DEC_2324: u32 = 2323;
pub const Z_UTIL_DEC_2325: u32 = 2324;
pub const Z_UTIL_DEC_2326: u32 = 2325;
pub const Z_UTIL_DEC_2327: u32 = 2326;
pub const Z_UTIL_DEC_2328: u32 = 2327;
pub const Z_UTIL_DEC_2329: u32 = 2328;
pub const Z_UTIL_DEC_2330: u32 = 2329;
pub const Z_UTIL_DEC_2331: u32 = 2330;
pub const Z_UTIL_DEC_2332: u32 = 2331;
pub const Z_UTIL_DEC_2333: u32 = 2332;
pub const Z_UTIL_DEC_2334: u32 = 2333;
pub const Z_UTIL_DEC_2335: u32 = 2334;
pub const Z_UTIL_DEC_2336: u32 = 2335;
pub const Z_UTIL_DEC_2337: u32 = 2336;
pub const Z_UTIL_DEC_2338: u32 = 2337;
pub const Z_UTIL_DEC_2339: u32 = 2338;
pub const Z_UTIL_DEC_2340: u32 = 2339;
pub const Z_UTIL_DEC_2341: u32 = 2340;
pub const Z_UTIL_DEC_2342: u32 = 2341;
pub const Z_UTIL_DEC_2343: u32 = 2342;
pub const Z_UTIL_DEC_2344: u32 = 2343;
pub const Z_UTIL_DEC_2345: u32 = 2344;
pub const Z_UTIL_DEC_2346: u32 = 2345;
pub const Z_UTIL_DEC_2347: u32 = 2346;
pub const Z_UTIL_DEC_2348: u32 = 2347;
pub const Z_UTIL_DEC_2349: u32 = 2348;
pub const Z_UTIL_DEC_2350: u32 = 2349;
pub const Z_UTIL_DEC_2351: u32 = 2350;
pub const Z_UTIL_DEC_2352: u32 = 2351;
pub const Z_UTIL_DEC_2353: u32 = 2352;
pub const Z_UTIL_DEC_2354: u32 = 2353;
pub const Z_UTIL_DEC_2355: u32 = 2354;
pub const Z_UTIL_DEC_2356: u32 = 2355;
pub const Z_UTIL_DEC_2357: u32 = 2356;
pub const Z_UTIL_DEC_2358: u32 = 2357;
pub const Z_UTIL_DEC_2359: u32 = 2358;
pub const Z_UTIL_DEC_2360: u32 = 2359;
pub const Z_UTIL_DEC_2361: u32 = 2360;
pub const Z_UTIL_DEC_2362: u32 = 2361;
pub const Z_UTIL_DEC_2363: u32 = 2362;
pub const Z_UTIL_DEC_2364: u32 = 2363;
pub const Z_UTIL_DEC_2365: u32 = 2364;
pub const Z_UTIL_DEC_2366: u32 = 2365;
pub const Z_UTIL_DEC_2367: u32 = 2366;
pub const Z_UTIL_DEC_2368: u32 = 2367;
pub const Z_UTIL_DEC_2369: u32 = 2368;
pub const Z_UTIL_DEC_2370: u32 = 2369;
pub const Z_UTIL_DEC_2371: u32 = 2370;
pub const Z_UTIL_DEC_2372: u32 = 2371;
pub const Z_UTIL_DEC_2373: u32 = 2372;
pub const Z_UTIL_DEC_2374: u32 = 2373;
pub const Z_UTIL_DEC_2375: u32 = 2374;
pub const Z_UTIL_DEC_2376: u32 = 2375;
pub const Z_UTIL_DEC_2377: u32 = 2376;
pub const Z_UTIL_DEC_2378: u32 = 2377;
pub const Z_UTIL_DEC_2379: u32 = 2378;
pub const Z_UTIL_DEC_2380: u32 = 2379;
pub const Z_UTIL_DEC_2381: u32 = 2380;
pub const Z_UTIL_DEC_2382: u32 = 2381;
pub const Z_UTIL_DEC_2383: u32 = 2382;
pub const Z_UTIL_DEC_2384: u32 = 2383;
pub const Z_UTIL_DEC_2385: u32 = 2384;
pub const Z_UTIL_DEC_2386: u32 = 2385;
pub const Z_UTIL_DEC_2387: u32 = 2386;
pub const Z_UTIL_DEC_2388: u32 = 2387;
pub const Z_UTIL_DEC_2389: u32 = 2388;
pub const Z_UTIL_DEC_2390: u32 = 2389;
pub const Z_UTIL_DEC_2391: u32 = 2390;
pub const Z_UTIL_DEC_2392: u32 = 2391;
pub const Z_UTIL_DEC_2393: u32 = 2392;
pub const Z_UTIL_DEC_2394: u32 = 2393;
pub const Z_UTIL_DEC_2395: u32 = 2394;
pub const Z_UTIL_DEC_2396: u32 = 2395;
pub const Z_UTIL_DEC_2397: u32 = 2396;
pub const Z_UTIL_DEC_2398: u32 = 2397;
pub const Z_UTIL_DEC_2399: u32 = 2398;
pub const Z_UTIL_DEC_2400: u32 = 2399;
pub const Z_UTIL_DEC_2401: u32 = 2400;
pub const Z_UTIL_DEC_2402: u32 = 2401;
pub const Z_UTIL_DEC_2403: u32 = 2402;
pub const Z_UTIL_DEC_2404: u32 = 2403;
pub const Z_UTIL_DEC_2405: u32 = 2404;
pub const Z_UTIL_DEC_2406: u32 = 2405;
pub const Z_UTIL_DEC_2407: u32 = 2406;
pub const Z_UTIL_DEC_2408: u32 = 2407;
pub const Z_UTIL_DEC_2409: u32 = 2408;
pub const Z_UTIL_DEC_2410: u32 = 2409;
pub const Z_UTIL_DEC_2411: u32 = 2410;
pub const Z_UTIL_DEC_2412: u32 = 2411;
pub const Z_UTIL_DEC_2413: u32 = 2412;
pub const Z_UTIL_DEC_2414: u32 = 2413;
pub const Z_UTIL_DEC_2415: u32 = 2414;
pub const Z_UTIL_DEC_2416: u32 = 2415;
pub const Z_UTIL_DEC_2417: u32 = 2416;
pub const Z_UTIL_DEC_2418: u32 = 2417;
pub const Z_UTIL_DEC_2419: u32 = 2418;
pub const Z_UTIL_DEC_2420: u32 = 2419;
pub const Z_UTIL_DEC_2421: u32 = 2420;
pub const Z_UTIL_DEC_2422: u32 = 2421;
pub const Z_UTIL_DEC_2423: u32 = 2422;
pub const Z_UTIL_DEC_2424: u32 = 2423;
pub const Z_UTIL_DEC_2425: u32 = 2424;
pub const Z_UTIL_DEC_2426: u32 = 2425;
pub const Z_UTIL_DEC_2427: u32 = 2426;
pub const Z_UTIL_DEC_2428: u32 = 2427;
pub const Z_UTIL_DEC_2429: u32 = 2428;
pub const Z_UTIL_DEC_2430: u32 = 2429;
pub const Z_UTIL_DEC_2431: u32 = 2430;
pub const Z_UTIL_DEC_2432: u32 = 2431;
pub const Z_UTIL_DEC_2433: u32 = 2432;
pub const Z_UTIL_DEC_2434: u32 = 2433;
pub const Z_UTIL_DEC_2435: u32 = 2434;
pub const Z_UTIL_DEC_2436: u32 = 2435;
pub const Z_UTIL_DEC_2437: u32 = 2436;
pub const Z_UTIL_DEC_2438: u32 = 2437;
pub const Z_UTIL_DEC_2439: u32 = 2438;
pub const Z_UTIL_DEC_2440: u32 = 2439;
pub const Z_UTIL_DEC_2441: u32 = 2440;
pub const Z_UTIL_DEC_2442: u32 = 2441;
pub const Z_UTIL_DEC_2443: u32 = 2442;
pub const Z_UTIL_DEC_2444: u32 = 2443;
pub const Z_UTIL_DEC_2445: u32 = 2444;
pub const Z_UTIL_DEC_2446: u32 = 2445;
pub const Z_UTIL_DEC_2447: u32 = 2446;
pub const Z_UTIL_DEC_2448: u32 = 2447;
pub const Z_UTIL_DEC_2449: u32 = 2448;
pub const Z_UTIL_DEC_2450: u32 = 2449;
pub const Z_UTIL_DEC_2451: u32 = 2450;
pub const Z_UTIL_DEC_2452: u32 = 2451;
pub const Z_UTIL_DEC_2453: u32 = 2452;
pub const Z_UTIL_DEC_2454: u32 = 2453;
pub const Z_UTIL_DEC_2455: u32 = 2454;
pub const Z_UTIL_DEC_2456: u32 = 2455;
pub const Z_UTIL_DEC_2457: u32 = 2456;
pub const Z_UTIL_DEC_2458: u32 = 2457;
pub const Z_UTIL_DEC_2459: u32 = 2458;
pub const Z_UTIL_DEC_2460: u32 = 2459;
pub const Z_UTIL_DEC_2461: u32 = 2460;
pub const Z_UTIL_DEC_2462: u32 = 2461;
pub const Z_UTIL_DEC_2463: u32 = 2462;
pub const Z_UTIL_DEC_2464: u32 = 2463;
pub const Z_UTIL_DEC_2465: u32 = 2464;
pub const Z_UTIL_DEC_2466: u32 = 2465;
pub const Z_UTIL_DEC_2467: u32 = 2466;
pub const Z_UTIL_DEC_2468: u32 = 2467;
pub const Z_UTIL_DEC_2469: u32 = 2468;
pub const Z_UTIL_DEC_2470: u32 = 2469;
pub const Z_UTIL_DEC_2471: u32 = 2470;
pub const Z_UTIL_DEC_2472: u32 = 2471;
pub const Z_UTIL_DEC_2473: u32 = 2472;
pub const Z_UTIL_DEC_2474: u32 = 2473;
pub const Z_UTIL_DEC_2475: u32 = 2474;
pub const Z_UTIL_DEC_2476: u32 = 2475;
pub const Z_UTIL_DEC_2477: u32 = 2476;
pub const Z_UTIL_DEC_2478: u32 = 2477;
pub const Z_UTIL_DEC_2479: u32 = 2478;
pub const Z_UTIL_DEC_2480: u32 = 2479;
pub const Z_UTIL_DEC_2481: u32 = 2480;
pub const Z_UTIL_DEC_2482: u32 = 2481;
pub const Z_UTIL_DEC_2483: u32 = 2482;
pub const Z_UTIL_DEC_2484: u32 = 2483;
pub const Z_UTIL_DEC_2485: u32 = 2484;
pub const Z_UTIL_DEC_2486: u32 = 2485;
pub const Z_UTIL_DEC_2487: u32 = 2486;
pub const Z_UTIL_DEC_2488: u32 = 2487;
pub const Z_UTIL_DEC_2489: u32 = 2488;
pub const Z_UTIL_DEC_2490: u32 = 2489;
pub const Z_UTIL_DEC_2491: u32 = 2490;
pub const Z_UTIL_DEC_2492: u32 = 2491;
pub const Z_UTIL_DEC_2493: u32 = 2492;
pub const Z_UTIL_DEC_2494: u32 = 2493;
pub const Z_UTIL_DEC_2495: u32 = 2494;
pub const Z_UTIL_DEC_2496: u32 = 2495;
pub const Z_UTIL_DEC_2497: u32 = 2496;
pub const Z_UTIL_DEC_2498: u32 = 2497;
pub const Z_UTIL_DEC_2499: u32 = 2498;
pub const Z_UTIL_DEC_2500: u32 = 2499;
pub const Z_UTIL_DEC_2501: u32 = 2500;
pub const Z_UTIL_DEC_2502: u32 = 2501;
pub const Z_UTIL_DEC_2503: u32 = 2502;
pub const Z_UTIL_DEC_2504: u32 = 2503;
pub const Z_UTIL_DEC_2505: u32 = 2504;
pub const Z_UTIL_DEC_2506: u32 = 2505;
pub const Z_UTIL_DEC_2507: u32 = 2506;
pub const Z_UTIL_DEC_2508: u32 = 2507;
pub const Z_UTIL_DEC_2509: u32 = 2508;
pub const Z_UTIL_DEC_2510: u32 = 2509;
pub const Z_UTIL_DEC_2511: u32 = 2510;
pub const Z_UTIL_DEC_2512: u32 = 2511;
pub const Z_UTIL_DEC_2513: u32 = 2512;
pub const Z_UTIL_DEC_2514: u32 = 2513;
pub const Z_UTIL_DEC_2515: u32 = 2514;
pub const Z_UTIL_DEC_2516: u32 = 2515;
pub const Z_UTIL_DEC_2517: u32 = 2516;
pub const Z_UTIL_DEC_2518: u32 = 2517;
pub const Z_UTIL_DEC_2519: u32 = 2518;
pub const Z_UTIL_DEC_2520: u32 = 2519;
pub const Z_UTIL_DEC_2521: u32 = 2520;
pub const Z_UTIL_DEC_2522: u32 = 2521;
pub const Z_UTIL_DEC_2523: u32 = 2522;
pub const Z_UTIL_DEC_2524: u32 = 2523;
pub const Z_UTIL_DEC_2525: u32 = 2524;
pub const Z_UTIL_DEC_2526: u32 = 2525;
pub const Z_UTIL_DEC_2527: u32 = 2526;
pub const Z_UTIL_DEC_2528: u32 = 2527;
pub const Z_UTIL_DEC_2529: u32 = 2528;
pub const Z_UTIL_DEC_2530: u32 = 2529;
pub const Z_UTIL_DEC_2531: u32 = 2530;
pub const Z_UTIL_DEC_2532: u32 = 2531;
pub const Z_UTIL_DEC_2533: u32 = 2532;
pub const Z_UTIL_DEC_2534: u32 = 2533;
pub const Z_UTIL_DEC_2535: u32 = 2534;
pub const Z_UTIL_DEC_2536: u32 = 2535;
pub const Z_UTIL_DEC_2537: u32 = 2536;
pub const Z_UTIL_DEC_2538: u32 = 2537;
pub const Z_UTIL_DEC_2539: u32 = 2538;
pub const Z_UTIL_DEC_2540: u32 = 2539;
pub const Z_UTIL_DEC_2541: u32 = 2540;
pub const Z_UTIL_DEC_2542: u32 = 2541;
pub const Z_UTIL_DEC_2543: u32 = 2542;
pub const Z_UTIL_DEC_2544: u32 = 2543;
pub const Z_UTIL_DEC_2545: u32 = 2544;
pub const Z_UTIL_DEC_2546: u32 = 2545;
pub const Z_UTIL_DEC_2547: u32 = 2546;
pub const Z_UTIL_DEC_2548: u32 = 2547;
pub const Z_UTIL_DEC_2549: u32 = 2548;
pub const Z_UTIL_DEC_2550: u32 = 2549;
pub const Z_UTIL_DEC_2551: u32 = 2550;
pub const Z_UTIL_DEC_2552: u32 = 2551;
pub const Z_UTIL_DEC_2553: u32 = 2552;
pub const Z_UTIL_DEC_2554: u32 = 2553;
pub const Z_UTIL_DEC_2555: u32 = 2554;
pub const Z_UTIL_DEC_2556: u32 = 2555;
pub const Z_UTIL_DEC_2557: u32 = 2556;
pub const Z_UTIL_DEC_2558: u32 = 2557;
pub const Z_UTIL_DEC_2559: u32 = 2558;
pub const Z_UTIL_DEC_2560: u32 = 2559;
pub const Z_UTIL_DEC_2561: u32 = 2560;
pub const Z_UTIL_DEC_2562: u32 = 2561;
pub const Z_UTIL_DEC_2563: u32 = 2562;
pub const Z_UTIL_DEC_2564: u32 = 2563;
pub const Z_UTIL_DEC_2565: u32 = 2564;
pub const Z_UTIL_DEC_2566: u32 = 2565;
pub const Z_UTIL_DEC_2567: u32 = 2566;
pub const Z_UTIL_DEC_2568: u32 = 2567;
pub const Z_UTIL_DEC_2569: u32 = 2568;
pub const Z_UTIL_DEC_2570: u32 = 2569;
pub const Z_UTIL_DEC_2571: u32 = 2570;
pub const Z_UTIL_DEC_2572: u32 = 2571;
pub const Z_UTIL_DEC_2573: u32 = 2572;
pub const Z_UTIL_DEC_2574: u32 = 2573;
pub const Z_UTIL_DEC_2575: u32 = 2574;
pub const Z_UTIL_DEC_2576: u32 = 2575;
pub const Z_UTIL_DEC_2577: u32 = 2576;
pub const Z_UTIL_DEC_2578: u32 = 2577;
pub const Z_UTIL_DEC_2579: u32 = 2578;
pub const Z_UTIL_DEC_2580: u32 = 2579;
pub const Z_UTIL_DEC_2581: u32 = 2580;
pub const Z_UTIL_DEC_2582: u32 = 2581;
pub const Z_UTIL_DEC_2583: u32 = 2582;
pub const Z_UTIL_DEC_2584: u32 = 2583;
pub const Z_UTIL_DEC_2585: u32 = 2584;
pub const Z_UTIL_DEC_2586: u32 = 2585;
pub const Z_UTIL_DEC_2587: u32 = 2586;
pub const Z_UTIL_DEC_2588: u32 = 2587;
pub const Z_UTIL_DEC_2589: u32 = 2588;
pub const Z_UTIL_DEC_2590: u32 = 2589;
pub const Z_UTIL_DEC_2591: u32 = 2590;
pub const Z_UTIL_DEC_2592: u32 = 2591;
pub const Z_UTIL_DEC_2593: u32 = 2592;
pub const Z_UTIL_DEC_2594: u32 = 2593;
pub const Z_UTIL_DEC_2595: u32 = 2594;
pub const Z_UTIL_DEC_2596: u32 = 2595;
pub const Z_UTIL_DEC_2597: u32 = 2596;
pub const Z_UTIL_DEC_2598: u32 = 2597;
pub const Z_UTIL_DEC_2599: u32 = 2598;
pub const Z_UTIL_DEC_2600: u32 = 2599;
pub const Z_UTIL_DEC_2601: u32 = 2600;
pub const Z_UTIL_DEC_2602: u32 = 2601;
pub const Z_UTIL_DEC_2603: u32 = 2602;
pub const Z_UTIL_DEC_2604: u32 = 2603;
pub const Z_UTIL_DEC_2605: u32 = 2604;
pub const Z_UTIL_DEC_2606: u32 = 2605;
pub const Z_UTIL_DEC_2607: u32 = 2606;
pub const Z_UTIL_DEC_2608: u32 = 2607;
pub const Z_UTIL_DEC_2609: u32 = 2608;
pub const Z_UTIL_DEC_2610: u32 = 2609;
pub const Z_UTIL_DEC_2611: u32 = 2610;
pub const Z_UTIL_DEC_2612: u32 = 2611;
pub const Z_UTIL_DEC_2613: u32 = 2612;
pub const Z_UTIL_DEC_2614: u32 = 2613;
pub const Z_UTIL_DEC_2615: u32 = 2614;
pub const Z_UTIL_DEC_2616: u32 = 2615;
pub const Z_UTIL_DEC_2617: u32 = 2616;
pub const Z_UTIL_DEC_2618: u32 = 2617;
pub const Z_UTIL_DEC_2619: u32 = 2618;
pub const Z_UTIL_DEC_2620: u32 = 2619;
pub const Z_UTIL_DEC_2621: u32 = 2620;
pub const Z_UTIL_DEC_2622: u32 = 2621;
pub const Z_UTIL_DEC_2623: u32 = 2622;
pub const Z_UTIL_DEC_2624: u32 = 2623;
pub const Z_UTIL_DEC_2625: u32 = 2624;
pub const Z_UTIL_DEC_2626: u32 = 2625;
pub const Z_UTIL_DEC_2627: u32 = 2626;
pub const Z_UTIL_DEC_2628: u32 = 2627;
pub const Z_UTIL_DEC_2629: u32 = 2628;
pub const Z_UTIL_DEC_2630: u32 = 2629;
pub const Z_UTIL_DEC_2631: u32 = 2630;
pub const Z_UTIL_DEC_2632: u32 = 2631;
pub const Z_UTIL_DEC_2633: u32 = 2632;
pub const Z_UTIL_DEC_2634: u32 = 2633;
pub const Z_UTIL_DEC_2635: u32 = 2634;
pub const Z_UTIL_DEC_2636: u32 = 2635;
pub const Z_UTIL_DEC_2637: u32 = 2636;
pub const Z_UTIL_DEC_2638: u32 = 2637;
pub const Z_UTIL_DEC_2639: u32 = 2638;
pub const Z_UTIL_DEC_2640: u32 = 2639;
pub const Z_UTIL_DEC_2641: u32 = 2640;
pub const Z_UTIL_DEC_2642: u32 = 2641;
pub const Z_UTIL_DEC_2643: u32 = 2642;
pub const Z_UTIL_DEC_2644: u32 = 2643;
pub const Z_UTIL_DEC_2645: u32 = 2644;
pub const Z_UTIL_DEC_2646: u32 = 2645;
pub const Z_UTIL_DEC_2647: u32 = 2646;
pub const Z_UTIL_DEC_2648: u32 = 2647;
pub const Z_UTIL_DEC_2649: u32 = 2648;
pub const Z_UTIL_DEC_2650: u32 = 2649;
pub const Z_UTIL_DEC_2651: u32 = 2650;
pub const Z_UTIL_DEC_2652: u32 = 2651;
pub const Z_UTIL_DEC_2653: u32 = 2652;
pub const Z_UTIL_DEC_2654: u32 = 2653;
pub const Z_UTIL_DEC_2655: u32 = 2654;
pub const Z_UTIL_DEC_2656: u32 = 2655;
pub const Z_UTIL_DEC_2657: u32 = 2656;
pub const Z_UTIL_DEC_2658: u32 = 2657;
pub const Z_UTIL_DEC_2659: u32 = 2658;
pub const Z_UTIL_DEC_2660: u32 = 2659;
pub const Z_UTIL_DEC_2661: u32 = 2660;
pub const Z_UTIL_DEC_2662: u32 = 2661;
pub const Z_UTIL_DEC_2663: u32 = 2662;
pub const Z_UTIL_DEC_2664: u32 = 2663;
pub const Z_UTIL_DEC_2665: u32 = 2664;
pub const Z_UTIL_DEC_2666: u32 = 2665;
pub const Z_UTIL_DEC_2667: u32 = 2666;
pub const Z_UTIL_DEC_2668: u32 = 2667;
pub const Z_UTIL_DEC_2669: u32 = 2668;
pub const Z_UTIL_DEC_2670: u32 = 2669;
pub const Z_UTIL_DEC_2671: u32 = 2670;
pub const Z_UTIL_DEC_2672: u32 = 2671;
pub const Z_UTIL_DEC_2673: u32 = 2672;
pub const Z_UTIL_DEC_2674: u32 = 2673;
pub const Z_UTIL_DEC_2675: u32 = 2674;
pub const Z_UTIL_DEC_2676: u32 = 2675;
pub const Z_UTIL_DEC_2677: u32 = 2676;
pub const Z_UTIL_DEC_2678: u32 = 2677;
pub const Z_UTIL_DEC_2679: u32 = 2678;
pub const Z_UTIL_DEC_2680: u32 = 2679;
pub const Z_UTIL_DEC_2681: u32 = 2680;
pub const Z_UTIL_DEC_2682: u32 = 2681;
pub const Z_UTIL_DEC_2683: u32 = 2682;
pub const Z_UTIL_DEC_2684: u32 = 2683;
pub const Z_UTIL_DEC_2685: u32 = 2684;
pub const Z_UTIL_DEC_2686: u32 = 2685;
pub const Z_UTIL_DEC_2687: u32 = 2686;
pub const Z_UTIL_DEC_2688: u32 = 2687;
pub const Z_UTIL_DEC_2689: u32 = 2688;
pub const Z_UTIL_DEC_2690: u32 = 2689;
pub const Z_UTIL_DEC_2691: u32 = 2690;
pub const Z_UTIL_DEC_2692: u32 = 2691;
pub const Z_UTIL_DEC_2693: u32 = 2692;
pub const Z_UTIL_DEC_2694: u32 = 2693;
pub const Z_UTIL_DEC_2695: u32 = 2694;
pub const Z_UTIL_DEC_2696: u32 = 2695;
pub const Z_UTIL_DEC_2697: u32 = 2696;
pub const Z_UTIL_DEC_2698: u32 = 2697;
pub const Z_UTIL_DEC_2699: u32 = 2698;
pub const Z_UTIL_DEC_2700: u32 = 2699;
pub const Z_UTIL_DEC_2701: u32 = 2700;
pub const Z_UTIL_DEC_2702: u32 = 2701;
pub const Z_UTIL_DEC_2703: u32 = 2702;
pub const Z_UTIL_DEC_2704: u32 = 2703;
pub const Z_UTIL_DEC_2705: u32 = 2704;
pub const Z_UTIL_DEC_2706: u32 = 2705;
pub const Z_UTIL_DEC_2707: u32 = 2706;
pub const Z_UTIL_DEC_2708: u32 = 2707;
pub const Z_UTIL_DEC_2709: u32 = 2708;
pub const Z_UTIL_DEC_2710: u32 = 2709;
pub const Z_UTIL_DEC_2711: u32 = 2710;
pub const Z_UTIL_DEC_2712: u32 = 2711;
pub const Z_UTIL_DEC_2713: u32 = 2712;
pub const Z_UTIL_DEC_2714: u32 = 2713;
pub const Z_UTIL_DEC_2715: u32 = 2714;
pub const Z_UTIL_DEC_2716: u32 = 2715;
pub const Z_UTIL_DEC_2717: u32 = 2716;
pub const Z_UTIL_DEC_2718: u32 = 2717;
pub const Z_UTIL_DEC_2719: u32 = 2718;
pub const Z_UTIL_DEC_2720: u32 = 2719;
pub const Z_UTIL_DEC_2721: u32 = 2720;
pub const Z_UTIL_DEC_2722: u32 = 2721;
pub const Z_UTIL_DEC_2723: u32 = 2722;
pub const Z_UTIL_DEC_2724: u32 = 2723;
pub const Z_UTIL_DEC_2725: u32 = 2724;
pub const Z_UTIL_DEC_2726: u32 = 2725;
pub const Z_UTIL_DEC_2727: u32 = 2726;
pub const Z_UTIL_DEC_2728: u32 = 2727;
pub const Z_UTIL_DEC_2729: u32 = 2728;
pub const Z_UTIL_DEC_2730: u32 = 2729;
pub const Z_UTIL_DEC_2731: u32 = 2730;
pub const Z_UTIL_DEC_2732: u32 = 2731;
pub const Z_UTIL_DEC_2733: u32 = 2732;
pub const Z_UTIL_DEC_2734: u32 = 2733;
pub const Z_UTIL_DEC_2735: u32 = 2734;
pub const Z_UTIL_DEC_2736: u32 = 2735;
pub const Z_UTIL_DEC_2737: u32 = 2736;
pub const Z_UTIL_DEC_2738: u32 = 2737;
pub const Z_UTIL_DEC_2739: u32 = 2738;
pub const Z_UTIL_DEC_2740: u32 = 2739;
pub const Z_UTIL_DEC_2741: u32 = 2740;
pub const Z_UTIL_DEC_2742: u32 = 2741;
pub const Z_UTIL_DEC_2743: u32 = 2742;
pub const Z_UTIL_DEC_2744: u32 = 2743;
pub const Z_UTIL_DEC_2745: u32 = 2744;
pub const Z_UTIL_DEC_2746: u32 = 2745;
pub const Z_UTIL_DEC_2747: u32 = 2746;
pub const Z_UTIL_DEC_2748: u32 = 2747;
pub const Z_UTIL_DEC_2749: u32 = 2748;
pub const Z_UTIL_DEC_2750: u32 = 2749;
pub const Z_UTIL_DEC_2751: u32 = 2750;
pub const Z_UTIL_DEC_2752: u32 = 2751;
pub const Z_UTIL_DEC_2753: u32 = 2752;
pub const Z_UTIL_DEC_2754: u32 = 2753;
pub const Z_UTIL_DEC_2755: u32 = 2754;
pub const Z_UTIL_DEC_2756: u32 = 2755;
pub const Z_UTIL_DEC_2757: u32 = 2756;
pub const Z_UTIL_DEC_2758: u32 = 2757;
pub const Z_UTIL_DEC_2759: u32 = 2758;
pub const Z_UTIL_DEC_2760: u32 = 2759;
pub const Z_UTIL_DEC_2761: u32 = 2760;
pub const Z_UTIL_DEC_2762: u32 = 2761;
pub const Z_UTIL_DEC_2763: u32 = 2762;
pub const Z_UTIL_DEC_2764: u32 = 2763;
pub const Z_UTIL_DEC_2765: u32 = 2764;
pub const Z_UTIL_DEC_2766: u32 = 2765;
pub const Z_UTIL_DEC_2767: u32 = 2766;
pub const Z_UTIL_DEC_2768: u32 = 2767;
pub const Z_UTIL_DEC_2769: u32 = 2768;
pub const Z_UTIL_DEC_2770: u32 = 2769;
pub const Z_UTIL_DEC_2771: u32 = 2770;
pub const Z_UTIL_DEC_2772: u32 = 2771;
pub const Z_UTIL_DEC_2773: u32 = 2772;
pub const Z_UTIL_DEC_2774: u32 = 2773;
pub const Z_UTIL_DEC_2775: u32 = 2774;
pub const Z_UTIL_DEC_2776: u32 = 2775;
pub const Z_UTIL_DEC_2777: u32 = 2776;
pub const Z_UTIL_DEC_2778: u32 = 2777;
pub const Z_UTIL_DEC_2779: u32 = 2778;
pub const Z_UTIL_DEC_2780: u32 = 2779;
pub const Z_UTIL_DEC_2781: u32 = 2780;
pub const Z_UTIL_DEC_2782: u32 = 2781;
pub const Z_UTIL_DEC_2783: u32 = 2782;
pub const Z_UTIL_DEC_2784: u32 = 2783;
pub const Z_UTIL_DEC_2785: u32 = 2784;
pub const Z_UTIL_DEC_2786: u32 = 2785;
pub const Z_UTIL_DEC_2787: u32 = 2786;
pub const Z_UTIL_DEC_2788: u32 = 2787;
pub const Z_UTIL_DEC_2789: u32 = 2788;
pub const Z_UTIL_DEC_2790: u32 = 2789;
pub const Z_UTIL_DEC_2791: u32 = 2790;
pub const Z_UTIL_DEC_2792: u32 = 2791;
pub const Z_UTIL_DEC_2793: u32 = 2792;
pub const Z_UTIL_DEC_2794: u32 = 2793;
pub const Z_UTIL_DEC_2795: u32 = 2794;
pub const Z_UTIL_DEC_2796: u32 = 2795;
pub const Z_UTIL_DEC_2797: u32 = 2796;
pub const Z_UTIL_DEC_2798: u32 = 2797;
pub const Z_UTIL_DEC_2799: u32 = 2798;
pub const Z_UTIL_DEC_2800: u32 = 2799;
pub const Z_UTIL_DEC_2801: u32 = 2800;
pub const Z_UTIL_DEC_2802: u32 = 2801;
pub const Z_UTIL_DEC_2803: u32 = 2802;
pub const Z_UTIL_DEC_2804: u32 = 2803;
pub const Z_UTIL_DEC_2805: u32 = 2804;
pub const Z_UTIL_DEC_2806: u32 = 2805;
pub const Z_UTIL_DEC_2807: u32 = 2806;
pub const Z_UTIL_DEC_2808: u32 = 2807;
pub const Z_UTIL_DEC_2809: u32 = 2808;
pub const Z_UTIL_DEC_2810: u32 = 2809;
pub const Z_UTIL_DEC_2811: u32 = 2810;
pub const Z_UTIL_DEC_2812: u32 = 2811;
pub const Z_UTIL_DEC_2813: u32 = 2812;
pub const Z_UTIL_DEC_2814: u32 = 2813;
pub const Z_UTIL_DEC_2815: u32 = 2814;
pub const Z_UTIL_DEC_2816: u32 = 2815;
pub const Z_UTIL_DEC_2817: u32 = 2816;
pub const Z_UTIL_DEC_2818: u32 = 2817;
pub const Z_UTIL_DEC_2819: u32 = 2818;
pub const Z_UTIL_DEC_2820: u32 = 2819;
pub const Z_UTIL_DEC_2821: u32 = 2820;
pub const Z_UTIL_DEC_2822: u32 = 2821;
pub const Z_UTIL_DEC_2823: u32 = 2822;
pub const Z_UTIL_DEC_2824: u32 = 2823;
pub const Z_UTIL_DEC_2825: u32 = 2824;
pub const Z_UTIL_DEC_2826: u32 = 2825;
pub const Z_UTIL_DEC_2827: u32 = 2826;
pub const Z_UTIL_DEC_2828: u32 = 2827;
pub const Z_UTIL_DEC_2829: u32 = 2828;
pub const Z_UTIL_DEC_2830: u32 = 2829;
pub const Z_UTIL_DEC_2831: u32 = 2830;
pub const Z_UTIL_DEC_2832: u32 = 2831;
pub const Z_UTIL_DEC_2833: u32 = 2832;
pub const Z_UTIL_DEC_2834: u32 = 2833;
pub const Z_UTIL_DEC_2835: u32 = 2834;
pub const Z_UTIL_DEC_2836: u32 = 2835;
pub const Z_UTIL_DEC_2837: u32 = 2836;
pub const Z_UTIL_DEC_2838: u32 = 2837;
pub const Z_UTIL_DEC_2839: u32 = 2838;
pub const Z_UTIL_DEC_2840: u32 = 2839;
pub const Z_UTIL_DEC_2841: u32 = 2840;
pub const Z_UTIL_DEC_2842: u32 = 2841;
pub const Z_UTIL_DEC_2843: u32 = 2842;
pub const Z_UTIL_DEC_2844: u32 = 2843;
pub const Z_UTIL_DEC_2845: u32 = 2844;
pub const Z_UTIL_DEC_2846: u32 = 2845;
pub const Z_UTIL_DEC_2847: u32 = 2846;
pub const Z_UTIL_DEC_2848: u32 = 2847;
pub const Z_UTIL_DEC_2849: u32 = 2848;
pub const Z_UTIL_DEC_2850: u32 = 2849;
pub const Z_UTIL_DEC_2851: u32 = 2850;
pub const Z_UTIL_DEC_2852: u32 = 2851;
pub const Z_UTIL_DEC_2853: u32 = 2852;
pub const Z_UTIL_DEC_2854: u32 = 2853;
pub const Z_UTIL_DEC_2855: u32 = 2854;
pub const Z_UTIL_DEC_2856: u32 = 2855;
pub const Z_UTIL_DEC_2857: u32 = 2856;
pub const Z_UTIL_DEC_2858: u32 = 2857;
pub const Z_UTIL_DEC_2859: u32 = 2858;
pub const Z_UTIL_DEC_2860: u32 = 2859;
pub const Z_UTIL_DEC_2861: u32 = 2860;
pub const Z_UTIL_DEC_2862: u32 = 2861;
pub const Z_UTIL_DEC_2863: u32 = 2862;
pub const Z_UTIL_DEC_2864: u32 = 2863;
pub const Z_UTIL_DEC_2865: u32 = 2864;
pub const Z_UTIL_DEC_2866: u32 = 2865;
pub const Z_UTIL_DEC_2867: u32 = 2866;
pub const Z_UTIL_DEC_2868: u32 = 2867;
pub const Z_UTIL_DEC_2869: u32 = 2868;
pub const Z_UTIL_DEC_2870: u32 = 2869;
pub const Z_UTIL_DEC_2871: u32 = 2870;
pub const Z_UTIL_DEC_2872: u32 = 2871;
pub const Z_UTIL_DEC_2873: u32 = 2872;
pub const Z_UTIL_DEC_2874: u32 = 2873;
pub const Z_UTIL_DEC_2875: u32 = 2874;
pub const Z_UTIL_DEC_2876: u32 = 2875;
pub const Z_UTIL_DEC_2877: u32 = 2876;
pub const Z_UTIL_DEC_2878: u32 = 2877;
pub const Z_UTIL_DEC_2879: u32 = 2878;
pub const Z_UTIL_DEC_2880: u32 = 2879;
pub const Z_UTIL_DEC_2881: u32 = 2880;
pub const Z_UTIL_DEC_2882: u32 = 2881;
pub const Z_UTIL_DEC_2883: u32 = 2882;
pub const Z_UTIL_DEC_2884: u32 = 2883;
pub const Z_UTIL_DEC_2885: u32 = 2884;
pub const Z_UTIL_DEC_2886: u32 = 2885;
pub const Z_UTIL_DEC_2887: u32 = 2886;
pub const Z_UTIL_DEC_2888: u32 = 2887;
pub const Z_UTIL_DEC_2889: u32 = 2888;
pub const Z_UTIL_DEC_2890: u32 = 2889;
pub const Z_UTIL_DEC_2891: u32 = 2890;
pub const Z_UTIL_DEC_2892: u32 = 2891;
pub const Z_UTIL_DEC_2893: u32 = 2892;
pub const Z_UTIL_DEC_2894: u32 = 2893;
pub const Z_UTIL_DEC_2895: u32 = 2894;
pub const Z_UTIL_DEC_2896: u32 = 2895;
pub const Z_UTIL_DEC_2897: u32 = 2896;
pub const Z_UTIL_DEC_2898: u32 = 2897;
pub const Z_UTIL_DEC_2899: u32 = 2898;
pub const Z_UTIL_DEC_2900: u32 = 2899;
pub const Z_UTIL_DEC_2901: u32 = 2900;
pub const Z_UTIL_DEC_2902: u32 = 2901;
pub const Z_UTIL_DEC_2903: u32 = 2902;
pub const Z_UTIL_DEC_2904: u32 = 2903;
pub const Z_UTIL_DEC_2905: u32 = 2904;
pub const Z_UTIL_DEC_2906: u32 = 2905;
pub const Z_UTIL_DEC_2907: u32 = 2906;
pub const Z_UTIL_DEC_2908: u32 = 2907;
pub const Z_UTIL_DEC_2909: u32 = 2908;
pub const Z_UTIL_DEC_2910: u32 = 2909;
pub const Z_UTIL_DEC_2911: u32 = 2910;
pub const Z_UTIL_DEC_2912: u32 = 2911;
pub const Z_UTIL_DEC_2913: u32 = 2912;
pub const Z_UTIL_DEC_2914: u32 = 2913;
pub const Z_UTIL_DEC_2915: u32 = 2914;
pub const Z_UTIL_DEC_2916: u32 = 2915;
pub const Z_UTIL_DEC_2917: u32 = 2916;
pub const Z_UTIL_DEC_2918: u32 = 2917;
pub const Z_UTIL_DEC_2919: u32 = 2918;
pub const Z_UTIL_DEC_2920: u32 = 2919;
pub const Z_UTIL_DEC_2921: u32 = 2920;
pub const Z_UTIL_DEC_2922: u32 = 2921;
pub const Z_UTIL_DEC_2923: u32 = 2922;
pub const Z_UTIL_DEC_2924: u32 = 2923;
pub const Z_UTIL_DEC_2925: u32 = 2924;
pub const Z_UTIL_DEC_2926: u32 = 2925;
pub const Z_UTIL_DEC_2927: u32 = 2926;
pub const Z_UTIL_DEC_2928: u32 = 2927;
pub const Z_UTIL_DEC_2929: u32 = 2928;
pub const Z_UTIL_DEC_2930: u32 = 2929;
pub const Z_UTIL_DEC_2931: u32 = 2930;
pub const Z_UTIL_DEC_2932: u32 = 2931;
pub const Z_UTIL_DEC_2933: u32 = 2932;
pub const Z_UTIL_DEC_2934: u32 = 2933;
pub const Z_UTIL_DEC_2935: u32 = 2934;
pub const Z_UTIL_DEC_2936: u32 = 2935;
pub const Z_UTIL_DEC_2937: u32 = 2936;
pub const Z_UTIL_DEC_2938: u32 = 2937;
pub const Z_UTIL_DEC_2939: u32 = 2938;
pub const Z_UTIL_DEC_2940: u32 = 2939;
pub const Z_UTIL_DEC_2941: u32 = 2940;
pub const Z_UTIL_DEC_2942: u32 = 2941;
pub const Z_UTIL_DEC_2943: u32 = 2942;
pub const Z_UTIL_DEC_2944: u32 = 2943;
pub const Z_UTIL_DEC_2945: u32 = 2944;
pub const Z_UTIL_DEC_2946: u32 = 2945;
pub const Z_UTIL_DEC_2947: u32 = 2946;
pub const Z_UTIL_DEC_2948: u32 = 2947;
pub const Z_UTIL_DEC_2949: u32 = 2948;
pub const Z_UTIL_DEC_2950: u32 = 2949;
pub const Z_UTIL_DEC_2951: u32 = 2950;
pub const Z_UTIL_DEC_2952: u32 = 2951;
pub const Z_UTIL_DEC_2953: u32 = 2952;
pub const Z_UTIL_DEC_2954: u32 = 2953;
pub const Z_UTIL_DEC_2955: u32 = 2954;
pub const Z_UTIL_DEC_2956: u32 = 2955;
pub const Z_UTIL_DEC_2957: u32 = 2956;
pub const Z_UTIL_DEC_2958: u32 = 2957;
pub const Z_UTIL_DEC_2959: u32 = 2958;
pub const Z_UTIL_DEC_2960: u32 = 2959;
pub const Z_UTIL_DEC_2961: u32 = 2960;
pub const Z_UTIL_DEC_2962: u32 = 2961;
pub const Z_UTIL_DEC_2963: u32 = 2962;
pub const Z_UTIL_DEC_2964: u32 = 2963;
pub const Z_UTIL_DEC_2965: u32 = 2964;
pub const Z_UTIL_DEC_2966: u32 = 2965;
pub const Z_UTIL_DEC_2967: u32 = 2966;
pub const Z_UTIL_DEC_2968: u32 = 2967;
pub const Z_UTIL_DEC_2969: u32 = 2968;
pub const Z_UTIL_DEC_2970: u32 = 2969;
pub const Z_UTIL_DEC_2971: u32 = 2970;
pub const Z_UTIL_DEC_2972: u32 = 2971;
pub const Z_UTIL_DEC_2973: u32 = 2972;
pub const Z_UTIL_DEC_2974: u32 = 2973;
pub const Z_UTIL_DEC_2975: u32 = 2974;
pub const Z_UTIL_DEC_2976: u32 = 2975;
pub const Z_UTIL_DEC_2977: u32 = 2976;
pub const Z_UTIL_DEC_2978: u32 = 2977;
pub const Z_UTIL_DEC_2979: u32 = 2978;
pub const Z_UTIL_DEC_2980: u32 = 2979;
pub const Z_UTIL_DEC_2981: u32 = 2980;
pub const Z_UTIL_DEC_2982: u32 = 2981;
pub const Z_UTIL_DEC_2983: u32 = 2982;
pub const Z_UTIL_DEC_2984: u32 = 2983;
pub const Z_UTIL_DEC_2985: u32 = 2984;
pub const Z_UTIL_DEC_2986: u32 = 2985;
pub const Z_UTIL_DEC_2987: u32 = 2986;
pub const Z_UTIL_DEC_2988: u32 = 2987;
pub const Z_UTIL_DEC_2989: u32 = 2988;
pub const Z_UTIL_DEC_2990: u32 = 2989;
pub const Z_UTIL_DEC_2991: u32 = 2990;
pub const Z_UTIL_DEC_2992: u32 = 2991;
pub const Z_UTIL_DEC_2993: u32 = 2992;
pub const Z_UTIL_DEC_2994: u32 = 2993;
pub const Z_UTIL_DEC_2995: u32 = 2994;
pub const Z_UTIL_DEC_2996: u32 = 2995;
pub const Z_UTIL_DEC_2997: u32 = 2996;
pub const Z_UTIL_DEC_2998: u32 = 2997;
pub const Z_UTIL_DEC_2999: u32 = 2998;
pub const Z_UTIL_DEC_3000: u32 = 2999;
pub const Z_UTIL_DEC_3001: u32 = 3000;
pub const Z_UTIL_DEC_3002: u32 = 3001;
pub const Z_UTIL_DEC_3003: u32 = 3002;
pub const Z_UTIL_DEC_3004: u32 = 3003;
pub const Z_UTIL_DEC_3005: u32 = 3004;
pub const Z_UTIL_DEC_3006: u32 = 3005;
pub const Z_UTIL_DEC_3007: u32 = 3006;
pub const Z_UTIL_DEC_3008: u32 = 3007;
pub const Z_UTIL_DEC_3009: u32 = 3008;
pub const Z_UTIL_DEC_3010: u32 = 3009;
pub const Z_UTIL_DEC_3011: u32 = 3010;
pub const Z_UTIL_DEC_3012: u32 = 3011;
pub const Z_UTIL_DEC_3013: u32 = 3012;
pub const Z_UTIL_DEC_3014: u32 = 3013;
pub const Z_UTIL_DEC_3015: u32 = 3014;
pub const Z_UTIL_DEC_3016: u32 = 3015;
pub const Z_UTIL_DEC_3017: u32 = 3016;
pub const Z_UTIL_DEC_3018: u32 = 3017;
pub const Z_UTIL_DEC_3019: u32 = 3018;
pub const Z_UTIL_DEC_3020: u32 = 3019;
pub const Z_UTIL_DEC_3021: u32 = 3020;
pub const Z_UTIL_DEC_3022: u32 = 3021;
pub const Z_UTIL_DEC_3023: u32 = 3022;
pub const Z_UTIL_DEC_3024: u32 = 3023;
pub const Z_UTIL_DEC_3025: u32 = 3024;
pub const Z_UTIL_DEC_3026: u32 = 3025;
pub const Z_UTIL_DEC_3027: u32 = 3026;
pub const Z_UTIL_DEC_3028: u32 = 3027;
pub const Z_UTIL_DEC_3029: u32 = 3028;
pub const Z_UTIL_DEC_3030: u32 = 3029;
pub const Z_UTIL_DEC_3031: u32 = 3030;
pub const Z_UTIL_DEC_3032: u32 = 3031;
pub const Z_UTIL_DEC_3033: u32 = 3032;
pub const Z_UTIL_DEC_3034: u32 = 3033;
pub const Z_UTIL_DEC_3035: u32 = 3034;
pub const Z_UTIL_DEC_3036: u32 = 3035;
pub const Z_UTIL_DEC_3037: u32 = 3036;
pub const Z_UTIL_DEC_3038: u32 = 3037;
pub const Z_UTIL_DEC_3039: u32 = 3038;
pub const Z_UTIL_DEC_3040: u32 = 3039;
pub const Z_UTIL_DEC_3041: u32 = 3040;
pub const Z_UTIL_DEC_3042: u32 = 3041;
pub const Z_UTIL_DEC_3043: u32 = 3042;
pub const Z_UTIL_DEC_3044: u32 = 3043;
pub const Z_UTIL_DEC_3045: u32 = 3044;
pub const Z_UTIL_DEC_3046: u32 = 3045;
pub const Z_UTIL_DEC_3047: u32 = 3046;
pub const Z_UTIL_DEC_3048: u32 = 3047;
pub const Z_UTIL_DEC_3049: u32 = 3048;
pub const Z_UTIL_DEC_3050: u32 = 3049;
pub const Z_UTIL_DEC_3051: u32 = 3050;
pub const Z_UTIL_DEC_3052: u32 = 3051;
pub const Z_UTIL_DEC_3053: u32 = 3052;
pub const Z_UTIL_DEC_3054: u32 = 3053;
pub const Z_UTIL_DEC_3055: u32 = 3054;
pub const Z_UTIL_DEC_3056: u32 = 3055;
pub const Z_UTIL_DEC_3057: u32 = 3056;
pub const Z_UTIL_DEC_3058: u32 = 3057;
pub const Z_UTIL_DEC_3059: u32 = 3058;
pub const Z_UTIL_DEC_3060: u32 = 3059;
pub const Z_UTIL_DEC_3061: u32 = 3060;
pub const Z_UTIL_DEC_3062: u32 = 3061;
pub const Z_UTIL_DEC_3063: u32 = 3062;
pub const Z_UTIL_DEC_3064: u32 = 3063;
pub const Z_UTIL_DEC_3065: u32 = 3064;
pub const Z_UTIL_DEC_3066: u32 = 3065;
pub const Z_UTIL_DEC_3067: u32 = 3066;
pub const Z_UTIL_DEC_3068: u32 = 3067;
pub const Z_UTIL_DEC_3069: u32 = 3068;
pub const Z_UTIL_DEC_3070: u32 = 3069;
pub const Z_UTIL_DEC_3071: u32 = 3070;
pub const Z_UTIL_DEC_3072: u32 = 3071;
pub const Z_UTIL_DEC_3073: u32 = 3072;
pub const Z_UTIL_DEC_3074: u32 = 3073;
pub const Z_UTIL_DEC_3075: u32 = 3074;
pub const Z_UTIL_DEC_3076: u32 = 3075;
pub const Z_UTIL_DEC_3077: u32 = 3076;
pub const Z_UTIL_DEC_3078: u32 = 3077;
pub const Z_UTIL_DEC_3079: u32 = 3078;
pub const Z_UTIL_DEC_3080: u32 = 3079;
pub const Z_UTIL_DEC_3081: u32 = 3080;
pub const Z_UTIL_DEC_3082: u32 = 3081;
pub const Z_UTIL_DEC_3083: u32 = 3082;
pub const Z_UTIL_DEC_3084: u32 = 3083;
pub const Z_UTIL_DEC_3085: u32 = 3084;
pub const Z_UTIL_DEC_3086: u32 = 3085;
pub const Z_UTIL_DEC_3087: u32 = 3086;
pub const Z_UTIL_DEC_3088: u32 = 3087;
pub const Z_UTIL_DEC_3089: u32 = 3088;
pub const Z_UTIL_DEC_3090: u32 = 3089;
pub const Z_UTIL_DEC_3091: u32 = 3090;
pub const Z_UTIL_DEC_3092: u32 = 3091;
pub const Z_UTIL_DEC_3093: u32 = 3092;
pub const Z_UTIL_DEC_3094: u32 = 3093;
pub const Z_UTIL_DEC_3095: u32 = 3094;
pub const Z_UTIL_DEC_3096: u32 = 3095;
pub const Z_UTIL_DEC_3097: u32 = 3096;
pub const Z_UTIL_DEC_3098: u32 = 3097;
pub const Z_UTIL_DEC_3099: u32 = 3098;
pub const Z_UTIL_DEC_3100: u32 = 3099;
pub const Z_UTIL_DEC_3101: u32 = 3100;
pub const Z_UTIL_DEC_3102: u32 = 3101;
pub const Z_UTIL_DEC_3103: u32 = 3102;
pub const Z_UTIL_DEC_3104: u32 = 3103;
pub const Z_UTIL_DEC_3105: u32 = 3104;
pub const Z_UTIL_DEC_3106: u32 = 3105;
pub const Z_UTIL_DEC_3107: u32 = 3106;
pub const Z_UTIL_DEC_3108: u32 = 3107;
pub const Z_UTIL_DEC_3109: u32 = 3108;
pub const Z_UTIL_DEC_3110: u32 = 3109;
pub const Z_UTIL_DEC_3111: u32 = 3110;
pub const Z_UTIL_DEC_3112: u32 = 3111;
pub const Z_UTIL_DEC_3113: u32 = 3112;
pub const Z_UTIL_DEC_3114: u32 = 3113;
pub const Z_UTIL_DEC_3115: u32 = 3114;
pub const Z_UTIL_DEC_3116: u32 = 3115;
pub const Z_UTIL_DEC_3117: u32 = 3116;
pub const Z_UTIL_DEC_3118: u32 = 3117;
pub const Z_UTIL_DEC_3119: u32 = 3118;
pub const Z_UTIL_DEC_3120: u32 = 3119;
pub const Z_UTIL_DEC_3121: u32 = 3120;
pub const Z_UTIL_DEC_3122: u32 = 3121;
pub const Z_UTIL_DEC_3123: u32 = 3122;
pub const Z_UTIL_DEC_3124: u32 = 3123;
pub const Z_UTIL_DEC_3125: u32 = 3124;
pub const Z_UTIL_DEC_3126: u32 = 3125;
pub const Z_UTIL_DEC_3127: u32 = 3126;
pub const Z_UTIL_DEC_3128: u32 = 3127;
pub const Z_UTIL_DEC_3129: u32 = 3128;
pub const Z_UTIL_DEC_3130: u32 = 3129;
pub const Z_UTIL_DEC_3131: u32 = 3130;
pub const Z_UTIL_DEC_3132: u32 = 3131;
pub const Z_UTIL_DEC_3133: u32 = 3132;
pub const Z_UTIL_DEC_3134: u32 = 3133;
pub const Z_UTIL_DEC_3135: u32 = 3134;
pub const Z_UTIL_DEC_3136: u32 = 3135;
pub const Z_UTIL_DEC_3137: u32 = 3136;
pub const Z_UTIL_DEC_3138: u32 = 3137;
pub const Z_UTIL_DEC_3139: u32 = 3138;
pub const Z_UTIL_DEC_3140: u32 = 3139;
pub const Z_UTIL_DEC_3141: u32 = 3140;
pub const Z_UTIL_DEC_3142: u32 = 3141;
pub const Z_UTIL_DEC_3143: u32 = 3142;
pub const Z_UTIL_DEC_3144: u32 = 3143;
pub const Z_UTIL_DEC_3145: u32 = 3144;
pub const Z_UTIL_DEC_3146: u32 = 3145;
pub const Z_UTIL_DEC_3147: u32 = 3146;
pub const Z_UTIL_DEC_3148: u32 = 3147;
pub const Z_UTIL_DEC_3149: u32 = 3148;
pub const Z_UTIL_DEC_3150: u32 = 3149;
pub const Z_UTIL_DEC_3151: u32 = 3150;
pub const Z_UTIL_DEC_3152: u32 = 3151;
pub const Z_UTIL_DEC_3153: u32 = 3152;
pub const Z_UTIL_DEC_3154: u32 = 3153;
pub const Z_UTIL_DEC_3155: u32 = 3154;
pub const Z_UTIL_DEC_3156: u32 = 3155;
pub const Z_UTIL_DEC_3157: u32 = 3156;
pub const Z_UTIL_DEC_3158: u32 = 3157;
pub const Z_UTIL_DEC_3159: u32 = 3158;
pub const Z_UTIL_DEC_3160: u32 = 3159;
pub const Z_UTIL_DEC_3161: u32 = 3160;
pub const Z_UTIL_DEC_3162: u32 = 3161;
pub const Z_UTIL_DEC_3163: u32 = 3162;
pub const Z_UTIL_DEC_3164: u32 = 3163;
pub const Z_UTIL_DEC_3165: u32 = 3164;
pub const Z_UTIL_DEC_3166: u32 = 3165;
pub const Z_UTIL_DEC_3167: u32 = 3166;
pub const Z_UTIL_DEC_3168: u32 = 3167;
pub const Z_UTIL_DEC_3169: u32 = 3168;
pub const Z_UTIL_DEC_3170: u32 = 3169;
pub const Z_UTIL_DEC_3171: u32 = 3170;
pub const Z_UTIL_DEC_3172: u32 = 3171;
pub const Z_UTIL_DEC_3173: u32 = 3172;
pub const Z_UTIL_DEC_3174: u32 = 3173;
pub const Z_UTIL_DEC_3175: u32 = 3174;
pub const Z_UTIL_DEC_3176: u32 = 3175;
pub const Z_UTIL_DEC_3177: u32 = 3176;
pub const Z_UTIL_DEC_3178: u32 = 3177;
pub const Z_UTIL_DEC_3179: u32 = 3178;
pub const Z_UTIL_DEC_3180: u32 = 3179;
pub const Z_UTIL_DEC_3181: u32 = 3180;
pub const Z_UTIL_DEC_3182: u32 = 3181;
pub const Z_UTIL_DEC_3183: u32 = 3182;
pub const Z_UTIL_DEC_3184: u32 = 3183;
pub const Z_UTIL_DEC_3185: u32 = 3184;
pub const Z_UTIL_DEC_3186: u32 = 3185;
pub const Z_UTIL_DEC_3187: u32 = 3186;
pub const Z_UTIL_DEC_3188: u32 = 3187;
pub const Z_UTIL_DEC_3189: u32 = 3188;
pub const Z_UTIL_DEC_3190: u32 = 3189;
pub const Z_UTIL_DEC_3191: u32 = 3190;
pub const Z_UTIL_DEC_3192: u32 = 3191;
pub const Z_UTIL_DEC_3193: u32 = 3192;
pub const Z_UTIL_DEC_3194: u32 = 3193;
pub const Z_UTIL_DEC_3195: u32 = 3194;
pub const Z_UTIL_DEC_3196: u32 = 3195;
pub const Z_UTIL_DEC_3197: u32 = 3196;
pub const Z_UTIL_DEC_3198: u32 = 3197;
pub const Z_UTIL_DEC_3199: u32 = 3198;
pub const Z_UTIL_DEC_3200: u32 = 3199;
pub const Z_UTIL_DEC_3201: u32 = 3200;
pub const Z_UTIL_DEC_3202: u32 = 3201;
pub const Z_UTIL_DEC_3203: u32 = 3202;
pub const Z_UTIL_DEC_3204: u32 = 3203;
pub const Z_UTIL_DEC_3205: u32 = 3204;
pub const Z_UTIL_DEC_3206: u32 = 3205;
pub const Z_UTIL_DEC_3207: u32 = 3206;
pub const Z_UTIL_DEC_3208: u32 = 3207;
pub const Z_UTIL_DEC_3209: u32 = 3208;
pub const Z_UTIL_DEC_3210: u32 = 3209;
pub const Z_UTIL_DEC_3211: u32 = 3210;
pub const Z_UTIL_DEC_3212: u32 = 3211;
pub const Z_UTIL_DEC_3213: u32 = 3212;
pub const Z_UTIL_DEC_3214: u32 = 3213;
pub const Z_UTIL_DEC_3215: u32 = 3214;
pub const Z_UTIL_DEC_3216: u32 = 3215;
pub const Z_UTIL_DEC_3217: u32 = 3216;
pub const Z_UTIL_DEC_3218: u32 = 3217;
pub const Z_UTIL_DEC_3219: u32 = 3218;
pub const Z_UTIL_DEC_3220: u32 = 3219;
pub const Z_UTIL_DEC_3221: u32 = 3220;
pub const Z_UTIL_DEC_3222: u32 = 3221;
pub const Z_UTIL_DEC_3223: u32 = 3222;
pub const Z_UTIL_DEC_3224: u32 = 3223;
pub const Z_UTIL_DEC_3225: u32 = 3224;
pub const Z_UTIL_DEC_3226: u32 = 3225;
pub const Z_UTIL_DEC_3227: u32 = 3226;
pub const Z_UTIL_DEC_3228: u32 = 3227;
pub const Z_UTIL_DEC_3229: u32 = 3228;
pub const Z_UTIL_DEC_3230: u32 = 3229;
pub const Z_UTIL_DEC_3231: u32 = 3230;
pub const Z_UTIL_DEC_3232: u32 = 3231;
pub const Z_UTIL_DEC_3233: u32 = 3232;
pub const Z_UTIL_DEC_3234: u32 = 3233;
pub const Z_UTIL_DEC_3235: u32 = 3234;
pub const Z_UTIL_DEC_3236: u32 = 3235;
pub const Z_UTIL_DEC_3237: u32 = 3236;
pub const Z_UTIL_DEC_3238: u32 = 3237;
pub const Z_UTIL_DEC_3239: u32 = 3238;
pub const Z_UTIL_DEC_3240: u32 = 3239;
pub const Z_UTIL_DEC_3241: u32 = 3240;
pub const Z_UTIL_DEC_3242: u32 = 3241;
pub const Z_UTIL_DEC_3243: u32 = 3242;
pub const Z_UTIL_DEC_3244: u32 = 3243;
pub const Z_UTIL_DEC_3245: u32 = 3244;
pub const Z_UTIL_DEC_3246: u32 = 3245;
pub const Z_UTIL_DEC_3247: u32 = 3246;
pub const Z_UTIL_DEC_3248: u32 = 3247;
pub const Z_UTIL_DEC_3249: u32 = 3248;
pub const Z_UTIL_DEC_3250: u32 = 3249;
pub const Z_UTIL_DEC_3251: u32 = 3250;
pub const Z_UTIL_DEC_3252: u32 = 3251;
pub const Z_UTIL_DEC_3253: u32 = 3252;
pub const Z_UTIL_DEC_3254: u32 = 3253;
pub const Z_UTIL_DEC_3255: u32 = 3254;
pub const Z_UTIL_DEC_3256: u32 = 3255;
pub const Z_UTIL_DEC_3257: u32 = 3256;
pub const Z_UTIL_DEC_3258: u32 = 3257;
pub const Z_UTIL_DEC_3259: u32 = 3258;
pub const Z_UTIL_DEC_3260: u32 = 3259;
pub const Z_UTIL_DEC_3261: u32 = 3260;
pub const Z_UTIL_DEC_3262: u32 = 3261;
pub const Z_UTIL_DEC_3263: u32 = 3262;
pub const Z_UTIL_DEC_3264: u32 = 3263;
pub const Z_UTIL_DEC_3265: u32 = 3264;
pub const Z_UTIL_DEC_3266: u32 = 3265;
pub const Z_UTIL_DEC_3267: u32 = 3266;
pub const Z_UTIL_DEC_3268: u32 = 3267;
pub const Z_UTIL_DEC_3269: u32 = 3268;
pub const Z_UTIL_DEC_3270: u32 = 3269;
pub const Z_UTIL_DEC_3271: u32 = 3270;
pub const Z_UTIL_DEC_3272: u32 = 3271;
pub const Z_UTIL_DEC_3273: u32 = 3272;
pub const Z_UTIL_DEC_3274: u32 = 3273;
pub const Z_UTIL_DEC_3275: u32 = 3274;
pub const Z_UTIL_DEC_3276: u32 = 3275;
pub const Z_UTIL_DEC_3277: u32 = 3276;
pub const Z_UTIL_DEC_3278: u32 = 3277;
pub const Z_UTIL_DEC_3279: u32 = 3278;
pub const Z_UTIL_DEC_3280: u32 = 3279;
pub const Z_UTIL_DEC_3281: u32 = 3280;
pub const Z_UTIL_DEC_3282: u32 = 3281;
pub const Z_UTIL_DEC_3283: u32 = 3282;
pub const Z_UTIL_DEC_3284: u32 = 3283;
pub const Z_UTIL_DEC_3285: u32 = 3284;
pub const Z_UTIL_DEC_3286: u32 = 3285;
pub const Z_UTIL_DEC_3287: u32 = 3286;
pub const Z_UTIL_DEC_3288: u32 = 3287;
pub const Z_UTIL_DEC_3289: u32 = 3288;
pub const Z_UTIL_DEC_3290: u32 = 3289;
pub const Z_UTIL_DEC_3291: u32 = 3290;
pub const Z_UTIL_DEC_3292: u32 = 3291;
pub const Z_UTIL_DEC_3293: u32 = 3292;
pub const Z_UTIL_DEC_3294: u32 = 3293;
pub const Z_UTIL_DEC_3295: u32 = 3294;
pub const Z_UTIL_DEC_3296: u32 = 3295;
pub const Z_UTIL_DEC_3297: u32 = 3296;
pub const Z_UTIL_DEC_3298: u32 = 3297;
pub const Z_UTIL_DEC_3299: u32 = 3298;
pub const Z_UTIL_DEC_3300: u32 = 3299;
pub const Z_UTIL_DEC_3301: u32 = 3300;
pub const Z_UTIL_DEC_3302: u32 = 3301;
pub const Z_UTIL_DEC_3303: u32 = 3302;
pub const Z_UTIL_DEC_3304: u32 = 3303;
pub const Z_UTIL_DEC_3305: u32 = 3304;
pub const Z_UTIL_DEC_3306: u32 = 3305;
pub const Z_UTIL_DEC_3307: u32 = 3306;
pub const Z_UTIL_DEC_3308: u32 = 3307;
pub const Z_UTIL_DEC_3309: u32 = 3308;
pub const Z_UTIL_DEC_3310: u32 = 3309;
pub const Z_UTIL_DEC_3311: u32 = 3310;
pub const Z_UTIL_DEC_3312: u32 = 3311;
pub const Z_UTIL_DEC_3313: u32 = 3312;
pub const Z_UTIL_DEC_3314: u32 = 3313;
pub const Z_UTIL_DEC_3315: u32 = 3314;
pub const Z_UTIL_DEC_3316: u32 = 3315;
pub const Z_UTIL_DEC_3317: u32 = 3316;
pub const Z_UTIL_DEC_3318: u32 = 3317;
pub const Z_UTIL_DEC_3319: u32 = 3318;
pub const Z_UTIL_DEC_3320: u32 = 3319;
pub const Z_UTIL_DEC_3321: u32 = 3320;
pub const Z_UTIL_DEC_3322: u32 = 3321;
pub const Z_UTIL_DEC_3323: u32 = 3322;
pub const Z_UTIL_DEC_3324: u32 = 3323;
pub const Z_UTIL_DEC_3325: u32 = 3324;
pub const Z_UTIL_DEC_3326: u32 = 3325;
pub const Z_UTIL_DEC_3327: u32 = 3326;
pub const Z_UTIL_DEC_3328: u32 = 3327;
pub const Z_UTIL_DEC_3329: u32 = 3328;
pub const Z_UTIL_DEC_3330: u32 = 3329;
pub const Z_UTIL_DEC_3331: u32 = 3330;
pub const Z_UTIL_DEC_3332: u32 = 3331;
pub const Z_UTIL_DEC_3333: u32 = 3332;
pub const Z_UTIL_DEC_3334: u32 = 3333;
pub const Z_UTIL_DEC_3335: u32 = 3334;
pub const Z_UTIL_DEC_3336: u32 = 3335;
pub const Z_UTIL_DEC_3337: u32 = 3336;
pub const Z_UTIL_DEC_3338: u32 = 3337;
pub const Z_UTIL_DEC_3339: u32 = 3338;
pub const Z_UTIL_DEC_3340: u32 = 3339;
pub const Z_UTIL_DEC_3341: u32 = 3340;
pub const Z_UTIL_DEC_3342: u32 = 3341;
pub const Z_UTIL_DEC_3343: u32 = 3342;
pub const Z_UTIL_DEC_3344: u32 = 3343;
pub const Z_UTIL_DEC_3345: u32 = 3344;
pub const Z_UTIL_DEC_3346: u32 = 3345;
pub const Z_UTIL_DEC_3347: u32 = 3346;
pub const Z_UTIL_DEC_3348: u32 = 3347;
pub const Z_UTIL_DEC_3349: u32 = 3348;
pub const Z_UTIL_DEC_3350: u32 = 3349;
pub const Z_UTIL_DEC_3351: u32 = 3350;
pub const Z_UTIL_DEC_3352: u32 = 3351;
pub const Z_UTIL_DEC_3353: u32 = 3352;
pub const Z_UTIL_DEC_3354: u32 = 3353;
pub const Z_UTIL_DEC_3355: u32 = 3354;
pub const Z_UTIL_DEC_3356: u32 = 3355;
pub const Z_UTIL_DEC_3357: u32 = 3356;
pub const Z_UTIL_DEC_3358: u32 = 3357;
pub const Z_UTIL_DEC_3359: u32 = 3358;
pub const Z_UTIL_DEC_3360: u32 = 3359;
pub const Z_UTIL_DEC_3361: u32 = 3360;
pub const Z_UTIL_DEC_3362: u32 = 3361;
pub const Z_UTIL_DEC_3363: u32 = 3362;
pub const Z_UTIL_DEC_3364: u32 = 3363;
pub const Z_UTIL_DEC_3365: u32 = 3364;
pub const Z_UTIL_DEC_3366: u32 = 3365;
pub const Z_UTIL_DEC_3367: u32 = 3366;
pub const Z_UTIL_DEC_3368: u32 = 3367;
pub const Z_UTIL_DEC_3369: u32 = 3368;
pub const Z_UTIL_DEC_3370: u32 = 3369;
pub const Z_UTIL_DEC_3371: u32 = 3370;
pub const Z_UTIL_DEC_3372: u32 = 3371;
pub const Z_UTIL_DEC_3373: u32 = 3372;
pub const Z_UTIL_DEC_3374: u32 = 3373;
pub const Z_UTIL_DEC_3375: u32 = 3374;
pub const Z_UTIL_DEC_3376: u32 = 3375;
pub const Z_UTIL_DEC_3377: u32 = 3376;
pub const Z_UTIL_DEC_3378: u32 = 3377;
pub const Z_UTIL_DEC_3379: u32 = 3378;
pub const Z_UTIL_DEC_3380: u32 = 3379;
pub const Z_UTIL_DEC_3381: u32 = 3380;
pub const Z_UTIL_DEC_3382: u32 = 3381;
pub const Z_UTIL_DEC_3383: u32 = 3382;
pub const Z_UTIL_DEC_3384: u32 = 3383;
pub const Z_UTIL_DEC_3385: u32 = 3384;
pub const Z_UTIL_DEC_3386: u32 = 3385;
pub const Z_UTIL_DEC_3387: u32 = 3386;
pub const Z_UTIL_DEC_3388: u32 = 3387;
pub const Z_UTIL_DEC_3389: u32 = 3388;
pub const Z_UTIL_DEC_3390: u32 = 3389;
pub const Z_UTIL_DEC_3391: u32 = 3390;
pub const Z_UTIL_DEC_3392: u32 = 3391;
pub const Z_UTIL_DEC_3393: u32 = 3392;
pub const Z_UTIL_DEC_3394: u32 = 3393;
pub const Z_UTIL_DEC_3395: u32 = 3394;
pub const Z_UTIL_DEC_3396: u32 = 3395;
pub const Z_UTIL_DEC_3397: u32 = 3396;
pub const Z_UTIL_DEC_3398: u32 = 3397;
pub const Z_UTIL_DEC_3399: u32 = 3398;
pub const Z_UTIL_DEC_3400: u32 = 3399;
pub const Z_UTIL_DEC_3401: u32 = 3400;
pub const Z_UTIL_DEC_3402: u32 = 3401;
pub const Z_UTIL_DEC_3403: u32 = 3402;
pub const Z_UTIL_DEC_3404: u32 = 3403;
pub const Z_UTIL_DEC_3405: u32 = 3404;
pub const Z_UTIL_DEC_3406: u32 = 3405;
pub const Z_UTIL_DEC_3407: u32 = 3406;
pub const Z_UTIL_DEC_3408: u32 = 3407;
pub const Z_UTIL_DEC_3409: u32 = 3408;
pub const Z_UTIL_DEC_3410: u32 = 3409;
pub const Z_UTIL_DEC_3411: u32 = 3410;
pub const Z_UTIL_DEC_3412: u32 = 3411;
pub const Z_UTIL_DEC_3413: u32 = 3412;
pub const Z_UTIL_DEC_3414: u32 = 3413;
pub const Z_UTIL_DEC_3415: u32 = 3414;
pub const Z_UTIL_DEC_3416: u32 = 3415;
pub const Z_UTIL_DEC_3417: u32 = 3416;
pub const Z_UTIL_DEC_3418: u32 = 3417;
pub const Z_UTIL_DEC_3419: u32 = 3418;
pub const Z_UTIL_DEC_3420: u32 = 3419;
pub const Z_UTIL_DEC_3421: u32 = 3420;
pub const Z_UTIL_DEC_3422: u32 = 3421;
pub const Z_UTIL_DEC_3423: u32 = 3422;
pub const Z_UTIL_DEC_3424: u32 = 3423;
pub const Z_UTIL_DEC_3425: u32 = 3424;
pub const Z_UTIL_DEC_3426: u32 = 3425;
pub const Z_UTIL_DEC_3427: u32 = 3426;
pub const Z_UTIL_DEC_3428: u32 = 3427;
pub const Z_UTIL_DEC_3429: u32 = 3428;
pub const Z_UTIL_DEC_3430: u32 = 3429;
pub const Z_UTIL_DEC_3431: u32 = 3430;
pub const Z_UTIL_DEC_3432: u32 = 3431;
pub const Z_UTIL_DEC_3433: u32 = 3432;
pub const Z_UTIL_DEC_3434: u32 = 3433;
pub const Z_UTIL_DEC_3435: u32 = 3434;
pub const Z_UTIL_DEC_3436: u32 = 3435;
pub const Z_UTIL_DEC_3437: u32 = 3436;
pub const Z_UTIL_DEC_3438: u32 = 3437;
pub const Z_UTIL_DEC_3439: u32 = 3438;
pub const Z_UTIL_DEC_3440: u32 = 3439;
pub const Z_UTIL_DEC_3441: u32 = 3440;
pub const Z_UTIL_DEC_3442: u32 = 3441;
pub const Z_UTIL_DEC_3443: u32 = 3442;
pub const Z_UTIL_DEC_3444: u32 = 3443;
pub const Z_UTIL_DEC_3445: u32 = 3444;
pub const Z_UTIL_DEC_3446: u32 = 3445;
pub const Z_UTIL_DEC_3447: u32 = 3446;
pub const Z_UTIL_DEC_3448: u32 = 3447;
pub const Z_UTIL_DEC_3449: u32 = 3448;
pub const Z_UTIL_DEC_3450: u32 = 3449;
pub const Z_UTIL_DEC_3451: u32 = 3450;
pub const Z_UTIL_DEC_3452: u32 = 3451;
pub const Z_UTIL_DEC_3453: u32 = 3452;
pub const Z_UTIL_DEC_3454: u32 = 3453;
pub const Z_UTIL_DEC_3455: u32 = 3454;
pub const Z_UTIL_DEC_3456: u32 = 3455;
pub const Z_UTIL_DEC_3457: u32 = 3456;
pub const Z_UTIL_DEC_3458: u32 = 3457;
pub const Z_UTIL_DEC_3459: u32 = 3458;
pub const Z_UTIL_DEC_3460: u32 = 3459;
pub const Z_UTIL_DEC_3461: u32 = 3460;
pub const Z_UTIL_DEC_3462: u32 = 3461;
pub const Z_UTIL_DEC_3463: u32 = 3462;
pub const Z_UTIL_DEC_3464: u32 = 3463;
pub const Z_UTIL_DEC_3465: u32 = 3464;
pub const Z_UTIL_DEC_3466: u32 = 3465;
pub const Z_UTIL_DEC_3467: u32 = 3466;
pub const Z_UTIL_DEC_3468: u32 = 3467;
pub const Z_UTIL_DEC_3469: u32 = 3468;
pub const Z_UTIL_DEC_3470: u32 = 3469;
pub const Z_UTIL_DEC_3471: u32 = 3470;
pub const Z_UTIL_DEC_3472: u32 = 3471;
pub const Z_UTIL_DEC_3473: u32 = 3472;
pub const Z_UTIL_DEC_3474: u32 = 3473;
pub const Z_UTIL_DEC_3475: u32 = 3474;
pub const Z_UTIL_DEC_3476: u32 = 3475;
pub const Z_UTIL_DEC_3477: u32 = 3476;
pub const Z_UTIL_DEC_3478: u32 = 3477;
pub const Z_UTIL_DEC_3479: u32 = 3478;
pub const Z_UTIL_DEC_3480: u32 = 3479;
pub const Z_UTIL_DEC_3481: u32 = 3480;
pub const Z_UTIL_DEC_3482: u32 = 3481;
pub const Z_UTIL_DEC_3483: u32 = 3482;
pub const Z_UTIL_DEC_3484: u32 = 3483;
pub const Z_UTIL_DEC_3485: u32 = 3484;
pub const Z_UTIL_DEC_3486: u32 = 3485;
pub const Z_UTIL_DEC_3487: u32 = 3486;
pub const Z_UTIL_DEC_3488: u32 = 3487;
pub const Z_UTIL_DEC_3489: u32 = 3488;
pub const Z_UTIL_DEC_3490: u32 = 3489;
pub const Z_UTIL_DEC_3491: u32 = 3490;
pub const Z_UTIL_DEC_3492: u32 = 3491;
pub const Z_UTIL_DEC_3493: u32 = 3492;
pub const Z_UTIL_DEC_3494: u32 = 3493;
pub const Z_UTIL_DEC_3495: u32 = 3494;
pub const Z_UTIL_DEC_3496: u32 = 3495;
pub const Z_UTIL_DEC_3497: u32 = 3496;
pub const Z_UTIL_DEC_3498: u32 = 3497;
pub const Z_UTIL_DEC_3499: u32 = 3498;
pub const Z_UTIL_DEC_3500: u32 = 3499;
pub const Z_UTIL_DEC_3501: u32 = 3500;
pub const Z_UTIL_DEC_3502: u32 = 3501;
pub const Z_UTIL_DEC_3503: u32 = 3502;
pub const Z_UTIL_DEC_3504: u32 = 3503;
pub const Z_UTIL_DEC_3505: u32 = 3504;
pub const Z_UTIL_DEC_3506: u32 = 3505;
pub const Z_UTIL_DEC_3507: u32 = 3506;
pub const Z_UTIL_DEC_3508: u32 = 3507;
pub const Z_UTIL_DEC_3509: u32 = 3508;
pub const Z_UTIL_DEC_3510: u32 = 3509;
pub const Z_UTIL_DEC_3511: u32 = 3510;
pub const Z_UTIL_DEC_3512: u32 = 3511;
pub const Z_UTIL_DEC_3513: u32 = 3512;
pub const Z_UTIL_DEC_3514: u32 = 3513;
pub const Z_UTIL_DEC_3515: u32 = 3514;
pub const Z_UTIL_DEC_3516: u32 = 3515;
pub const Z_UTIL_DEC_3517: u32 = 3516;
pub const Z_UTIL_DEC_3518: u32 = 3517;
pub const Z_UTIL_DEC_3519: u32 = 3518;
pub const Z_UTIL_DEC_3520: u32 = 3519;
pub const Z_UTIL_DEC_3521: u32 = 3520;
pub const Z_UTIL_DEC_3522: u32 = 3521;
pub const Z_UTIL_DEC_3523: u32 = 3522;
pub const Z_UTIL_DEC_3524: u32 = 3523;
pub const Z_UTIL_DEC_3525: u32 = 3524;
pub const Z_UTIL_DEC_3526: u32 = 3525;
pub const Z_UTIL_DEC_3527: u32 = 3526;
pub const Z_UTIL_DEC_3528: u32 = 3527;
pub const Z_UTIL_DEC_3529: u32 = 3528;
pub const Z_UTIL_DEC_3530: u32 = 3529;
pub const Z_UTIL_DEC_3531: u32 = 3530;
pub const Z_UTIL_DEC_3532: u32 = 3531;
pub const Z_UTIL_DEC_3533: u32 = 3532;
pub const Z_UTIL_DEC_3534: u32 = 3533;
pub const Z_UTIL_DEC_3535: u32 = 3534;
pub const Z_UTIL_DEC_3536: u32 = 3535;
pub const Z_UTIL_DEC_3537: u32 = 3536;
pub const Z_UTIL_DEC_3538: u32 = 3537;
pub const Z_UTIL_DEC_3539: u32 = 3538;
pub const Z_UTIL_DEC_3540: u32 = 3539;
pub const Z_UTIL_DEC_3541: u32 = 3540;
pub const Z_UTIL_DEC_3542: u32 = 3541;
pub const Z_UTIL_DEC_3543: u32 = 3542;
pub const Z_UTIL_DEC_3544: u32 = 3543;
pub const Z_UTIL_DEC_3545: u32 = 3544;
pub const Z_UTIL_DEC_3546: u32 = 3545;
pub const Z_UTIL_DEC_3547: u32 = 3546;
pub const Z_UTIL_DEC_3548: u32 = 3547;
pub const Z_UTIL_DEC_3549: u32 = 3548;
pub const Z_UTIL_DEC_3550: u32 = 3549;
pub const Z_UTIL_DEC_3551: u32 = 3550;
pub const Z_UTIL_DEC_3552: u32 = 3551;
pub const Z_UTIL_DEC_3553: u32 = 3552;
pub const Z_UTIL_DEC_3554: u32 = 3553;
pub const Z_UTIL_DEC_3555: u32 = 3554;
pub const Z_UTIL_DEC_3556: u32 = 3555;
pub const Z_UTIL_DEC_3557: u32 = 3556;
pub const Z_UTIL_DEC_3558: u32 = 3557;
pub const Z_UTIL_DEC_3559: u32 = 3558;
pub const Z_UTIL_DEC_3560: u32 = 3559;
pub const Z_UTIL_DEC_3561: u32 = 3560;
pub const Z_UTIL_DEC_3562: u32 = 3561;
pub const Z_UTIL_DEC_3563: u32 = 3562;
pub const Z_UTIL_DEC_3564: u32 = 3563;
pub const Z_UTIL_DEC_3565: u32 = 3564;
pub const Z_UTIL_DEC_3566: u32 = 3565;
pub const Z_UTIL_DEC_3567: u32 = 3566;
pub const Z_UTIL_DEC_3568: u32 = 3567;
pub const Z_UTIL_DEC_3569: u32 = 3568;
pub const Z_UTIL_DEC_3570: u32 = 3569;
pub const Z_UTIL_DEC_3571: u32 = 3570;
pub const Z_UTIL_DEC_3572: u32 = 3571;
pub const Z_UTIL_DEC_3573: u32 = 3572;
pub const Z_UTIL_DEC_3574: u32 = 3573;
pub const Z_UTIL_DEC_3575: u32 = 3574;
pub const Z_UTIL_DEC_3576: u32 = 3575;
pub const Z_UTIL_DEC_3577: u32 = 3576;
pub const Z_UTIL_DEC_3578: u32 = 3577;
pub const Z_UTIL_DEC_3579: u32 = 3578;
pub const Z_UTIL_DEC_3580: u32 = 3579;
pub const Z_UTIL_DEC_3581: u32 = 3580;
pub const Z_UTIL_DEC_3582: u32 = 3581;
pub const Z_UTIL_DEC_3583: u32 = 3582;
pub const Z_UTIL_DEC_3584: u32 = 3583;
pub const Z_UTIL_DEC_3585: u32 = 3584;
pub const Z_UTIL_DEC_3586: u32 = 3585;
pub const Z_UTIL_DEC_3587: u32 = 3586;
pub const Z_UTIL_DEC_3588: u32 = 3587;
pub const Z_UTIL_DEC_3589: u32 = 3588;
pub const Z_UTIL_DEC_3590: u32 = 3589;
pub const Z_UTIL_DEC_3591: u32 = 3590;
pub const Z_UTIL_DEC_3592: u32 = 3591;
pub const Z_UTIL_DEC_3593: u32 = 3592;
pub const Z_UTIL_DEC_3594: u32 = 3593;
pub const Z_UTIL_DEC_3595: u32 = 3594;
pub const Z_UTIL_DEC_3596: u32 = 3595;
pub const Z_UTIL_DEC_3597: u32 = 3596;
pub const Z_UTIL_DEC_3598: u32 = 3597;
pub const Z_UTIL_DEC_3599: u32 = 3598;
pub const Z_UTIL_DEC_3600: u32 = 3599;
pub const Z_UTIL_DEC_3601: u32 = 3600;
pub const Z_UTIL_DEC_3602: u32 = 3601;
pub const Z_UTIL_DEC_3603: u32 = 3602;
pub const Z_UTIL_DEC_3604: u32 = 3603;
pub const Z_UTIL_DEC_3605: u32 = 3604;
pub const Z_UTIL_DEC_3606: u32 = 3605;
pub const Z_UTIL_DEC_3607: u32 = 3606;
pub const Z_UTIL_DEC_3608: u32 = 3607;
pub const Z_UTIL_DEC_3609: u32 = 3608;
pub const Z_UTIL_DEC_3610: u32 = 3609;
pub const Z_UTIL_DEC_3611: u32 = 3610;
pub const Z_UTIL_DEC_3612: u32 = 3611;
pub const Z_UTIL_DEC_3613: u32 = 3612;
pub const Z_UTIL_DEC_3614: u32 = 3613;
pub const Z_UTIL_DEC_3615: u32 = 3614;
pub const Z_UTIL_DEC_3616: u32 = 3615;
pub const Z_UTIL_DEC_3617: u32 = 3616;
pub const Z_UTIL_DEC_3618: u32 = 3617;
pub const Z_UTIL_DEC_3619: u32 = 3618;
pub const Z_UTIL_DEC_3620: u32 = 3619;
pub const Z_UTIL_DEC_3621: u32 = 3620;
pub const Z_UTIL_DEC_3622: u32 = 3621;
pub const Z_UTIL_DEC_3623: u32 = 3622;
pub const Z_UTIL_DEC_3624: u32 = 3623;
pub const Z_UTIL_DEC_3625: u32 = 3624;
pub const Z_UTIL_DEC_3626: u32 = 3625;
pub const Z_UTIL_DEC_3627: u32 = 3626;
pub const Z_UTIL_DEC_3628: u32 = 3627;
pub const Z_UTIL_DEC_3629: u32 = 3628;
pub const Z_UTIL_DEC_3630: u32 = 3629;
pub const Z_UTIL_DEC_3631: u32 = 3630;
pub const Z_UTIL_DEC_3632: u32 = 3631;
pub const Z_UTIL_DEC_3633: u32 = 3632;
pub const Z_UTIL_DEC_3634: u32 = 3633;
pub const Z_UTIL_DEC_3635: u32 = 3634;
pub const Z_UTIL_DEC_3636: u32 = 3635;
pub const Z_UTIL_DEC_3637: u32 = 3636;
pub const Z_UTIL_DEC_3638: u32 = 3637;
pub const Z_UTIL_DEC_3639: u32 = 3638;
pub const Z_UTIL_DEC_3640: u32 = 3639;
pub const Z_UTIL_DEC_3641: u32 = 3640;
pub const Z_UTIL_DEC_3642: u32 = 3641;
pub const Z_UTIL_DEC_3643: u32 = 3642;
pub const Z_UTIL_DEC_3644: u32 = 3643;
pub const Z_UTIL_DEC_3645: u32 = 3644;
pub const Z_UTIL_DEC_3646: u32 = 3645;
pub const Z_UTIL_DEC_3647: u32 = 3646;
pub const Z_UTIL_DEC_3648: u32 = 3647;
pub const Z_UTIL_DEC_3649: u32 = 3648;
pub const Z_UTIL_DEC_3650: u32 = 3649;
pub const Z_UTIL_DEC_3651: u32 = 3650;
pub const Z_UTIL_DEC_3652: u32 = 3651;
pub const Z_UTIL_DEC_3653: u32 = 3652;
pub const Z_UTIL_DEC_3654: u32 = 3653;
pub const Z_UTIL_DEC_3655: u32 = 3654;
pub const Z_UTIL_DEC_3656: u32 = 3655;
pub const Z_UTIL_DEC_3657: u32 = 3656;
pub const Z_UTIL_DEC_3658: u32 = 3657;
pub const Z_UTIL_DEC_3659: u32 = 3658;
pub const Z_UTIL_DEC_3660: u32 = 3659;
pub const Z_UTIL_DEC_3661: u32 = 3660;
pub const Z_UTIL_DEC_3662: u32 = 3661;
pub const Z_UTIL_DEC_3663: u32 = 3662;
pub const Z_UTIL_DEC_3664: u32 = 3663;
pub const Z_UTIL_DEC_3665: u32 = 3664;
pub const Z_UTIL_DEC_3666: u32 = 3665;
pub const Z_UTIL_DEC_3667: u32 = 3666;
pub const Z_UTIL_DEC_3668: u32 = 3667;
pub const Z_UTIL_DEC_3669: u32 = 3668;
pub const Z_UTIL_DEC_3670: u32 = 3669;
pub const Z_UTIL_DEC_3671: u32 = 3670;
pub const Z_UTIL_DEC_3672: u32 = 3671;
pub const Z_UTIL_DEC_3673: u32 = 3672;
pub const Z_UTIL_DEC_3674: u32 = 3673;
pub const Z_UTIL_DEC_3675: u32 = 3674;
pub const Z_UTIL_DEC_3676: u32 = 3675;
pub const Z_UTIL_DEC_3677: u32 = 3676;
pub const Z_UTIL_DEC_3678: u32 = 3677;
pub const Z_UTIL_DEC_3679: u32 = 3678;
pub const Z_UTIL_DEC_3680: u32 = 3679;
pub const Z_UTIL_DEC_3681: u32 = 3680;
pub const Z_UTIL_DEC_3682: u32 = 3681;
pub const Z_UTIL_DEC_3683: u32 = 3682;
pub const Z_UTIL_DEC_3684: u32 = 3683;
pub const Z_UTIL_DEC_3685: u32 = 3684;
pub const Z_UTIL_DEC_3686: u32 = 3685;
pub const Z_UTIL_DEC_3687: u32 = 3686;
pub const Z_UTIL_DEC_3688: u32 = 3687;
pub const Z_UTIL_DEC_3689: u32 = 3688;
pub const Z_UTIL_DEC_3690: u32 = 3689;
pub const Z_UTIL_DEC_3691: u32 = 3690;
pub const Z_UTIL_DEC_3692: u32 = 3691;
pub const Z_UTIL_DEC_3693: u32 = 3692;
pub const Z_UTIL_DEC_3694: u32 = 3693;
pub const Z_UTIL_DEC_3695: u32 = 3694;
pub const Z_UTIL_DEC_3696: u32 = 3695;
pub const Z_UTIL_DEC_3697: u32 = 3696;
pub const Z_UTIL_DEC_3698: u32 = 3697;
pub const Z_UTIL_DEC_3699: u32 = 3698;
pub const Z_UTIL_DEC_3700: u32 = 3699;
pub const Z_UTIL_DEC_3701: u32 = 3700;
pub const Z_UTIL_DEC_3702: u32 = 3701;
pub const Z_UTIL_DEC_3703: u32 = 3702;
pub const Z_UTIL_DEC_3704: u32 = 3703;
pub const Z_UTIL_DEC_3705: u32 = 3704;
pub const Z_UTIL_DEC_3706: u32 = 3705;
pub const Z_UTIL_DEC_3707: u32 = 3706;
pub const Z_UTIL_DEC_3708: u32 = 3707;
pub const Z_UTIL_DEC_3709: u32 = 3708;
pub const Z_UTIL_DEC_3710: u32 = 3709;
pub const Z_UTIL_DEC_3711: u32 = 3710;
pub const Z_UTIL_DEC_3712: u32 = 3711;
pub const Z_UTIL_DEC_3713: u32 = 3712;
pub const Z_UTIL_DEC_3714: u32 = 3713;
pub const Z_UTIL_DEC_3715: u32 = 3714;
pub const Z_UTIL_DEC_3716: u32 = 3715;
pub const Z_UTIL_DEC_3717: u32 = 3716;
pub const Z_UTIL_DEC_3718: u32 = 3717;
pub const Z_UTIL_DEC_3719: u32 = 3718;
pub const Z_UTIL_DEC_3720: u32 = 3719;
pub const Z_UTIL_DEC_3721: u32 = 3720;
pub const Z_UTIL_DEC_3722: u32 = 3721;
pub const Z_UTIL_DEC_3723: u32 = 3722;
pub const Z_UTIL_DEC_3724: u32 = 3723;
pub const Z_UTIL_DEC_3725: u32 = 3724;
pub const Z_UTIL_DEC_3726: u32 = 3725;
pub const Z_UTIL_DEC_3727: u32 = 3726;
pub const Z_UTIL_DEC_3728: u32 = 3727;
pub const Z_UTIL_DEC_3729: u32 = 3728;
pub const Z_UTIL_DEC_3730: u32 = 3729;
pub const Z_UTIL_DEC_3731: u32 = 3730;
pub const Z_UTIL_DEC_3732: u32 = 3731;
pub const Z_UTIL_DEC_3733: u32 = 3732;
pub const Z_UTIL_DEC_3734: u32 = 3733;
pub const Z_UTIL_DEC_3735: u32 = 3734;
pub const Z_UTIL_DEC_3736: u32 = 3735;
pub const Z_UTIL_DEC_3737: u32 = 3736;
pub const Z_UTIL_DEC_3738: u32 = 3737;
pub const Z_UTIL_DEC_3739: u32 = 3738;
pub const Z_UTIL_DEC_3740: u32 = 3739;
pub const Z_UTIL_DEC_3741: u32 = 3740;
pub const Z_UTIL_DEC_3742: u32 = 3741;
pub const Z_UTIL_DEC_3743: u32 = 3742;
pub const Z_UTIL_DEC_3744: u32 = 3743;
pub const Z_UTIL_DEC_3745: u32 = 3744;
pub const Z_UTIL_DEC_3746: u32 = 3745;
pub const Z_UTIL_DEC_3747: u32 = 3746;
pub const Z_UTIL_DEC_3748: u32 = 3747;
pub const Z_UTIL_DEC_3749: u32 = 3748;
pub const Z_UTIL_DEC_3750: u32 = 3749;
pub const Z_UTIL_DEC_3751: u32 = 3750;
pub const Z_UTIL_DEC_3752: u32 = 3751;
pub const Z_UTIL_DEC_3753: u32 = 3752;
pub const Z_UTIL_DEC_3754: u32 = 3753;
pub const Z_UTIL_DEC_3755: u32 = 3754;
pub const Z_UTIL_DEC_3756: u32 = 3755;
pub const Z_UTIL_DEC_3757: u32 = 3756;
pub const Z_UTIL_DEC_3758: u32 = 3757;
pub const Z_UTIL_DEC_3759: u32 = 3758;
pub const Z_UTIL_DEC_3760: u32 = 3759;
pub const Z_UTIL_DEC_3761: u32 = 3760;
pub const Z_UTIL_DEC_3762: u32 = 3761;
pub const Z_UTIL_DEC_3763: u32 = 3762;
pub const Z_UTIL_DEC_3764: u32 = 3763;
pub const Z_UTIL_DEC_3765: u32 = 3764;
pub const Z_UTIL_DEC_3766: u32 = 3765;
pub const Z_UTIL_DEC_3767: u32 = 3766;
pub const Z_UTIL_DEC_3768: u32 = 3767;
pub const Z_UTIL_DEC_3769: u32 = 3768;
pub const Z_UTIL_DEC_3770: u32 = 3769;
pub const Z_UTIL_DEC_3771: u32 = 3770;
pub const Z_UTIL_DEC_3772: u32 = 3771;
pub const Z_UTIL_DEC_3773: u32 = 3772;
pub const Z_UTIL_DEC_3774: u32 = 3773;
pub const Z_UTIL_DEC_3775: u32 = 3774;
pub const Z_UTIL_DEC_3776: u32 = 3775;
pub const Z_UTIL_DEC_3777: u32 = 3776;
pub const Z_UTIL_DEC_3778: u32 = 3777;
pub const Z_UTIL_DEC_3779: u32 = 3778;
pub const Z_UTIL_DEC_3780: u32 = 3779;
pub const Z_UTIL_DEC_3781: u32 = 3780;
pub const Z_UTIL_DEC_3782: u32 = 3781;
pub const Z_UTIL_DEC_3783: u32 = 3782;
pub const Z_UTIL_DEC_3784: u32 = 3783;
pub const Z_UTIL_DEC_3785: u32 = 3784;
pub const Z_UTIL_DEC_3786: u32 = 3785;
pub const Z_UTIL_DEC_3787: u32 = 3786;
pub const Z_UTIL_DEC_3788: u32 = 3787;
pub const Z_UTIL_DEC_3789: u32 = 3788;
pub const Z_UTIL_DEC_3790: u32 = 3789;
pub const Z_UTIL_DEC_3791: u32 = 3790;
pub const Z_UTIL_DEC_3792: u32 = 3791;
pub const Z_UTIL_DEC_3793: u32 = 3792;
pub const Z_UTIL_DEC_3794: u32 = 3793;
pub const Z_UTIL_DEC_3795: u32 = 3794;
pub const Z_UTIL_DEC_3796: u32 = 3795;
pub const Z_UTIL_DEC_3797: u32 = 3796;
pub const Z_UTIL_DEC_3798: u32 = 3797;
pub const Z_UTIL_DEC_3799: u32 = 3798;
pub const Z_UTIL_DEC_3800: u32 = 3799;
pub const Z_UTIL_DEC_3801: u32 = 3800;
pub const Z_UTIL_DEC_3802: u32 = 3801;
pub const Z_UTIL_DEC_3803: u32 = 3802;
pub const Z_UTIL_DEC_3804: u32 = 3803;
pub const Z_UTIL_DEC_3805: u32 = 3804;
pub const Z_UTIL_DEC_3806: u32 = 3805;
pub const Z_UTIL_DEC_3807: u32 = 3806;
pub const Z_UTIL_DEC_3808: u32 = 3807;
pub const Z_UTIL_DEC_3809: u32 = 3808;
pub const Z_UTIL_DEC_3810: u32 = 3809;
pub const Z_UTIL_DEC_3811: u32 = 3810;
pub const Z_UTIL_DEC_3812: u32 = 3811;
pub const Z_UTIL_DEC_3813: u32 = 3812;
pub const Z_UTIL_DEC_3814: u32 = 3813;
pub const Z_UTIL_DEC_3815: u32 = 3814;
pub const Z_UTIL_DEC_3816: u32 = 3815;
pub const Z_UTIL_DEC_3817: u32 = 3816;
pub const Z_UTIL_DEC_3818: u32 = 3817;
pub const Z_UTIL_DEC_3819: u32 = 3818;
pub const Z_UTIL_DEC_3820: u32 = 3819;
pub const Z_UTIL_DEC_3821: u32 = 3820;
pub const Z_UTIL_DEC_3822: u32 = 3821;
pub const Z_UTIL_DEC_3823: u32 = 3822;
pub const Z_UTIL_DEC_3824: u32 = 3823;
pub const Z_UTIL_DEC_3825: u32 = 3824;
pub const Z_UTIL_DEC_3826: u32 = 3825;
pub const Z_UTIL_DEC_3827: u32 = 3826;
pub const Z_UTIL_DEC_3828: u32 = 3827;
pub const Z_UTIL_DEC_3829: u32 = 3828;
pub const Z_UTIL_DEC_3830: u32 = 3829;
pub const Z_UTIL_DEC_3831: u32 = 3830;
pub const Z_UTIL_DEC_3832: u32 = 3831;
pub const Z_UTIL_DEC_3833: u32 = 3832;
pub const Z_UTIL_DEC_3834: u32 = 3833;
pub const Z_UTIL_DEC_3835: u32 = 3834;
pub const Z_UTIL_DEC_3836: u32 = 3835;
pub const Z_UTIL_DEC_3837: u32 = 3836;
pub const Z_UTIL_DEC_3838: u32 = 3837;
pub const Z_UTIL_DEC_3839: u32 = 3838;
pub const Z_UTIL_DEC_3840: u32 = 3839;
pub const Z_UTIL_DEC_3841: u32 = 3840;
pub const Z_UTIL_DEC_3842: u32 = 3841;
pub const Z_UTIL_DEC_3843: u32 = 3842;
pub const Z_UTIL_DEC_3844: u32 = 3843;
pub const Z_UTIL_DEC_3845: u32 = 3844;
pub const Z_UTIL_DEC_3846: u32 = 3845;
pub const Z_UTIL_DEC_3847: u32 = 3846;
pub const Z_UTIL_DEC_3848: u32 = 3847;
pub const Z_UTIL_DEC_3849: u32 = 3848;
pub const Z_UTIL_DEC_3850: u32 = 3849;
pub const Z_UTIL_DEC_3851: u32 = 3850;
pub const Z_UTIL_DEC_3852: u32 = 3851;
pub const Z_UTIL_DEC_3853: u32 = 3852;
pub const Z_UTIL_DEC_3854: u32 = 3853;
pub const Z_UTIL_DEC_3855: u32 = 3854;
pub const Z_UTIL_DEC_3856: u32 = 3855;
pub const Z_UTIL_DEC_3857: u32 = 3856;
pub const Z_UTIL_DEC_3858: u32 = 3857;
pub const Z_UTIL_DEC_3859: u32 = 3858;
pub const Z_UTIL_DEC_3860: u32 = 3859;
pub const Z_UTIL_DEC_3861: u32 = 3860;
pub const Z_UTIL_DEC_3862: u32 = 3861;
pub const Z_UTIL_DEC_3863: u32 = 3862;
pub const Z_UTIL_DEC_3864: u32 = 3863;
pub const Z_UTIL_DEC_3865: u32 = 3864;
pub const Z_UTIL_DEC_3866: u32 = 3865;
pub const Z_UTIL_DEC_3867: u32 = 3866;
pub const Z_UTIL_DEC_3868: u32 = 3867;
pub const Z_UTIL_DEC_3869: u32 = 3868;
pub const Z_UTIL_DEC_3870: u32 = 3869;
pub const Z_UTIL_DEC_3871: u32 = 3870;
pub const Z_UTIL_DEC_3872: u32 = 3871;
pub const Z_UTIL_DEC_3873: u32 = 3872;
pub const Z_UTIL_DEC_3874: u32 = 3873;
pub const Z_UTIL_DEC_3875: u32 = 3874;
pub const Z_UTIL_DEC_3876: u32 = 3875;
pub const Z_UTIL_DEC_3877: u32 = 3876;
pub const Z_UTIL_DEC_3878: u32 = 3877;
pub const Z_UTIL_DEC_3879: u32 = 3878;
pub const Z_UTIL_DEC_3880: u32 = 3879;
pub const Z_UTIL_DEC_3881: u32 = 3880;
pub const Z_UTIL_DEC_3882: u32 = 3881;
pub const Z_UTIL_DEC_3883: u32 = 3882;
pub const Z_UTIL_DEC_3884: u32 = 3883;
pub const Z_UTIL_DEC_3885: u32 = 3884;
pub const Z_UTIL_DEC_3886: u32 = 3885;
pub const Z_UTIL_DEC_3887: u32 = 3886;
pub const Z_UTIL_DEC_3888: u32 = 3887;
pub const Z_UTIL_DEC_3889: u32 = 3888;
pub const Z_UTIL_DEC_3890: u32 = 3889;
pub const Z_UTIL_DEC_3891: u32 = 3890;
pub const Z_UTIL_DEC_3892: u32 = 3891;
pub const Z_UTIL_DEC_3893: u32 = 3892;
pub const Z_UTIL_DEC_3894: u32 = 3893;
pub const Z_UTIL_DEC_3895: u32 = 3894;
pub const Z_UTIL_DEC_3896: u32 = 3895;
pub const Z_UTIL_DEC_3897: u32 = 3896;
pub const Z_UTIL_DEC_3898: u32 = 3897;
pub const Z_UTIL_DEC_3899: u32 = 3898;
pub const Z_UTIL_DEC_3900: u32 = 3899;
pub const Z_UTIL_DEC_3901: u32 = 3900;
pub const Z_UTIL_DEC_3902: u32 = 3901;
pub const Z_UTIL_DEC_3903: u32 = 3902;
pub const Z_UTIL_DEC_3904: u32 = 3903;
pub const Z_UTIL_DEC_3905: u32 = 3904;
pub const Z_UTIL_DEC_3906: u32 = 3905;
pub const Z_UTIL_DEC_3907: u32 = 3906;
pub const Z_UTIL_DEC_3908: u32 = 3907;
pub const Z_UTIL_DEC_3909: u32 = 3908;
pub const Z_UTIL_DEC_3910: u32 = 3909;
pub const Z_UTIL_DEC_3911: u32 = 3910;
pub const Z_UTIL_DEC_3912: u32 = 3911;
pub const Z_UTIL_DEC_3913: u32 = 3912;
pub const Z_UTIL_DEC_3914: u32 = 3913;
pub const Z_UTIL_DEC_3915: u32 = 3914;
pub const Z_UTIL_DEC_3916: u32 = 3915;
pub const Z_UTIL_DEC_3917: u32 = 3916;
pub const Z_UTIL_DEC_3918: u32 = 3917;
pub const Z_UTIL_DEC_3919: u32 = 3918;
pub const Z_UTIL_DEC_3920: u32 = 3919;
pub const Z_UTIL_DEC_3921: u32 = 3920;
pub const Z_UTIL_DEC_3922: u32 = 3921;
pub const Z_UTIL_DEC_3923: u32 = 3922;
pub const Z_UTIL_DEC_3924: u32 = 3923;
pub const Z_UTIL_DEC_3925: u32 = 3924;
pub const Z_UTIL_DEC_3926: u32 = 3925;
pub const Z_UTIL_DEC_3927: u32 = 3926;
pub const Z_UTIL_DEC_3928: u32 = 3927;
pub const Z_UTIL_DEC_3929: u32 = 3928;
pub const Z_UTIL_DEC_3930: u32 = 3929;
pub const Z_UTIL_DEC_3931: u32 = 3930;
pub const Z_UTIL_DEC_3932: u32 = 3931;
pub const Z_UTIL_DEC_3933: u32 = 3932;
pub const Z_UTIL_DEC_3934: u32 = 3933;
pub const Z_UTIL_DEC_3935: u32 = 3934;
pub const Z_UTIL_DEC_3936: u32 = 3935;
pub const Z_UTIL_DEC_3937: u32 = 3936;
pub const Z_UTIL_DEC_3938: u32 = 3937;
pub const Z_UTIL_DEC_3939: u32 = 3938;
pub const Z_UTIL_DEC_3940: u32 = 3939;
pub const Z_UTIL_DEC_3941: u32 = 3940;
pub const Z_UTIL_DEC_3942: u32 = 3941;
pub const Z_UTIL_DEC_3943: u32 = 3942;
pub const Z_UTIL_DEC_3944: u32 = 3943;
pub const Z_UTIL_DEC_3945: u32 = 3944;
pub const Z_UTIL_DEC_3946: u32 = 3945;
pub const Z_UTIL_DEC_3947: u32 = 3946;
pub const Z_UTIL_DEC_3948: u32 = 3947;
pub const Z_UTIL_DEC_3949: u32 = 3948;
pub const Z_UTIL_DEC_3950: u32 = 3949;
pub const Z_UTIL_DEC_3951: u32 = 3950;
pub const Z_UTIL_DEC_3952: u32 = 3951;
pub const Z_UTIL_DEC_3953: u32 = 3952;
pub const Z_UTIL_DEC_3954: u32 = 3953;
pub const Z_UTIL_DEC_3955: u32 = 3954;
pub const Z_UTIL_DEC_3956: u32 = 3955;
pub const Z_UTIL_DEC_3957: u32 = 3956;
pub const Z_UTIL_DEC_3958: u32 = 3957;
pub const Z_UTIL_DEC_3959: u32 = 3958;
pub const Z_UTIL_DEC_3960: u32 = 3959;
pub const Z_UTIL_DEC_3961: u32 = 3960;
pub const Z_UTIL_DEC_3962: u32 = 3961;
pub const Z_UTIL_DEC_3963: u32 = 3962;
pub const Z_UTIL_DEC_3964: u32 = 3963;
pub const Z_UTIL_DEC_3965: u32 = 3964;
pub const Z_UTIL_DEC_3966: u32 = 3965;
pub const Z_UTIL_DEC_3967: u32 = 3966;
pub const Z_UTIL_DEC_3968: u32 = 3967;
pub const Z_UTIL_DEC_3969: u32 = 3968;
pub const Z_UTIL_DEC_3970: u32 = 3969;
pub const Z_UTIL_DEC_3971: u32 = 3970;
pub const Z_UTIL_DEC_3972: u32 = 3971;
pub const Z_UTIL_DEC_3973: u32 = 3972;
pub const Z_UTIL_DEC_3974: u32 = 3973;
pub const Z_UTIL_DEC_3975: u32 = 3974;
pub const Z_UTIL_DEC_3976: u32 = 3975;
pub const Z_UTIL_DEC_3977: u32 = 3976;
pub const Z_UTIL_DEC_3978: u32 = 3977;
pub const Z_UTIL_DEC_3979: u32 = 3978;
pub const Z_UTIL_DEC_3980: u32 = 3979;
pub const Z_UTIL_DEC_3981: u32 = 3980;
pub const Z_UTIL_DEC_3982: u32 = 3981;
pub const Z_UTIL_DEC_3983: u32 = 3982;
pub const Z_UTIL_DEC_3984: u32 = 3983;
pub const Z_UTIL_DEC_3985: u32 = 3984;
pub const Z_UTIL_DEC_3986: u32 = 3985;
pub const Z_UTIL_DEC_3987: u32 = 3986;
pub const Z_UTIL_DEC_3988: u32 = 3987;
pub const Z_UTIL_DEC_3989: u32 = 3988;
pub const Z_UTIL_DEC_3990: u32 = 3989;
pub const Z_UTIL_DEC_3991: u32 = 3990;
pub const Z_UTIL_DEC_3992: u32 = 3991;
pub const Z_UTIL_DEC_3993: u32 = 3992;
pub const Z_UTIL_DEC_3994: u32 = 3993;
pub const Z_UTIL_DEC_3995: u32 = 3994;
pub const Z_UTIL_DEC_3996: u32 = 3995;
pub const Z_UTIL_DEC_3997: u32 = 3996;
pub const Z_UTIL_DEC_3998: u32 = 3997;
pub const Z_UTIL_DEC_3999: u32 = 3998;
pub const Z_UTIL_DEC_4000: u32 = 3999;
pub const Z_UTIL_DEC_4001: u32 = 4000;
pub const Z_UTIL_DEC_4002: u32 = 4001;
pub const Z_UTIL_DEC_4003: u32 = 4002;
pub const Z_UTIL_DEC_4004: u32 = 4003;
pub const Z_UTIL_DEC_4005: u32 = 4004;
pub const Z_UTIL_DEC_4006: u32 = 4005;
pub const Z_UTIL_DEC_4007: u32 = 4006;
pub const Z_UTIL_DEC_4008: u32 = 4007;
pub const Z_UTIL_DEC_4009: u32 = 4008;
pub const Z_UTIL_DEC_4010: u32 = 4009;
pub const Z_UTIL_DEC_4011: u32 = 4010;
pub const Z_UTIL_DEC_4012: u32 = 4011;
pub const Z_UTIL_DEC_4013: u32 = 4012;
pub const Z_UTIL_DEC_4014: u32 = 4013;
pub const Z_UTIL_DEC_4015: u32 = 4014;
pub const Z_UTIL_DEC_4016: u32 = 4015;
pub const Z_UTIL_DEC_4017: u32 = 4016;
pub const Z_UTIL_DEC_4018: u32 = 4017;
pub const Z_UTIL_DEC_4019: u32 = 4018;
pub const Z_UTIL_DEC_4020: u32 = 4019;
pub const Z_UTIL_DEC_4021: u32 = 4020;
pub const Z_UTIL_DEC_4022: u32 = 4021;
pub const Z_UTIL_DEC_4023: u32 = 4022;
pub const Z_UTIL_DEC_4024: u32 = 4023;
pub const Z_UTIL_DEC_4025: u32 = 4024;
pub const Z_UTIL_DEC_4026: u32 = 4025;
pub const Z_UTIL_DEC_4027: u32 = 4026;
pub const Z_UTIL_DEC_4028: u32 = 4027;
pub const Z_UTIL_DEC_4029: u32 = 4028;
pub const Z_UTIL_DEC_4030: u32 = 4029;
pub const Z_UTIL_DEC_4031: u32 = 4030;
pub const Z_UTIL_DEC_4032: u32 = 4031;
pub const Z_UTIL_DEC_4033: u32 = 4032;
pub const Z_UTIL_DEC_4034: u32 = 4033;
pub const Z_UTIL_DEC_4035: u32 = 4034;
pub const Z_UTIL_DEC_4036: u32 = 4035;
pub const Z_UTIL_DEC_4037: u32 = 4036;
pub const Z_UTIL_DEC_4038: u32 = 4037;
pub const Z_UTIL_DEC_4039: u32 = 4038;
pub const Z_UTIL_DEC_4040: u32 = 4039;
pub const Z_UTIL_DEC_4041: u32 = 4040;
pub const Z_UTIL_DEC_4042: u32 = 4041;
pub const Z_UTIL_DEC_4043: u32 = 4042;
pub const Z_UTIL_DEC_4044: u32 = 4043;
pub const Z_UTIL_DEC_4045: u32 = 4044;
pub const Z_UTIL_DEC_4046: u32 = 4045;
pub const Z_UTIL_DEC_4047: u32 = 4046;
pub const Z_UTIL_DEC_4048: u32 = 4047;
pub const Z_UTIL_DEC_4049: u32 = 4048;
pub const Z_UTIL_DEC_4050: u32 = 4049;
pub const Z_UTIL_DEC_4051: u32 = 4050;
pub const Z_UTIL_DEC_4052: u32 = 4051;
pub const Z_UTIL_DEC_4053: u32 = 4052;
pub const Z_UTIL_DEC_4054: u32 = 4053;
pub const Z_UTIL_DEC_4055: u32 = 4054;
pub const Z_UTIL_DEC_4056: u32 = 4055;
pub const Z_UTIL_DEC_4057: u32 = 4056;
pub const Z_UTIL_DEC_4058: u32 = 4057;
pub const Z_UTIL_DEC_4059: u32 = 4058;
pub const Z_UTIL_DEC_4060: u32 = 4059;
pub const Z_UTIL_DEC_4061: u32 = 4060;
pub const Z_UTIL_DEC_4062: u32 = 4061;
pub const Z_UTIL_DEC_4063: u32 = 4062;
pub const Z_UTIL_DEC_4064: u32 = 4063;
pub const Z_UTIL_DEC_4065: u32 = 4064;
pub const Z_UTIL_DEC_4066: u32 = 4065;
pub const Z_UTIL_DEC_4067: u32 = 4066;
pub const Z_UTIL_DEC_4068: u32 = 4067;
pub const Z_UTIL_DEC_4069: u32 = 4068;
pub const Z_UTIL_DEC_4070: u32 = 4069;
pub const Z_UTIL_DEC_4071: u32 = 4070;
pub const Z_UTIL_DEC_4072: u32 = 4071;
pub const Z_UTIL_DEC_4073: u32 = 4072;
pub const Z_UTIL_DEC_4074: u32 = 4073;
pub const Z_UTIL_DEC_4075: u32 = 4074;
pub const Z_UTIL_DEC_4076: u32 = 4075;
pub const Z_UTIL_DEC_4077: u32 = 4076;
pub const Z_UTIL_DEC_4078: u32 = 4077;
pub const Z_UTIL_DEC_4079: u32 = 4078;
pub const Z_UTIL_DEC_4080: u32 = 4079;
pub const Z_UTIL_DEC_4081: u32 = 4080;
pub const Z_UTIL_DEC_4082: u32 = 4081;
pub const Z_UTIL_DEC_4083: u32 = 4082;
pub const Z_UTIL_DEC_4084: u32 = 4083;
pub const Z_UTIL_DEC_4085: u32 = 4084;
pub const Z_UTIL_DEC_4086: u32 = 4085;
pub const Z_UTIL_DEC_4087: u32 = 4086;
pub const Z_UTIL_DEC_4088: u32 = 4087;
pub const Z_UTIL_DEC_4089: u32 = 4088;
pub const Z_UTIL_DEC_4090: u32 = 4089;
pub const Z_UTIL_DEC_4091: u32 = 4090;
pub const Z_UTIL_DEC_4092: u32 = 4091;
pub const Z_UTIL_DEC_4093: u32 = 4092;
pub const Z_UTIL_DEC_4094: u32 = 4093;
pub const Z_UTIL_DEC_4095: u32 = 4094;
pub const Z_UTIL_DEC_4096: u32 = 4095;
pub const Z_UTIL_X2_0: u32 = 0;
pub const Z_UTIL_X2_1: u32 = 2;
pub const Z_UTIL_X2_2: u32 = 4;
pub const Z_UTIL_X2_3: u32 = 6;
pub const Z_UTIL_X2_4: u32 = 8;
pub const Z_UTIL_X2_5: u32 = 10;
pub const Z_UTIL_X2_6: u32 = 12;
pub const Z_UTIL_X2_7: u32 = 14;
pub const Z_UTIL_X2_8: u32 = 16;
pub const Z_UTIL_X2_9: u32 = 18;
pub const Z_UTIL_X2_10: u32 = 20;
pub const Z_UTIL_X2_11: u32 = 22;
pub const Z_UTIL_X2_12: u32 = 24;
pub const Z_UTIL_X2_13: u32 = 26;
pub const Z_UTIL_X2_14: u32 = 28;
pub const Z_UTIL_X2_15: u32 = 30;
pub const Z_UTIL_X2_16: u32 = 32;
pub const Z_UTIL_X2_17: u32 = 34;
pub const Z_UTIL_X2_18: u32 = 36;
pub const Z_UTIL_X2_19: u32 = 38;
pub const Z_UTIL_X2_20: u32 = 40;
pub const Z_UTIL_X2_21: u32 = 42;
pub const Z_UTIL_X2_22: u32 = 44;
pub const Z_UTIL_X2_23: u32 = 46;
pub const Z_UTIL_X2_24: u32 = 48;
pub const Z_UTIL_X2_25: u32 = 50;
pub const Z_UTIL_X2_26: u32 = 52;
pub const Z_UTIL_X2_27: u32 = 54;
pub const Z_UTIL_X2_28: u32 = 56;
pub const Z_UTIL_X2_29: u32 = 58;
pub const Z_UTIL_X2_30: u32 = 60;
pub const Z_UTIL_X2_31: u32 = 62;
pub const Z_UTIL_X2_32: u32 = 64;
pub const Z_UTIL_X2_33: u32 = 66;
pub const Z_UTIL_X2_34: u32 = 68;
pub const Z_UTIL_X2_35: u32 = 70;
pub const Z_UTIL_X2_36: u32 = 72;
pub const Z_UTIL_X2_37: u32 = 74;
pub const Z_UTIL_X2_38: u32 = 76;
pub const Z_UTIL_X2_39: u32 = 78;
pub const Z_UTIL_X2_40: u32 = 80;
pub const Z_UTIL_X2_41: u32 = 82;
pub const Z_UTIL_X2_42: u32 = 84;
pub const Z_UTIL_X2_43: u32 = 86;
pub const Z_UTIL_X2_44: u32 = 88;
pub const Z_UTIL_X2_45: u32 = 90;
pub const Z_UTIL_X2_46: u32 = 92;
pub const Z_UTIL_X2_47: u32 = 94;
pub const Z_UTIL_X2_48: u32 = 96;
pub const Z_UTIL_X2_49: u32 = 98;
pub const Z_UTIL_X2_50: u32 = 100;
pub const Z_UTIL_X2_51: u32 = 102;
pub const Z_UTIL_X2_52: u32 = 104;
pub const Z_UTIL_X2_53: u32 = 106;
pub const Z_UTIL_X2_54: u32 = 108;
pub const Z_UTIL_X2_55: u32 = 110;
pub const Z_UTIL_X2_56: u32 = 112;
pub const Z_UTIL_X2_57: u32 = 114;
pub const Z_UTIL_X2_58: u32 = 116;
pub const Z_UTIL_X2_59: u32 = 118;
pub const Z_UTIL_X2_60: u32 = 120;
pub const Z_UTIL_X2_61: u32 = 122;
pub const Z_UTIL_X2_62: u32 = 124;
pub const Z_UTIL_X2_63: u32 = 126;
pub const Z_UTIL_X2_64: u32 = 128;
pub const Z_UTIL_X2_65: u32 = 130;
pub const Z_UTIL_X2_66: u32 = 132;
pub const Z_UTIL_X2_67: u32 = 134;
pub const Z_UTIL_X2_68: u32 = 136;
pub const Z_UTIL_X2_69: u32 = 138;
pub const Z_UTIL_X2_70: u32 = 140;
pub const Z_UTIL_X2_71: u32 = 142;
pub const Z_UTIL_X2_72: u32 = 144;
pub const Z_UTIL_X2_73: u32 = 146;
pub const Z_UTIL_X2_74: u32 = 148;
pub const Z_UTIL_X2_75: u32 = 150;
pub const Z_UTIL_X2_76: u32 = 152;
pub const Z_UTIL_X2_77: u32 = 154;
pub const Z_UTIL_X2_78: u32 = 156;
pub const Z_UTIL_X2_79: u32 = 158;
pub const Z_UTIL_X2_80: u32 = 160;
pub const Z_UTIL_X2_81: u32 = 162;
pub const Z_UTIL_X2_82: u32 = 164;
pub const Z_UTIL_X2_83: u32 = 166;
pub const Z_UTIL_X2_84: u32 = 168;
pub const Z_UTIL_X2_85: u32 = 170;
pub const Z_UTIL_X2_86: u32 = 172;
pub const Z_UTIL_X2_87: u32 = 174;
pub const Z_UTIL_X2_88: u32 = 176;
pub const Z_UTIL_X2_89: u32 = 178;
pub const Z_UTIL_X2_90: u32 = 180;
pub const Z_UTIL_X2_91: u32 = 182;
pub const Z_UTIL_X2_92: u32 = 184;
pub const Z_UTIL_X2_93: u32 = 186;
pub const Z_UTIL_X2_94: u32 = 188;
pub const Z_UTIL_X2_95: u32 = 190;
pub const Z_UTIL_X2_96: u32 = 192;
pub const Z_UTIL_X2_97: u32 = 194;
pub const Z_UTIL_X2_98: u32 = 196;
pub const Z_UTIL_X2_99: u32 = 198;
pub const Z_UTIL_X2_100: u32 = 200;
pub const Z_UTIL_X2_101: u32 = 202;
pub const Z_UTIL_X2_102: u32 = 204;
pub const Z_UTIL_X2_103: u32 = 206;
pub const Z_UTIL_X2_104: u32 = 208;
pub const Z_UTIL_X2_105: u32 = 210;
pub const Z_UTIL_X2_106: u32 = 212;
pub const Z_UTIL_X2_107: u32 = 214;
pub const Z_UTIL_X2_108: u32 = 216;
pub const Z_UTIL_X2_109: u32 = 218;
pub const Z_UTIL_X2_110: u32 = 220;
pub const Z_UTIL_X2_111: u32 = 222;
pub const Z_UTIL_X2_112: u32 = 224;
pub const Z_UTIL_X2_113: u32 = 226;
pub const Z_UTIL_X2_114: u32 = 228;
pub const Z_UTIL_X2_115: u32 = 230;
pub const Z_UTIL_X2_116: u32 = 232;
pub const Z_UTIL_X2_117: u32 = 234;
pub const Z_UTIL_X2_118: u32 = 236;
pub const Z_UTIL_X2_119: u32 = 238;
pub const Z_UTIL_X2_120: u32 = 240;
pub const Z_UTIL_X2_121: u32 = 242;
pub const Z_UTIL_X2_122: u32 = 244;
pub const Z_UTIL_X2_123: u32 = 246;
pub const Z_UTIL_X2_124: u32 = 248;
pub const Z_UTIL_X2_125: u32 = 250;
pub const Z_UTIL_X2_126: u32 = 252;
pub const Z_UTIL_X2_127: u32 = 254;
pub const Z_UTIL_X2_128: u32 = 256;
pub const Z_UTIL_X2_129: u32 = 258;
pub const Z_UTIL_X2_130: u32 = 260;
pub const Z_UTIL_X2_131: u32 = 262;
pub const Z_UTIL_X2_132: u32 = 264;
pub const Z_UTIL_X2_133: u32 = 266;
pub const Z_UTIL_X2_134: u32 = 268;
pub const Z_UTIL_X2_135: u32 = 270;
pub const Z_UTIL_X2_136: u32 = 272;
pub const Z_UTIL_X2_137: u32 = 274;
pub const Z_UTIL_X2_138: u32 = 276;
pub const Z_UTIL_X2_139: u32 = 278;
pub const Z_UTIL_X2_140: u32 = 280;
pub const Z_UTIL_X2_141: u32 = 282;
pub const Z_UTIL_X2_142: u32 = 284;
pub const Z_UTIL_X2_143: u32 = 286;
pub const Z_UTIL_X2_144: u32 = 288;
pub const Z_UTIL_X2_145: u32 = 290;
pub const Z_UTIL_X2_146: u32 = 292;
pub const Z_UTIL_X2_147: u32 = 294;
pub const Z_UTIL_X2_148: u32 = 296;
pub const Z_UTIL_X2_149: u32 = 298;
pub const Z_UTIL_X2_150: u32 = 300;
pub const Z_UTIL_X2_151: u32 = 302;
pub const Z_UTIL_X2_152: u32 = 304;
pub const Z_UTIL_X2_153: u32 = 306;
pub const Z_UTIL_X2_154: u32 = 308;
pub const Z_UTIL_X2_155: u32 = 310;
pub const Z_UTIL_X2_156: u32 = 312;
pub const Z_UTIL_X2_157: u32 = 314;
pub const Z_UTIL_X2_158: u32 = 316;
pub const Z_UTIL_X2_159: u32 = 318;
pub const Z_UTIL_X2_160: u32 = 320;
pub const Z_UTIL_X2_161: u32 = 322;
pub const Z_UTIL_X2_162: u32 = 324;
pub const Z_UTIL_X2_163: u32 = 326;
pub const Z_UTIL_X2_164: u32 = 328;
pub const Z_UTIL_X2_165: u32 = 330;
pub const Z_UTIL_X2_166: u32 = 332;
pub const Z_UTIL_X2_167: u32 = 334;
pub const Z_UTIL_X2_168: u32 = 336;
pub const Z_UTIL_X2_169: u32 = 338;
pub const Z_UTIL_X2_170: u32 = 340;
pub const Z_UTIL_X2_171: u32 = 342;
pub const Z_UTIL_X2_172: u32 = 344;
pub const Z_UTIL_X2_173: u32 = 346;
pub const Z_UTIL_X2_174: u32 = 348;
pub const Z_UTIL_X2_175: u32 = 350;
pub const Z_UTIL_X2_176: u32 = 352;
pub const Z_UTIL_X2_177: u32 = 354;
pub const Z_UTIL_X2_178: u32 = 356;
pub const Z_UTIL_X2_179: u32 = 358;
pub const Z_UTIL_X2_180: u32 = 360;
pub const Z_UTIL_X2_181: u32 = 362;
pub const Z_UTIL_X2_182: u32 = 364;
pub const Z_UTIL_X2_183: u32 = 366;
pub const Z_UTIL_X2_184: u32 = 368;
pub const Z_UTIL_X2_185: u32 = 370;
pub const Z_UTIL_X2_186: u32 = 372;
pub const Z_UTIL_X2_187: u32 = 374;
pub const Z_UTIL_X2_188: u32 = 376;
pub const Z_UTIL_X2_189: u32 = 378;
pub const Z_UTIL_X2_190: u32 = 380;
pub const Z_UTIL_X2_191: u32 = 382;
pub const Z_UTIL_X2_192: u32 = 384;
pub const Z_UTIL_X2_193: u32 = 386;
pub const Z_UTIL_X2_194: u32 = 388;
pub const Z_UTIL_X2_195: u32 = 390;
pub const Z_UTIL_X2_196: u32 = 392;
pub const Z_UTIL_X2_197: u32 = 394;
pub const Z_UTIL_X2_198: u32 = 396;
pub const Z_UTIL_X2_199: u32 = 398;
pub const Z_UTIL_X2_200: u32 = 400;
pub const Z_UTIL_X2_201: u32 = 402;
pub const Z_UTIL_X2_202: u32 = 404;
pub const Z_UTIL_X2_203: u32 = 406;
pub const Z_UTIL_X2_204: u32 = 408;
pub const Z_UTIL_X2_205: u32 = 410;
pub const Z_UTIL_X2_206: u32 = 412;
pub const Z_UTIL_X2_207: u32 = 414;
pub const Z_UTIL_X2_208: u32 = 416;
pub const Z_UTIL_X2_209: u32 = 418;
pub const Z_UTIL_X2_210: u32 = 420;
pub const Z_UTIL_X2_211: u32 = 422;
pub const Z_UTIL_X2_212: u32 = 424;
pub const Z_UTIL_X2_213: u32 = 426;
pub const Z_UTIL_X2_214: u32 = 428;
pub const Z_UTIL_X2_215: u32 = 430;
pub const Z_UTIL_X2_216: u32 = 432;
pub const Z_UTIL_X2_217: u32 = 434;
pub const Z_UTIL_X2_218: u32 = 436;
pub const Z_UTIL_X2_219: u32 = 438;
pub const Z_UTIL_X2_220: u32 = 440;
pub const Z_UTIL_X2_221: u32 = 442;
pub const Z_UTIL_X2_222: u32 = 444;
pub const Z_UTIL_X2_223: u32 = 446;
pub const Z_UTIL_X2_224: u32 = 448;
pub const Z_UTIL_X2_225: u32 = 450;
pub const Z_UTIL_X2_226: u32 = 452;
pub const Z_UTIL_X2_227: u32 = 454;
pub const Z_UTIL_X2_228: u32 = 456;
pub const Z_UTIL_X2_229: u32 = 458;
pub const Z_UTIL_X2_230: u32 = 460;
pub const Z_UTIL_X2_231: u32 = 462;
pub const Z_UTIL_X2_232: u32 = 464;
pub const Z_UTIL_X2_233: u32 = 466;
pub const Z_UTIL_X2_234: u32 = 468;
pub const Z_UTIL_X2_235: u32 = 470;
pub const Z_UTIL_X2_236: u32 = 472;
pub const Z_UTIL_X2_237: u32 = 474;
pub const Z_UTIL_X2_238: u32 = 476;
pub const Z_UTIL_X2_239: u32 = 478;
pub const Z_UTIL_X2_240: u32 = 480;
pub const Z_UTIL_X2_241: u32 = 482;
pub const Z_UTIL_X2_242: u32 = 484;
pub const Z_UTIL_X2_243: u32 = 486;
pub const Z_UTIL_X2_244: u32 = 488;
pub const Z_UTIL_X2_245: u32 = 490;
pub const Z_UTIL_X2_246: u32 = 492;
pub const Z_UTIL_X2_247: u32 = 494;
pub const Z_UTIL_X2_248: u32 = 496;
pub const Z_UTIL_X2_249: u32 = 498;
pub const Z_UTIL_X2_250: u32 = 500;
pub const Z_UTIL_X2_251: u32 = 502;
pub const Z_UTIL_X2_252: u32 = 504;
pub const Z_UTIL_X2_253: u32 = 506;
pub const Z_UTIL_X2_254: u32 = 508;
pub const Z_UTIL_X2_255: u32 = 510;
pub const Z_UTIL_X2_256: u32 = 512;
pub const Z_UTIL_X2_257: u32 = 514;
pub const Z_UTIL_X2_258: u32 = 516;
pub const Z_UTIL_X2_259: u32 = 518;
pub const Z_UTIL_X2_260: u32 = 520;
pub const Z_UTIL_X2_261: u32 = 522;
pub const Z_UTIL_X2_262: u32 = 524;
pub const Z_UTIL_X2_263: u32 = 526;
pub const Z_UTIL_X2_264: u32 = 528;
pub const Z_UTIL_X2_265: u32 = 530;
pub const Z_UTIL_X2_266: u32 = 532;
pub const Z_UTIL_X2_267: u32 = 534;
pub const Z_UTIL_X2_268: u32 = 536;
pub const Z_UTIL_X2_269: u32 = 538;
pub const Z_UTIL_X2_270: u32 = 540;
pub const Z_UTIL_X2_271: u32 = 542;
pub const Z_UTIL_X2_272: u32 = 544;
pub const Z_UTIL_X2_273: u32 = 546;
pub const Z_UTIL_X2_274: u32 = 548;
pub const Z_UTIL_X2_275: u32 = 550;
pub const Z_UTIL_X2_276: u32 = 552;
pub const Z_UTIL_X2_277: u32 = 554;
pub const Z_UTIL_X2_278: u32 = 556;
pub const Z_UTIL_X2_279: u32 = 558;
pub const Z_UTIL_X2_280: u32 = 560;
pub const Z_UTIL_X2_281: u32 = 562;
pub const Z_UTIL_X2_282: u32 = 564;
pub const Z_UTIL_X2_283: u32 = 566;
pub const Z_UTIL_X2_284: u32 = 568;
pub const Z_UTIL_X2_285: u32 = 570;
pub const Z_UTIL_X2_286: u32 = 572;
pub const Z_UTIL_X2_287: u32 = 574;
pub const Z_UTIL_X2_288: u32 = 576;
pub const Z_UTIL_X2_289: u32 = 578;
pub const Z_UTIL_X2_290: u32 = 580;
pub const Z_UTIL_X2_291: u32 = 582;
pub const Z_UTIL_X2_292: u32 = 584;
pub const Z_UTIL_X2_293: u32 = 586;
pub const Z_UTIL_X2_294: u32 = 588;
pub const Z_UTIL_X2_295: u32 = 590;
pub const Z_UTIL_X2_296: u32 = 592;
pub const Z_UTIL_X2_297: u32 = 594;
pub const Z_UTIL_X2_298: u32 = 596;
pub const Z_UTIL_X2_299: u32 = 598;
pub const Z_UTIL_X2_300: u32 = 600;
pub const Z_UTIL_X2_301: u32 = 602;
pub const Z_UTIL_X2_302: u32 = 604;
pub const Z_UTIL_X2_303: u32 = 606;
pub const Z_UTIL_X2_304: u32 = 608;
pub const Z_UTIL_X2_305: u32 = 610;
pub const Z_UTIL_X2_306: u32 = 612;
pub const Z_UTIL_X2_307: u32 = 614;
pub const Z_UTIL_X2_308: u32 = 616;
pub const Z_UTIL_X2_309: u32 = 618;
pub const Z_UTIL_X2_310: u32 = 620;
pub const Z_UTIL_X2_311: u32 = 622;
pub const Z_UTIL_X2_312: u32 = 624;
pub const Z_UTIL_X2_313: u32 = 626;
pub const Z_UTIL_X2_314: u32 = 628;
pub const Z_UTIL_X2_315: u32 = 630;
pub const Z_UTIL_X2_316: u32 = 632;
pub const Z_UTIL_X2_317: u32 = 634;
pub const Z_UTIL_X2_318: u32 = 636;
pub const Z_UTIL_X2_319: u32 = 638;
pub const Z_UTIL_X2_320: u32 = 640;
pub const Z_UTIL_X2_321: u32 = 642;
pub const Z_UTIL_X2_322: u32 = 644;
pub const Z_UTIL_X2_323: u32 = 646;
pub const Z_UTIL_X2_324: u32 = 648;
pub const Z_UTIL_X2_325: u32 = 650;
pub const Z_UTIL_X2_326: u32 = 652;
pub const Z_UTIL_X2_327: u32 = 654;
pub const Z_UTIL_X2_328: u32 = 656;
pub const Z_UTIL_X2_329: u32 = 658;
pub const Z_UTIL_X2_330: u32 = 660;
pub const Z_UTIL_X2_331: u32 = 662;
pub const Z_UTIL_X2_332: u32 = 664;
pub const Z_UTIL_X2_333: u32 = 666;
pub const Z_UTIL_X2_334: u32 = 668;
pub const Z_UTIL_X2_335: u32 = 670;
pub const Z_UTIL_X2_336: u32 = 672;
pub const Z_UTIL_X2_337: u32 = 674;
pub const Z_UTIL_X2_338: u32 = 676;
pub const Z_UTIL_X2_339: u32 = 678;
pub const Z_UTIL_X2_340: u32 = 680;
pub const Z_UTIL_X2_341: u32 = 682;
pub const Z_UTIL_X2_342: u32 = 684;
pub const Z_UTIL_X2_343: u32 = 686;
pub const Z_UTIL_X2_344: u32 = 688;
pub const Z_UTIL_X2_345: u32 = 690;
pub const Z_UTIL_X2_346: u32 = 692;
pub const Z_UTIL_X2_347: u32 = 694;
pub const Z_UTIL_X2_348: u32 = 696;
pub const Z_UTIL_X2_349: u32 = 698;
pub const Z_UTIL_X2_350: u32 = 700;
pub const Z_UTIL_X2_351: u32 = 702;
pub const Z_UTIL_X2_352: u32 = 704;
pub const Z_UTIL_X2_353: u32 = 706;
pub const Z_UTIL_X2_354: u32 = 708;
pub const Z_UTIL_X2_355: u32 = 710;
pub const Z_UTIL_X2_356: u32 = 712;
pub const Z_UTIL_X2_357: u32 = 714;
pub const Z_UTIL_X2_358: u32 = 716;
pub const Z_UTIL_X2_359: u32 = 718;
pub const Z_UTIL_X2_360: u32 = 720;
pub const Z_UTIL_X2_361: u32 = 722;
pub const Z_UTIL_X2_362: u32 = 724;
pub const Z_UTIL_X2_363: u32 = 726;
pub const Z_UTIL_X2_364: u32 = 728;
pub const Z_UTIL_X2_365: u32 = 730;
pub const Z_UTIL_X2_366: u32 = 732;
pub const Z_UTIL_X2_367: u32 = 734;
pub const Z_UTIL_X2_368: u32 = 736;
pub const Z_UTIL_X2_369: u32 = 738;
pub const Z_UTIL_X2_370: u32 = 740;
pub const Z_UTIL_X2_371: u32 = 742;
pub const Z_UTIL_X2_372: u32 = 744;
pub const Z_UTIL_X2_373: u32 = 746;
pub const Z_UTIL_X2_374: u32 = 748;
pub const Z_UTIL_X2_375: u32 = 750;
pub const Z_UTIL_X2_376: u32 = 752;
pub const Z_UTIL_X2_377: u32 = 754;
pub const Z_UTIL_X2_378: u32 = 756;
pub const Z_UTIL_X2_379: u32 = 758;
pub const Z_UTIL_X2_380: u32 = 760;
pub const Z_UTIL_X2_381: u32 = 762;
pub const Z_UTIL_X2_382: u32 = 764;
pub const Z_UTIL_X2_383: u32 = 766;
pub const Z_UTIL_X2_384: u32 = 768;
pub const Z_UTIL_X2_385: u32 = 770;
pub const Z_UTIL_X2_386: u32 = 772;
pub const Z_UTIL_X2_387: u32 = 774;
pub const Z_UTIL_X2_388: u32 = 776;
pub const Z_UTIL_X2_389: u32 = 778;
pub const Z_UTIL_X2_390: u32 = 780;
pub const Z_UTIL_X2_391: u32 = 782;
pub const Z_UTIL_X2_392: u32 = 784;
pub const Z_UTIL_X2_393: u32 = 786;
pub const Z_UTIL_X2_394: u32 = 788;
pub const Z_UTIL_X2_395: u32 = 790;
pub const Z_UTIL_X2_396: u32 = 792;
pub const Z_UTIL_X2_397: u32 = 794;
pub const Z_UTIL_X2_398: u32 = 796;
pub const Z_UTIL_X2_399: u32 = 798;
pub const Z_UTIL_X2_400: u32 = 800;
pub const Z_UTIL_X2_401: u32 = 802;
pub const Z_UTIL_X2_402: u32 = 804;
pub const Z_UTIL_X2_403: u32 = 806;
pub const Z_UTIL_X2_404: u32 = 808;
pub const Z_UTIL_X2_405: u32 = 810;
pub const Z_UTIL_X2_406: u32 = 812;
pub const Z_UTIL_X2_407: u32 = 814;
pub const Z_UTIL_X2_408: u32 = 816;
pub const Z_UTIL_X2_409: u32 = 818;
pub const Z_UTIL_X2_410: u32 = 820;
pub const Z_UTIL_X2_411: u32 = 822;
pub const Z_UTIL_X2_412: u32 = 824;
pub const Z_UTIL_X2_413: u32 = 826;
pub const Z_UTIL_X2_414: u32 = 828;
pub const Z_UTIL_X2_415: u32 = 830;
pub const Z_UTIL_X2_416: u32 = 832;
pub const Z_UTIL_X2_417: u32 = 834;
pub const Z_UTIL_X2_418: u32 = 836;
pub const Z_UTIL_X2_419: u32 = 838;
pub const Z_UTIL_X2_420: u32 = 840;
pub const Z_UTIL_X2_421: u32 = 842;
pub const Z_UTIL_X2_422: u32 = 844;
pub const Z_UTIL_X2_423: u32 = 846;
pub const Z_UTIL_X2_424: u32 = 848;
pub const Z_UTIL_X2_425: u32 = 850;
pub const Z_UTIL_X2_426: u32 = 852;
pub const Z_UTIL_X2_427: u32 = 854;
pub const Z_UTIL_X2_428: u32 = 856;
pub const Z_UTIL_X2_429: u32 = 858;
pub const Z_UTIL_X2_430: u32 = 860;
pub const Z_UTIL_X2_431: u32 = 862;
pub const Z_UTIL_X2_432: u32 = 864;
pub const Z_UTIL_X2_433: u32 = 866;
pub const Z_UTIL_X2_434: u32 = 868;
pub const Z_UTIL_X2_435: u32 = 870;
pub const Z_UTIL_X2_436: u32 = 872;
pub const Z_UTIL_X2_437: u32 = 874;
pub const Z_UTIL_X2_438: u32 = 876;
pub const Z_UTIL_X2_439: u32 = 878;
pub const Z_UTIL_X2_440: u32 = 880;
pub const Z_UTIL_X2_441: u32 = 882;
pub const Z_UTIL_X2_442: u32 = 884;
pub const Z_UTIL_X2_443: u32 = 886;
pub const Z_UTIL_X2_444: u32 = 888;
pub const Z_UTIL_X2_445: u32 = 890;
pub const Z_UTIL_X2_446: u32 = 892;
pub const Z_UTIL_X2_447: u32 = 894;
pub const Z_UTIL_X2_448: u32 = 896;
pub const Z_UTIL_X2_449: u32 = 898;
pub const Z_UTIL_X2_450: u32 = 900;
pub const Z_UTIL_X2_451: u32 = 902;
pub const Z_UTIL_X2_452: u32 = 904;
pub const Z_UTIL_X2_453: u32 = 906;
pub const Z_UTIL_X2_454: u32 = 908;
pub const Z_UTIL_X2_455: u32 = 910;
pub const Z_UTIL_X2_456: u32 = 912;
pub const Z_UTIL_X2_457: u32 = 914;
pub const Z_UTIL_X2_458: u32 = 916;
pub const Z_UTIL_X2_459: u32 = 918;
pub const Z_UTIL_X2_460: u32 = 920;
pub const Z_UTIL_X2_461: u32 = 922;
pub const Z_UTIL_X2_462: u32 = 924;
pub const Z_UTIL_X2_463: u32 = 926;
pub const Z_UTIL_X2_464: u32 = 928;
pub const Z_UTIL_X2_465: u32 = 930;
pub const Z_UTIL_X2_466: u32 = 932;
pub const Z_UTIL_X2_467: u32 = 934;
pub const Z_UTIL_X2_468: u32 = 936;
pub const Z_UTIL_X2_469: u32 = 938;
pub const Z_UTIL_X2_470: u32 = 940;
pub const Z_UTIL_X2_471: u32 = 942;
pub const Z_UTIL_X2_472: u32 = 944;
pub const Z_UTIL_X2_473: u32 = 946;
pub const Z_UTIL_X2_474: u32 = 948;
pub const Z_UTIL_X2_475: u32 = 950;
pub const Z_UTIL_X2_476: u32 = 952;
pub const Z_UTIL_X2_477: u32 = 954;
pub const Z_UTIL_X2_478: u32 = 956;
pub const Z_UTIL_X2_479: u32 = 958;
pub const Z_UTIL_X2_480: u32 = 960;
pub const Z_UTIL_X2_481: u32 = 962;
pub const Z_UTIL_X2_482: u32 = 964;
pub const Z_UTIL_X2_483: u32 = 966;
pub const Z_UTIL_X2_484: u32 = 968;
pub const Z_UTIL_X2_485: u32 = 970;
pub const Z_UTIL_X2_486: u32 = 972;
pub const Z_UTIL_X2_487: u32 = 974;
pub const Z_UTIL_X2_488: u32 = 976;
pub const Z_UTIL_X2_489: u32 = 978;
pub const Z_UTIL_X2_490: u32 = 980;
pub const Z_UTIL_X2_491: u32 = 982;
pub const Z_UTIL_X2_492: u32 = 984;
pub const Z_UTIL_X2_493: u32 = 986;
pub const Z_UTIL_X2_494: u32 = 988;
pub const Z_UTIL_X2_495: u32 = 990;
pub const Z_UTIL_X2_496: u32 = 992;
pub const Z_UTIL_X2_497: u32 = 994;
pub const Z_UTIL_X2_498: u32 = 996;
pub const Z_UTIL_X2_499: u32 = 998;
pub const Z_UTIL_X2_500: u32 = 1000;
pub const Z_UTIL_X2_501: u32 = 1002;
pub const Z_UTIL_X2_502: u32 = 1004;
pub const Z_UTIL_X2_503: u32 = 1006;
pub const Z_UTIL_X2_504: u32 = 1008;
pub const Z_UTIL_X2_505: u32 = 1010;
pub const Z_UTIL_X2_506: u32 = 1012;
pub const Z_UTIL_X2_507: u32 = 1014;
pub const Z_UTIL_X2_508: u32 = 1016;
pub const Z_UTIL_X2_509: u32 = 1018;
pub const Z_UTIL_X2_510: u32 = 1020;
pub const Z_UTIL_X2_511: u32 = 1022;
pub const Z_UTIL_X2_512: u32 = 1024;
pub const Z_UTIL_X2_513: u32 = 1026;
pub const Z_UTIL_X2_514: u32 = 1028;
pub const Z_UTIL_X2_515: u32 = 1030;
pub const Z_UTIL_X2_516: u32 = 1032;
pub const Z_UTIL_X2_517: u32 = 1034;
pub const Z_UTIL_X2_518: u32 = 1036;
pub const Z_UTIL_X2_519: u32 = 1038;
pub const Z_UTIL_X2_520: u32 = 1040;
pub const Z_UTIL_X2_521: u32 = 1042;
pub const Z_UTIL_X2_522: u32 = 1044;
pub const Z_UTIL_X2_523: u32 = 1046;
pub const Z_UTIL_X2_524: u32 = 1048;
pub const Z_UTIL_X2_525: u32 = 1050;
pub const Z_UTIL_X2_526: u32 = 1052;
pub const Z_UTIL_X2_527: u32 = 1054;
pub const Z_UTIL_X2_528: u32 = 1056;
pub const Z_UTIL_X2_529: u32 = 1058;
pub const Z_UTIL_X2_530: u32 = 1060;
pub const Z_UTIL_X2_531: u32 = 1062;
pub const Z_UTIL_X2_532: u32 = 1064;
pub const Z_UTIL_X2_533: u32 = 1066;
pub const Z_UTIL_X2_534: u32 = 1068;
pub const Z_UTIL_X2_535: u32 = 1070;
pub const Z_UTIL_X2_536: u32 = 1072;
pub const Z_UTIL_X2_537: u32 = 1074;
pub const Z_UTIL_X2_538: u32 = 1076;
pub const Z_UTIL_X2_539: u32 = 1078;
pub const Z_UTIL_X2_540: u32 = 1080;
pub const Z_UTIL_X2_541: u32 = 1082;
pub const Z_UTIL_X2_542: u32 = 1084;
pub const Z_UTIL_X2_543: u32 = 1086;
pub const Z_UTIL_X2_544: u32 = 1088;
pub const Z_UTIL_X2_545: u32 = 1090;
pub const Z_UTIL_X2_546: u32 = 1092;
pub const Z_UTIL_X2_547: u32 = 1094;
pub const Z_UTIL_X2_548: u32 = 1096;
pub const Z_UTIL_X2_549: u32 = 1098;
pub const Z_UTIL_X2_550: u32 = 1100;
pub const Z_UTIL_X2_551: u32 = 1102;
pub const Z_UTIL_X2_552: u32 = 1104;
pub const Z_UTIL_X2_553: u32 = 1106;
pub const Z_UTIL_X2_554: u32 = 1108;
pub const Z_UTIL_X2_555: u32 = 1110;
pub const Z_UTIL_X2_556: u32 = 1112;
pub const Z_UTIL_X2_557: u32 = 1114;
pub const Z_UTIL_X2_558: u32 = 1116;
pub const Z_UTIL_X2_559: u32 = 1118;
pub const Z_UTIL_X2_560: u32 = 1120;
pub const Z_UTIL_X2_561: u32 = 1122;
pub const Z_UTIL_X2_562: u32 = 1124;
pub const Z_UTIL_X2_563: u32 = 1126;
pub const Z_UTIL_X2_564: u32 = 1128;
pub const Z_UTIL_X2_565: u32 = 1130;
pub const Z_UTIL_X2_566: u32 = 1132;
pub const Z_UTIL_X2_567: u32 = 1134;
pub const Z_UTIL_X2_568: u32 = 1136;
pub const Z_UTIL_X2_569: u32 = 1138;
pub const Z_UTIL_X2_570: u32 = 1140;
pub const Z_UTIL_X2_571: u32 = 1142;
pub const Z_UTIL_X2_572: u32 = 1144;
pub const Z_UTIL_X2_573: u32 = 1146;
pub const Z_UTIL_X2_574: u32 = 1148;
pub const Z_UTIL_X2_575: u32 = 1150;
pub const Z_UTIL_X2_576: u32 = 1152;
pub const Z_UTIL_X2_577: u32 = 1154;
pub const Z_UTIL_X2_578: u32 = 1156;
pub const Z_UTIL_X2_579: u32 = 1158;
pub const Z_UTIL_X2_580: u32 = 1160;
pub const Z_UTIL_X2_581: u32 = 1162;
pub const Z_UTIL_X2_582: u32 = 1164;
pub const Z_UTIL_X2_583: u32 = 1166;
pub const Z_UTIL_X2_584: u32 = 1168;
pub const Z_UTIL_X2_585: u32 = 1170;
pub const Z_UTIL_X2_586: u32 = 1172;
pub const Z_UTIL_X2_587: u32 = 1174;
pub const Z_UTIL_X2_588: u32 = 1176;
pub const Z_UTIL_X2_589: u32 = 1178;
pub const Z_UTIL_X2_590: u32 = 1180;
pub const Z_UTIL_X2_591: u32 = 1182;
pub const Z_UTIL_X2_592: u32 = 1184;
pub const Z_UTIL_X2_593: u32 = 1186;
pub const Z_UTIL_X2_594: u32 = 1188;
pub const Z_UTIL_X2_595: u32 = 1190;
pub const Z_UTIL_X2_596: u32 = 1192;
pub const Z_UTIL_X2_597: u32 = 1194;
pub const Z_UTIL_X2_598: u32 = 1196;
pub const Z_UTIL_X2_599: u32 = 1198;
pub const Z_UTIL_X2_600: u32 = 1200;
pub const Z_UTIL_X2_601: u32 = 1202;
pub const Z_UTIL_X2_602: u32 = 1204;
pub const Z_UTIL_X2_603: u32 = 1206;
pub const Z_UTIL_X2_604: u32 = 1208;
pub const Z_UTIL_X2_605: u32 = 1210;
pub const Z_UTIL_X2_606: u32 = 1212;
pub const Z_UTIL_X2_607: u32 = 1214;
pub const Z_UTIL_X2_608: u32 = 1216;
pub const Z_UTIL_X2_609: u32 = 1218;
pub const Z_UTIL_X2_610: u32 = 1220;
pub const Z_UTIL_X2_611: u32 = 1222;
pub const Z_UTIL_X2_612: u32 = 1224;
pub const Z_UTIL_X2_613: u32 = 1226;
pub const Z_UTIL_X2_614: u32 = 1228;
pub const Z_UTIL_X2_615: u32 = 1230;
pub const Z_UTIL_X2_616: u32 = 1232;
pub const Z_UTIL_X2_617: u32 = 1234;
pub const Z_UTIL_X2_618: u32 = 1236;
pub const Z_UTIL_X2_619: u32 = 1238;
pub const Z_UTIL_X2_620: u32 = 1240;
pub const Z_UTIL_X2_621: u32 = 1242;
pub const Z_UTIL_X2_622: u32 = 1244;
pub const Z_UTIL_X2_623: u32 = 1246;
pub const Z_UTIL_X2_624: u32 = 1248;
pub const Z_UTIL_X2_625: u32 = 1250;
pub const Z_UTIL_X2_626: u32 = 1252;
pub const Z_UTIL_X2_627: u32 = 1254;
pub const Z_UTIL_X2_628: u32 = 1256;
pub const Z_UTIL_X2_629: u32 = 1258;
pub const Z_UTIL_X2_630: u32 = 1260;
pub const Z_UTIL_X2_631: u32 = 1262;
pub const Z_UTIL_X2_632: u32 = 1264;
pub const Z_UTIL_X2_633: u32 = 1266;
pub const Z_UTIL_X2_634: u32 = 1268;
pub const Z_UTIL_X2_635: u32 = 1270;
pub const Z_UTIL_X2_636: u32 = 1272;
pub const Z_UTIL_X2_637: u32 = 1274;
pub const Z_UTIL_X2_638: u32 = 1276;
pub const Z_UTIL_X2_639: u32 = 1278;
pub const Z_UTIL_X2_640: u32 = 1280;
pub const Z_UTIL_X2_641: u32 = 1282;
pub const Z_UTIL_X2_642: u32 = 1284;
pub const Z_UTIL_X2_643: u32 = 1286;
pub const Z_UTIL_X2_644: u32 = 1288;
pub const Z_UTIL_X2_645: u32 = 1290;
pub const Z_UTIL_X2_646: u32 = 1292;
pub const Z_UTIL_X2_647: u32 = 1294;
pub const Z_UTIL_X2_648: u32 = 1296;
pub const Z_UTIL_X2_649: u32 = 1298;
pub const Z_UTIL_X2_650: u32 = 1300;
pub const Z_UTIL_X2_651: u32 = 1302;
pub const Z_UTIL_X2_652: u32 = 1304;
pub const Z_UTIL_X2_653: u32 = 1306;
pub const Z_UTIL_X2_654: u32 = 1308;
pub const Z_UTIL_X2_655: u32 = 1310;
pub const Z_UTIL_X2_656: u32 = 1312;
pub const Z_UTIL_X2_657: u32 = 1314;
pub const Z_UTIL_X2_658: u32 = 1316;
pub const Z_UTIL_X2_659: u32 = 1318;
pub const Z_UTIL_X2_660: u32 = 1320;
pub const Z_UTIL_X2_661: u32 = 1322;
pub const Z_UTIL_X2_662: u32 = 1324;
pub const Z_UTIL_X2_663: u32 = 1326;
pub const Z_UTIL_X2_664: u32 = 1328;
pub const Z_UTIL_X2_665: u32 = 1330;
pub const Z_UTIL_X2_666: u32 = 1332;
pub const Z_UTIL_X2_667: u32 = 1334;
pub const Z_UTIL_X2_668: u32 = 1336;
pub const Z_UTIL_X2_669: u32 = 1338;
pub const Z_UTIL_X2_670: u32 = 1340;
pub const Z_UTIL_X2_671: u32 = 1342;
pub const Z_UTIL_X2_672: u32 = 1344;
pub const Z_UTIL_X2_673: u32 = 1346;
pub const Z_UTIL_X2_674: u32 = 1348;
pub const Z_UTIL_X2_675: u32 = 1350;
pub const Z_UTIL_X2_676: u32 = 1352;
pub const Z_UTIL_X2_677: u32 = 1354;
pub const Z_UTIL_X2_678: u32 = 1356;
pub const Z_UTIL_X2_679: u32 = 1358;
pub const Z_UTIL_X2_680: u32 = 1360;
pub const Z_UTIL_X2_681: u32 = 1362;
pub const Z_UTIL_X2_682: u32 = 1364;
pub const Z_UTIL_X2_683: u32 = 1366;
pub const Z_UTIL_X2_684: u32 = 1368;
pub const Z_UTIL_X2_685: u32 = 1370;
pub const Z_UTIL_X2_686: u32 = 1372;
pub const Z_UTIL_X2_687: u32 = 1374;
pub const Z_UTIL_X2_688: u32 = 1376;
pub const Z_UTIL_X2_689: u32 = 1378;
pub const Z_UTIL_X2_690: u32 = 1380;
pub const Z_UTIL_X2_691: u32 = 1382;
pub const Z_UTIL_X2_692: u32 = 1384;
pub const Z_UTIL_X2_693: u32 = 1386;
pub const Z_UTIL_X2_694: u32 = 1388;
pub const Z_UTIL_X2_695: u32 = 1390;
pub const Z_UTIL_X2_696: u32 = 1392;
pub const Z_UTIL_X2_697: u32 = 1394;
pub const Z_UTIL_X2_698: u32 = 1396;
pub const Z_UTIL_X2_699: u32 = 1398;
pub const Z_UTIL_X2_700: u32 = 1400;
pub const Z_UTIL_X2_701: u32 = 1402;
pub const Z_UTIL_X2_702: u32 = 1404;
pub const Z_UTIL_X2_703: u32 = 1406;
pub const Z_UTIL_X2_704: u32 = 1408;
pub const Z_UTIL_X2_705: u32 = 1410;
pub const Z_UTIL_X2_706: u32 = 1412;
pub const Z_UTIL_X2_707: u32 = 1414;
pub const Z_UTIL_X2_708: u32 = 1416;
pub const Z_UTIL_X2_709: u32 = 1418;
pub const Z_UTIL_X2_710: u32 = 1420;
pub const Z_UTIL_X2_711: u32 = 1422;
pub const Z_UTIL_X2_712: u32 = 1424;
pub const Z_UTIL_X2_713: u32 = 1426;
pub const Z_UTIL_X2_714: u32 = 1428;
pub const Z_UTIL_X2_715: u32 = 1430;
pub const Z_UTIL_X2_716: u32 = 1432;
pub const Z_UTIL_X2_717: u32 = 1434;
pub const Z_UTIL_X2_718: u32 = 1436;
pub const Z_UTIL_X2_719: u32 = 1438;
pub const Z_UTIL_X2_720: u32 = 1440;
pub const Z_UTIL_X2_721: u32 = 1442;
pub const Z_UTIL_X2_722: u32 = 1444;
pub const Z_UTIL_X2_723: u32 = 1446;
pub const Z_UTIL_X2_724: u32 = 1448;
pub const Z_UTIL_X2_725: u32 = 1450;
pub const Z_UTIL_X2_726: u32 = 1452;
pub const Z_UTIL_X2_727: u32 = 1454;
pub const Z_UTIL_X2_728: u32 = 1456;
pub const Z_UTIL_X2_729: u32 = 1458;
pub const Z_UTIL_X2_730: u32 = 1460;
pub const Z_UTIL_X2_731: u32 = 1462;
pub const Z_UTIL_X2_732: u32 = 1464;
pub const Z_UTIL_X2_733: u32 = 1466;
pub const Z_UTIL_X2_734: u32 = 1468;
pub const Z_UTIL_X2_735: u32 = 1470;
pub const Z_UTIL_X2_736: u32 = 1472;
pub const Z_UTIL_X2_737: u32 = 1474;
pub const Z_UTIL_X2_738: u32 = 1476;
pub const Z_UTIL_X2_739: u32 = 1478;
pub const Z_UTIL_X2_740: u32 = 1480;
pub const Z_UTIL_X2_741: u32 = 1482;
pub const Z_UTIL_X2_742: u32 = 1484;
pub const Z_UTIL_X2_743: u32 = 1486;
pub const Z_UTIL_X2_744: u32 = 1488;
pub const Z_UTIL_X2_745: u32 = 1490;
pub const Z_UTIL_X2_746: u32 = 1492;
pub const Z_UTIL_X2_747: u32 = 1494;
pub const Z_UTIL_X2_748: u32 = 1496;
pub const Z_UTIL_X2_749: u32 = 1498;
pub const Z_UTIL_X2_750: u32 = 1500;
pub const Z_UTIL_X2_751: u32 = 1502;
pub const Z_UTIL_X2_752: u32 = 1504;
pub const Z_UTIL_X2_753: u32 = 1506;
pub const Z_UTIL_X2_754: u32 = 1508;
pub const Z_UTIL_X2_755: u32 = 1510;
pub const Z_UTIL_X2_756: u32 = 1512;
pub const Z_UTIL_X2_757: u32 = 1514;
pub const Z_UTIL_X2_758: u32 = 1516;
pub const Z_UTIL_X2_759: u32 = 1518;
pub const Z_UTIL_X2_760: u32 = 1520;
pub const Z_UTIL_X2_761: u32 = 1522;
pub const Z_UTIL_X2_762: u32 = 1524;
pub const Z_UTIL_X2_763: u32 = 1526;
pub const Z_UTIL_X2_764: u32 = 1528;
pub const Z_UTIL_X2_765: u32 = 1530;
pub const Z_UTIL_X2_766: u32 = 1532;
pub const Z_UTIL_X2_767: u32 = 1534;
pub const Z_UTIL_X2_768: u32 = 1536;
pub const Z_UTIL_X2_769: u32 = 1538;
pub const Z_UTIL_X2_770: u32 = 1540;
pub const Z_UTIL_X2_771: u32 = 1542;
pub const Z_UTIL_X2_772: u32 = 1544;
pub const Z_UTIL_X2_773: u32 = 1546;
pub const Z_UTIL_X2_774: u32 = 1548;
pub const Z_UTIL_X2_775: u32 = 1550;
pub const Z_UTIL_X2_776: u32 = 1552;
pub const Z_UTIL_X2_777: u32 = 1554;
pub const Z_UTIL_X2_778: u32 = 1556;
pub const Z_UTIL_X2_779: u32 = 1558;
pub const Z_UTIL_X2_780: u32 = 1560;
pub const Z_UTIL_X2_781: u32 = 1562;
pub const Z_UTIL_X2_782: u32 = 1564;
pub const Z_UTIL_X2_783: u32 = 1566;
pub const Z_UTIL_X2_784: u32 = 1568;
pub const Z_UTIL_X2_785: u32 = 1570;
pub const Z_UTIL_X2_786: u32 = 1572;
pub const Z_UTIL_X2_787: u32 = 1574;
pub const Z_UTIL_X2_788: u32 = 1576;
pub const Z_UTIL_X2_789: u32 = 1578;
pub const Z_UTIL_X2_790: u32 = 1580;
pub const Z_UTIL_X2_791: u32 = 1582;
pub const Z_UTIL_X2_792: u32 = 1584;
pub const Z_UTIL_X2_793: u32 = 1586;
pub const Z_UTIL_X2_794: u32 = 1588;
pub const Z_UTIL_X2_795: u32 = 1590;
pub const Z_UTIL_X2_796: u32 = 1592;
pub const Z_UTIL_X2_797: u32 = 1594;
pub const Z_UTIL_X2_798: u32 = 1596;
pub const Z_UTIL_X2_799: u32 = 1598;
pub const Z_UTIL_X2_800: u32 = 1600;
pub const Z_UTIL_X2_801: u32 = 1602;
pub const Z_UTIL_X2_802: u32 = 1604;
pub const Z_UTIL_X2_803: u32 = 1606;
pub const Z_UTIL_X2_804: u32 = 1608;
pub const Z_UTIL_X2_805: u32 = 1610;
pub const Z_UTIL_X2_806: u32 = 1612;
pub const Z_UTIL_X2_807: u32 = 1614;
pub const Z_UTIL_X2_808: u32 = 1616;
pub const Z_UTIL_X2_809: u32 = 1618;
pub const Z_UTIL_X2_810: u32 = 1620;
pub const Z_UTIL_X2_811: u32 = 1622;
pub const Z_UTIL_X2_812: u32 = 1624;
pub const Z_UTIL_X2_813: u32 = 1626;
pub const Z_UTIL_X2_814: u32 = 1628;
pub const Z_UTIL_X2_815: u32 = 1630;
pub const Z_UTIL_X2_816: u32 = 1632;
pub const Z_UTIL_X2_817: u32 = 1634;
pub const Z_UTIL_X2_818: u32 = 1636;
pub const Z_UTIL_X2_819: u32 = 1638;
pub const Z_UTIL_X2_820: u32 = 1640;
pub const Z_UTIL_X2_821: u32 = 1642;
pub const Z_UTIL_X2_822: u32 = 1644;
pub const Z_UTIL_X2_823: u32 = 1646;
pub const Z_UTIL_X2_824: u32 = 1648;
pub const Z_UTIL_X2_825: u32 = 1650;
pub const Z_UTIL_X2_826: u32 = 1652;
pub const Z_UTIL_X2_827: u32 = 1654;
pub const Z_UTIL_X2_828: u32 = 1656;
pub const Z_UTIL_X2_829: u32 = 1658;
pub const Z_UTIL_X2_830: u32 = 1660;
pub const Z_UTIL_X2_831: u32 = 1662;
pub const Z_UTIL_X2_832: u32 = 1664;
pub const Z_UTIL_X2_833: u32 = 1666;
pub const Z_UTIL_X2_834: u32 = 1668;
pub const Z_UTIL_X2_835: u32 = 1670;
pub const Z_UTIL_X2_836: u32 = 1672;
pub const Z_UTIL_X2_837: u32 = 1674;
pub const Z_UTIL_X2_838: u32 = 1676;
pub const Z_UTIL_X2_839: u32 = 1678;
pub const Z_UTIL_X2_840: u32 = 1680;
pub const Z_UTIL_X2_841: u32 = 1682;
pub const Z_UTIL_X2_842: u32 = 1684;
pub const Z_UTIL_X2_843: u32 = 1686;
pub const Z_UTIL_X2_844: u32 = 1688;
pub const Z_UTIL_X2_845: u32 = 1690;
pub const Z_UTIL_X2_846: u32 = 1692;
pub const Z_UTIL_X2_847: u32 = 1694;
pub const Z_UTIL_X2_848: u32 = 1696;
pub const Z_UTIL_X2_849: u32 = 1698;
pub const Z_UTIL_X2_850: u32 = 1700;
pub const Z_UTIL_X2_851: u32 = 1702;
pub const Z_UTIL_X2_852: u32 = 1704;
pub const Z_UTIL_X2_853: u32 = 1706;
pub const Z_UTIL_X2_854: u32 = 1708;
pub const Z_UTIL_X2_855: u32 = 1710;
pub const Z_UTIL_X2_856: u32 = 1712;
pub const Z_UTIL_X2_857: u32 = 1714;
pub const Z_UTIL_X2_858: u32 = 1716;
pub const Z_UTIL_X2_859: u32 = 1718;
pub const Z_UTIL_X2_860: u32 = 1720;
pub const Z_UTIL_X2_861: u32 = 1722;
pub const Z_UTIL_X2_862: u32 = 1724;
pub const Z_UTIL_X2_863: u32 = 1726;
pub const Z_UTIL_X2_864: u32 = 1728;
pub const Z_UTIL_X2_865: u32 = 1730;
pub const Z_UTIL_X2_866: u32 = 1732;
pub const Z_UTIL_X2_867: u32 = 1734;
pub const Z_UTIL_X2_868: u32 = 1736;
pub const Z_UTIL_X2_869: u32 = 1738;
pub const Z_UTIL_X2_870: u32 = 1740;
pub const Z_UTIL_X2_871: u32 = 1742;
pub const Z_UTIL_X2_872: u32 = 1744;
pub const Z_UTIL_X2_873: u32 = 1746;
pub const Z_UTIL_X2_874: u32 = 1748;
pub const Z_UTIL_X2_875: u32 = 1750;
pub const Z_UTIL_X2_876: u32 = 1752;
pub const Z_UTIL_X2_877: u32 = 1754;
pub const Z_UTIL_X2_878: u32 = 1756;
pub const Z_UTIL_X2_879: u32 = 1758;
pub const Z_UTIL_X2_880: u32 = 1760;
pub const Z_UTIL_X2_881: u32 = 1762;
pub const Z_UTIL_X2_882: u32 = 1764;
pub const Z_UTIL_X2_883: u32 = 1766;
pub const Z_UTIL_X2_884: u32 = 1768;
pub const Z_UTIL_X2_885: u32 = 1770;
pub const Z_UTIL_X2_886: u32 = 1772;
pub const Z_UTIL_X2_887: u32 = 1774;
pub const Z_UTIL_X2_888: u32 = 1776;
pub const Z_UTIL_X2_889: u32 = 1778;
pub const Z_UTIL_X2_890: u32 = 1780;
pub const Z_UTIL_X2_891: u32 = 1782;
pub const Z_UTIL_X2_892: u32 = 1784;
pub const Z_UTIL_X2_893: u32 = 1786;
pub const Z_UTIL_X2_894: u32 = 1788;
pub const Z_UTIL_X2_895: u32 = 1790;
pub const Z_UTIL_X2_896: u32 = 1792;
pub const Z_UTIL_X2_897: u32 = 1794;
pub const Z_UTIL_X2_898: u32 = 1796;
pub const Z_UTIL_X2_899: u32 = 1798;
pub const Z_UTIL_X2_900: u32 = 1800;
pub const Z_UTIL_X2_901: u32 = 1802;
pub const Z_UTIL_X2_902: u32 = 1804;
pub const Z_UTIL_X2_903: u32 = 1806;
pub const Z_UTIL_X2_904: u32 = 1808;
pub const Z_UTIL_X2_905: u32 = 1810;
pub const Z_UTIL_X2_906: u32 = 1812;
pub const Z_UTIL_X2_907: u32 = 1814;
pub const Z_UTIL_X2_908: u32 = 1816;
pub const Z_UTIL_X2_909: u32 = 1818;
pub const Z_UTIL_X2_910: u32 = 1820;
pub const Z_UTIL_X2_911: u32 = 1822;
pub const Z_UTIL_X2_912: u32 = 1824;
pub const Z_UTIL_X2_913: u32 = 1826;
pub const Z_UTIL_X2_914: u32 = 1828;
pub const Z_UTIL_X2_915: u32 = 1830;
pub const Z_UTIL_X2_916: u32 = 1832;
pub const Z_UTIL_X2_917: u32 = 1834;
pub const Z_UTIL_X2_918: u32 = 1836;
pub const Z_UTIL_X2_919: u32 = 1838;
pub const Z_UTIL_X2_920: u32 = 1840;
pub const Z_UTIL_X2_921: u32 = 1842;
pub const Z_UTIL_X2_922: u32 = 1844;
pub const Z_UTIL_X2_923: u32 = 1846;
pub const Z_UTIL_X2_924: u32 = 1848;
pub const Z_UTIL_X2_925: u32 = 1850;
pub const Z_UTIL_X2_926: u32 = 1852;
pub const Z_UTIL_X2_927: u32 = 1854;
pub const Z_UTIL_X2_928: u32 = 1856;
pub const Z_UTIL_X2_929: u32 = 1858;
pub const Z_UTIL_X2_930: u32 = 1860;
pub const Z_UTIL_X2_931: u32 = 1862;
pub const Z_UTIL_X2_932: u32 = 1864;
pub const Z_UTIL_X2_933: u32 = 1866;
pub const Z_UTIL_X2_934: u32 = 1868;
pub const Z_UTIL_X2_935: u32 = 1870;
pub const Z_UTIL_X2_936: u32 = 1872;
pub const Z_UTIL_X2_937: u32 = 1874;
pub const Z_UTIL_X2_938: u32 = 1876;
pub const Z_UTIL_X2_939: u32 = 1878;
pub const Z_UTIL_X2_940: u32 = 1880;
pub const Z_UTIL_X2_941: u32 = 1882;
pub const Z_UTIL_X2_942: u32 = 1884;
pub const Z_UTIL_X2_943: u32 = 1886;
pub const Z_UTIL_X2_944: u32 = 1888;
pub const Z_UTIL_X2_945: u32 = 1890;
pub const Z_UTIL_X2_946: u32 = 1892;
pub const Z_UTIL_X2_947: u32 = 1894;
pub const Z_UTIL_X2_948: u32 = 1896;
pub const Z_UTIL_X2_949: u32 = 1898;
pub const Z_UTIL_X2_950: u32 = 1900;
pub const Z_UTIL_X2_951: u32 = 1902;
pub const Z_UTIL_X2_952: u32 = 1904;
pub const Z_UTIL_X2_953: u32 = 1906;
pub const Z_UTIL_X2_954: u32 = 1908;
pub const Z_UTIL_X2_955: u32 = 1910;
pub const Z_UTIL_X2_956: u32 = 1912;
pub const Z_UTIL_X2_957: u32 = 1914;
pub const Z_UTIL_X2_958: u32 = 1916;
pub const Z_UTIL_X2_959: u32 = 1918;
pub const Z_UTIL_X2_960: u32 = 1920;
pub const Z_UTIL_X2_961: u32 = 1922;
pub const Z_UTIL_X2_962: u32 = 1924;
pub const Z_UTIL_X2_963: u32 = 1926;
pub const Z_UTIL_X2_964: u32 = 1928;
pub const Z_UTIL_X2_965: u32 = 1930;
pub const Z_UTIL_X2_966: u32 = 1932;
pub const Z_UTIL_X2_967: u32 = 1934;
pub const Z_UTIL_X2_968: u32 = 1936;
pub const Z_UTIL_X2_969: u32 = 1938;
pub const Z_UTIL_X2_970: u32 = 1940;
pub const Z_UTIL_X2_971: u32 = 1942;
pub const Z_UTIL_X2_972: u32 = 1944;
pub const Z_UTIL_X2_973: u32 = 1946;
pub const Z_UTIL_X2_974: u32 = 1948;
pub const Z_UTIL_X2_975: u32 = 1950;
pub const Z_UTIL_X2_976: u32 = 1952;
pub const Z_UTIL_X2_977: u32 = 1954;
pub const Z_UTIL_X2_978: u32 = 1956;
pub const Z_UTIL_X2_979: u32 = 1958;
pub const Z_UTIL_X2_980: u32 = 1960;
pub const Z_UTIL_X2_981: u32 = 1962;
pub const Z_UTIL_X2_982: u32 = 1964;
pub const Z_UTIL_X2_983: u32 = 1966;
pub const Z_UTIL_X2_984: u32 = 1968;
pub const Z_UTIL_X2_985: u32 = 1970;
pub const Z_UTIL_X2_986: u32 = 1972;
pub const Z_UTIL_X2_987: u32 = 1974;
pub const Z_UTIL_X2_988: u32 = 1976;
pub const Z_UTIL_X2_989: u32 = 1978;
pub const Z_UTIL_X2_990: u32 = 1980;
pub const Z_UTIL_X2_991: u32 = 1982;
pub const Z_UTIL_X2_992: u32 = 1984;
pub const Z_UTIL_X2_993: u32 = 1986;
pub const Z_UTIL_X2_994: u32 = 1988;
pub const Z_UTIL_X2_995: u32 = 1990;
pub const Z_UTIL_X2_996: u32 = 1992;
pub const Z_UTIL_X2_997: u32 = 1994;
pub const Z_UTIL_X2_998: u32 = 1996;
pub const Z_UTIL_X2_999: u32 = 1998;
pub const Z_UTIL_X2_1000: u32 = 2000;
pub const Z_UTIL_X2_1001: u32 = 2002;
pub const Z_UTIL_X2_1002: u32 = 2004;
pub const Z_UTIL_X2_1003: u32 = 2006;
pub const Z_UTIL_X2_1004: u32 = 2008;
pub const Z_UTIL_X2_1005: u32 = 2010;
pub const Z_UTIL_X2_1006: u32 = 2012;
pub const Z_UTIL_X2_1007: u32 = 2014;
pub const Z_UTIL_X2_1008: u32 = 2016;
pub const Z_UTIL_X2_1009: u32 = 2018;
pub const Z_UTIL_X2_1010: u32 = 2020;
pub const Z_UTIL_X2_1011: u32 = 2022;
pub const Z_UTIL_X2_1012: u32 = 2024;
pub const Z_UTIL_X2_1013: u32 = 2026;
pub const Z_UTIL_X2_1014: u32 = 2028;
pub const Z_UTIL_X2_1015: u32 = 2030;
pub const Z_UTIL_X2_1016: u32 = 2032;
pub const Z_UTIL_X2_1017: u32 = 2034;
pub const Z_UTIL_X2_1018: u32 = 2036;
pub const Z_UTIL_X2_1019: u32 = 2038;
pub const Z_UTIL_X2_1020: u32 = 2040;
pub const Z_UTIL_X2_1021: u32 = 2042;
pub const Z_UTIL_X2_1022: u32 = 2044;
pub const Z_UTIL_X2_1023: u32 = 2046;
pub const Z_UTIL_X2_1024: u32 = 2048;
pub const Z_UTIL_X2_1025: u32 = 2050;
pub const Z_UTIL_X2_1026: u32 = 2052;
pub const Z_UTIL_X2_1027: u32 = 2054;
pub const Z_UTIL_X2_1028: u32 = 2056;
pub const Z_UTIL_X2_1029: u32 = 2058;
pub const Z_UTIL_X2_1030: u32 = 2060;
pub const Z_UTIL_X2_1031: u32 = 2062;
pub const Z_UTIL_X2_1032: u32 = 2064;
pub const Z_UTIL_X2_1033: u32 = 2066;
pub const Z_UTIL_X2_1034: u32 = 2068;
pub const Z_UTIL_X2_1035: u32 = 2070;
pub const Z_UTIL_X2_1036: u32 = 2072;
pub const Z_UTIL_X2_1037: u32 = 2074;
pub const Z_UTIL_X2_1038: u32 = 2076;
pub const Z_UTIL_X2_1039: u32 = 2078;
pub const Z_UTIL_X2_1040: u32 = 2080;
pub const Z_UTIL_X2_1041: u32 = 2082;
pub const Z_UTIL_X2_1042: u32 = 2084;
pub const Z_UTIL_X2_1043: u32 = 2086;
pub const Z_UTIL_X2_1044: u32 = 2088;
pub const Z_UTIL_X2_1045: u32 = 2090;
pub const Z_UTIL_X2_1046: u32 = 2092;
pub const Z_UTIL_X2_1047: u32 = 2094;
pub const Z_UTIL_X2_1048: u32 = 2096;
pub const Z_UTIL_X2_1049: u32 = 2098;
pub const Z_UTIL_X2_1050: u32 = 2100;
pub const Z_UTIL_X2_1051: u32 = 2102;
pub const Z_UTIL_X2_1052: u32 = 2104;
pub const Z_UTIL_X2_1053: u32 = 2106;
pub const Z_UTIL_X2_1054: u32 = 2108;
pub const Z_UTIL_X2_1055: u32 = 2110;
pub const Z_UTIL_X2_1056: u32 = 2112;
pub const Z_UTIL_X2_1057: u32 = 2114;
pub const Z_UTIL_X2_1058: u32 = 2116;
pub const Z_UTIL_X2_1059: u32 = 2118;
pub const Z_UTIL_X2_1060: u32 = 2120;
pub const Z_UTIL_X2_1061: u32 = 2122;
pub const Z_UTIL_X2_1062: u32 = 2124;
pub const Z_UTIL_X2_1063: u32 = 2126;
pub const Z_UTIL_X2_1064: u32 = 2128;
pub const Z_UTIL_X2_1065: u32 = 2130;
pub const Z_UTIL_X2_1066: u32 = 2132;
pub const Z_UTIL_X2_1067: u32 = 2134;
pub const Z_UTIL_X2_1068: u32 = 2136;
pub const Z_UTIL_X2_1069: u32 = 2138;
pub const Z_UTIL_X2_1070: u32 = 2140;
pub const Z_UTIL_X2_1071: u32 = 2142;
pub const Z_UTIL_X2_1072: u32 = 2144;
pub const Z_UTIL_X2_1073: u32 = 2146;
pub const Z_UTIL_X2_1074: u32 = 2148;
pub const Z_UTIL_X2_1075: u32 = 2150;
pub const Z_UTIL_X2_1076: u32 = 2152;
pub const Z_UTIL_X2_1077: u32 = 2154;
pub const Z_UTIL_X2_1078: u32 = 2156;
pub const Z_UTIL_X2_1079: u32 = 2158;
pub const Z_UTIL_X2_1080: u32 = 2160;
pub const Z_UTIL_X2_1081: u32 = 2162;
pub const Z_UTIL_X2_1082: u32 = 2164;
pub const Z_UTIL_X2_1083: u32 = 2166;
pub const Z_UTIL_X2_1084: u32 = 2168;
pub const Z_UTIL_X2_1085: u32 = 2170;
pub const Z_UTIL_X2_1086: u32 = 2172;
pub const Z_UTIL_X2_1087: u32 = 2174;
pub const Z_UTIL_X2_1088: u32 = 2176;
pub const Z_UTIL_X2_1089: u32 = 2178;
pub const Z_UTIL_X2_1090: u32 = 2180;
pub const Z_UTIL_X2_1091: u32 = 2182;
pub const Z_UTIL_X2_1092: u32 = 2184;
pub const Z_UTIL_X2_1093: u32 = 2186;
pub const Z_UTIL_X2_1094: u32 = 2188;
pub const Z_UTIL_X2_1095: u32 = 2190;
pub const Z_UTIL_X2_1096: u32 = 2192;
pub const Z_UTIL_X2_1097: u32 = 2194;
pub const Z_UTIL_X2_1098: u32 = 2196;
pub const Z_UTIL_X2_1099: u32 = 2198;
pub const Z_UTIL_X2_1100: u32 = 2200;
pub const Z_UTIL_X2_1101: u32 = 2202;
pub const Z_UTIL_X2_1102: u32 = 2204;
pub const Z_UTIL_X2_1103: u32 = 2206;
pub const Z_UTIL_X2_1104: u32 = 2208;
pub const Z_UTIL_X2_1105: u32 = 2210;
pub const Z_UTIL_X2_1106: u32 = 2212;
pub const Z_UTIL_X2_1107: u32 = 2214;
pub const Z_UTIL_X2_1108: u32 = 2216;
pub const Z_UTIL_X2_1109: u32 = 2218;
pub const Z_UTIL_X2_1110: u32 = 2220;
pub const Z_UTIL_X2_1111: u32 = 2222;
pub const Z_UTIL_X2_1112: u32 = 2224;
pub const Z_UTIL_X2_1113: u32 = 2226;
pub const Z_UTIL_X2_1114: u32 = 2228;
pub const Z_UTIL_X2_1115: u32 = 2230;
pub const Z_UTIL_X2_1116: u32 = 2232;
pub const Z_UTIL_X2_1117: u32 = 2234;
pub const Z_UTIL_X2_1118: u32 = 2236;
pub const Z_UTIL_X2_1119: u32 = 2238;
pub const Z_UTIL_X2_1120: u32 = 2240;
pub const Z_UTIL_X2_1121: u32 = 2242;
pub const Z_UTIL_X2_1122: u32 = 2244;
pub const Z_UTIL_X2_1123: u32 = 2246;
pub const Z_UTIL_X2_1124: u32 = 2248;
pub const Z_UTIL_X2_1125: u32 = 2250;
pub const Z_UTIL_X2_1126: u32 = 2252;
pub const Z_UTIL_X2_1127: u32 = 2254;
pub const Z_UTIL_X2_1128: u32 = 2256;
pub const Z_UTIL_X2_1129: u32 = 2258;
pub const Z_UTIL_X2_1130: u32 = 2260;
pub const Z_UTIL_X2_1131: u32 = 2262;
pub const Z_UTIL_X2_1132: u32 = 2264;
pub const Z_UTIL_X2_1133: u32 = 2266;
pub const Z_UTIL_X2_1134: u32 = 2268;
pub const Z_UTIL_X2_1135: u32 = 2270;
pub const Z_UTIL_X2_1136: u32 = 2272;
pub const Z_UTIL_X2_1137: u32 = 2274;
pub const Z_UTIL_X2_1138: u32 = 2276;
pub const Z_UTIL_X2_1139: u32 = 2278;
pub const Z_UTIL_X2_1140: u32 = 2280;
pub const Z_UTIL_X2_1141: u32 = 2282;
pub const Z_UTIL_X2_1142: u32 = 2284;
pub const Z_UTIL_X2_1143: u32 = 2286;
pub const Z_UTIL_X2_1144: u32 = 2288;
pub const Z_UTIL_X2_1145: u32 = 2290;
pub const Z_UTIL_X2_1146: u32 = 2292;
pub const Z_UTIL_X2_1147: u32 = 2294;
pub const Z_UTIL_X2_1148: u32 = 2296;
pub const Z_UTIL_X2_1149: u32 = 2298;
pub const Z_UTIL_X2_1150: u32 = 2300;
pub const Z_UTIL_X2_1151: u32 = 2302;
pub const Z_UTIL_X2_1152: u32 = 2304;
pub const Z_UTIL_X2_1153: u32 = 2306;
pub const Z_UTIL_X2_1154: u32 = 2308;
pub const Z_UTIL_X2_1155: u32 = 2310;
pub const Z_UTIL_X2_1156: u32 = 2312;
pub const Z_UTIL_X2_1157: u32 = 2314;
pub const Z_UTIL_X2_1158: u32 = 2316;
pub const Z_UTIL_X2_1159: u32 = 2318;
pub const Z_UTIL_X2_1160: u32 = 2320;
pub const Z_UTIL_X2_1161: u32 = 2322;
pub const Z_UTIL_X2_1162: u32 = 2324;
pub const Z_UTIL_X2_1163: u32 = 2326;
pub const Z_UTIL_X2_1164: u32 = 2328;
pub const Z_UTIL_X2_1165: u32 = 2330;
pub const Z_UTIL_X2_1166: u32 = 2332;
pub const Z_UTIL_X2_1167: u32 = 2334;
pub const Z_UTIL_X2_1168: u32 = 2336;
pub const Z_UTIL_X2_1169: u32 = 2338;
pub const Z_UTIL_X2_1170: u32 = 2340;
pub const Z_UTIL_X2_1171: u32 = 2342;
pub const Z_UTIL_X2_1172: u32 = 2344;
pub const Z_UTIL_X2_1173: u32 = 2346;
pub const Z_UTIL_X2_1174: u32 = 2348;
pub const Z_UTIL_X2_1175: u32 = 2350;
pub const Z_UTIL_X2_1176: u32 = 2352;
pub const Z_UTIL_X2_1177: u32 = 2354;
pub const Z_UTIL_X2_1178: u32 = 2356;
pub const Z_UTIL_X2_1179: u32 = 2358;
pub const Z_UTIL_X2_1180: u32 = 2360;
pub const Z_UTIL_X2_1181: u32 = 2362;
pub const Z_UTIL_X2_1182: u32 = 2364;
pub const Z_UTIL_X2_1183: u32 = 2366;
pub const Z_UTIL_X2_1184: u32 = 2368;
pub const Z_UTIL_X2_1185: u32 = 2370;
pub const Z_UTIL_X2_1186: u32 = 2372;
pub const Z_UTIL_X2_1187: u32 = 2374;
pub const Z_UTIL_X2_1188: u32 = 2376;
pub const Z_UTIL_X2_1189: u32 = 2378;
pub const Z_UTIL_X2_1190: u32 = 2380;
pub const Z_UTIL_X2_1191: u32 = 2382;
pub const Z_UTIL_X2_1192: u32 = 2384;
pub const Z_UTIL_X2_1193: u32 = 2386;
pub const Z_UTIL_X2_1194: u32 = 2388;
pub const Z_UTIL_X2_1195: u32 = 2390;
pub const Z_UTIL_X2_1196: u32 = 2392;
pub const Z_UTIL_X2_1197: u32 = 2394;
pub const Z_UTIL_X2_1198: u32 = 2396;
pub const Z_UTIL_X2_1199: u32 = 2398;
pub const Z_UTIL_X2_1200: u32 = 2400;
pub const Z_UTIL_X2_1201: u32 = 2402;
pub const Z_UTIL_X2_1202: u32 = 2404;
pub const Z_UTIL_X2_1203: u32 = 2406;
pub const Z_UTIL_X2_1204: u32 = 2408;
pub const Z_UTIL_X2_1205: u32 = 2410;
pub const Z_UTIL_X2_1206: u32 = 2412;
pub const Z_UTIL_X2_1207: u32 = 2414;
pub const Z_UTIL_X2_1208: u32 = 2416;
pub const Z_UTIL_X2_1209: u32 = 2418;
pub const Z_UTIL_X2_1210: u32 = 2420;
pub const Z_UTIL_X2_1211: u32 = 2422;
pub const Z_UTIL_X2_1212: u32 = 2424;
pub const Z_UTIL_X2_1213: u32 = 2426;
pub const Z_UTIL_X2_1214: u32 = 2428;
pub const Z_UTIL_X2_1215: u32 = 2430;
pub const Z_UTIL_X2_1216: u32 = 2432;
pub const Z_UTIL_X2_1217: u32 = 2434;
pub const Z_UTIL_X2_1218: u32 = 2436;
pub const Z_UTIL_X2_1219: u32 = 2438;
pub const Z_UTIL_X2_1220: u32 = 2440;
pub const Z_UTIL_X2_1221: u32 = 2442;
pub const Z_UTIL_X2_1222: u32 = 2444;
pub const Z_UTIL_X2_1223: u32 = 2446;
pub const Z_UTIL_X2_1224: u32 = 2448;
pub const Z_UTIL_X2_1225: u32 = 2450;
pub const Z_UTIL_X2_1226: u32 = 2452;
pub const Z_UTIL_X2_1227: u32 = 2454;
pub const Z_UTIL_X2_1228: u32 = 2456;
pub const Z_UTIL_X2_1229: u32 = 2458;
pub const Z_UTIL_X2_1230: u32 = 2460;
pub const Z_UTIL_X2_1231: u32 = 2462;
pub const Z_UTIL_X2_1232: u32 = 2464;
pub const Z_UTIL_X2_1233: u32 = 2466;
pub const Z_UTIL_X2_1234: u32 = 2468;
pub const Z_UTIL_X2_1235: u32 = 2470;
pub const Z_UTIL_X2_1236: u32 = 2472;
pub const Z_UTIL_X2_1237: u32 = 2474;
pub const Z_UTIL_X2_1238: u32 = 2476;
pub const Z_UTIL_X2_1239: u32 = 2478;
pub const Z_UTIL_X2_1240: u32 = 2480;
pub const Z_UTIL_X2_1241: u32 = 2482;
pub const Z_UTIL_X2_1242: u32 = 2484;
pub const Z_UTIL_X2_1243: u32 = 2486;
pub const Z_UTIL_X2_1244: u32 = 2488;
pub const Z_UTIL_X2_1245: u32 = 2490;
pub const Z_UTIL_X2_1246: u32 = 2492;
pub const Z_UTIL_X2_1247: u32 = 2494;
pub const Z_UTIL_X2_1248: u32 = 2496;
pub const Z_UTIL_X2_1249: u32 = 2498;
pub const Z_UTIL_X2_1250: u32 = 2500;
pub const Z_UTIL_X2_1251: u32 = 2502;
pub const Z_UTIL_X2_1252: u32 = 2504;
pub const Z_UTIL_X2_1253: u32 = 2506;
pub const Z_UTIL_X2_1254: u32 = 2508;
pub const Z_UTIL_X2_1255: u32 = 2510;
pub const Z_UTIL_X2_1256: u32 = 2512;
pub const Z_UTIL_X2_1257: u32 = 2514;
pub const Z_UTIL_X2_1258: u32 = 2516;
pub const Z_UTIL_X2_1259: u32 = 2518;
pub const Z_UTIL_X2_1260: u32 = 2520;
pub const Z_UTIL_X2_1261: u32 = 2522;
pub const Z_UTIL_X2_1262: u32 = 2524;
pub const Z_UTIL_X2_1263: u32 = 2526;
pub const Z_UTIL_X2_1264: u32 = 2528;
pub const Z_UTIL_X2_1265: u32 = 2530;
pub const Z_UTIL_X2_1266: u32 = 2532;
pub const Z_UTIL_X2_1267: u32 = 2534;
pub const Z_UTIL_X2_1268: u32 = 2536;
pub const Z_UTIL_X2_1269: u32 = 2538;
pub const Z_UTIL_X2_1270: u32 = 2540;
pub const Z_UTIL_X2_1271: u32 = 2542;
pub const Z_UTIL_X2_1272: u32 = 2544;
pub const Z_UTIL_X2_1273: u32 = 2546;
pub const Z_UTIL_X2_1274: u32 = 2548;
pub const Z_UTIL_X2_1275: u32 = 2550;
pub const Z_UTIL_X2_1276: u32 = 2552;
pub const Z_UTIL_X2_1277: u32 = 2554;
pub const Z_UTIL_X2_1278: u32 = 2556;
pub const Z_UTIL_X2_1279: u32 = 2558;
pub const Z_UTIL_X2_1280: u32 = 2560;
pub const Z_UTIL_X2_1281: u32 = 2562;
pub const Z_UTIL_X2_1282: u32 = 2564;
pub const Z_UTIL_X2_1283: u32 = 2566;
pub const Z_UTIL_X2_1284: u32 = 2568;
pub const Z_UTIL_X2_1285: u32 = 2570;
pub const Z_UTIL_X2_1286: u32 = 2572;
pub const Z_UTIL_X2_1287: u32 = 2574;
pub const Z_UTIL_X2_1288: u32 = 2576;
pub const Z_UTIL_X2_1289: u32 = 2578;
pub const Z_UTIL_X2_1290: u32 = 2580;
pub const Z_UTIL_X2_1291: u32 = 2582;
pub const Z_UTIL_X2_1292: u32 = 2584;
pub const Z_UTIL_X2_1293: u32 = 2586;
pub const Z_UTIL_X2_1294: u32 = 2588;
pub const Z_UTIL_X2_1295: u32 = 2590;
pub const Z_UTIL_X2_1296: u32 = 2592;
pub const Z_UTIL_X2_1297: u32 = 2594;
pub const Z_UTIL_X2_1298: u32 = 2596;
pub const Z_UTIL_X2_1299: u32 = 2598;
pub const Z_UTIL_X2_1300: u32 = 2600;
pub const Z_UTIL_X2_1301: u32 = 2602;
pub const Z_UTIL_X2_1302: u32 = 2604;
pub const Z_UTIL_X2_1303: u32 = 2606;
pub const Z_UTIL_X2_1304: u32 = 2608;
pub const Z_UTIL_X2_1305: u32 = 2610;
pub const Z_UTIL_X2_1306: u32 = 2612;
pub const Z_UTIL_X2_1307: u32 = 2614;
pub const Z_UTIL_X2_1308: u32 = 2616;
pub const Z_UTIL_X2_1309: u32 = 2618;
pub const Z_UTIL_X2_1310: u32 = 2620;
pub const Z_UTIL_X2_1311: u32 = 2622;
pub const Z_UTIL_X2_1312: u32 = 2624;
pub const Z_UTIL_X2_1313: u32 = 2626;
pub const Z_UTIL_X2_1314: u32 = 2628;
pub const Z_UTIL_X2_1315: u32 = 2630;
pub const Z_UTIL_X2_1316: u32 = 2632;
pub const Z_UTIL_X2_1317: u32 = 2634;
pub const Z_UTIL_X2_1318: u32 = 2636;
pub const Z_UTIL_X2_1319: u32 = 2638;
pub const Z_UTIL_X2_1320: u32 = 2640;
pub const Z_UTIL_X2_1321: u32 = 2642;
pub const Z_UTIL_X2_1322: u32 = 2644;
pub const Z_UTIL_X2_1323: u32 = 2646;
pub const Z_UTIL_X2_1324: u32 = 2648;
pub const Z_UTIL_X2_1325: u32 = 2650;
pub const Z_UTIL_X2_1326: u32 = 2652;
pub const Z_UTIL_X2_1327: u32 = 2654;
pub const Z_UTIL_X2_1328: u32 = 2656;
pub const Z_UTIL_X2_1329: u32 = 2658;
pub const Z_UTIL_X2_1330: u32 = 2660;
pub const Z_UTIL_X2_1331: u32 = 2662;
pub const Z_UTIL_X2_1332: u32 = 2664;
pub const Z_UTIL_X2_1333: u32 = 2666;
pub const Z_UTIL_X2_1334: u32 = 2668;
pub const Z_UTIL_X2_1335: u32 = 2670;
pub const Z_UTIL_X2_1336: u32 = 2672;
pub const Z_UTIL_X2_1337: u32 = 2674;
pub const Z_UTIL_X2_1338: u32 = 2676;
pub const Z_UTIL_X2_1339: u32 = 2678;
pub const Z_UTIL_X2_1340: u32 = 2680;
pub const Z_UTIL_X2_1341: u32 = 2682;
pub const Z_UTIL_X2_1342: u32 = 2684;
pub const Z_UTIL_X2_1343: u32 = 2686;
pub const Z_UTIL_X2_1344: u32 = 2688;
pub const Z_UTIL_X2_1345: u32 = 2690;
pub const Z_UTIL_X2_1346: u32 = 2692;
pub const Z_UTIL_X2_1347: u32 = 2694;
pub const Z_UTIL_X2_1348: u32 = 2696;
pub const Z_UTIL_X2_1349: u32 = 2698;
pub const Z_UTIL_X2_1350: u32 = 2700;
pub const Z_UTIL_X2_1351: u32 = 2702;
pub const Z_UTIL_X2_1352: u32 = 2704;
pub const Z_UTIL_X2_1353: u32 = 2706;
pub const Z_UTIL_X2_1354: u32 = 2708;
pub const Z_UTIL_X2_1355: u32 = 2710;
pub const Z_UTIL_X2_1356: u32 = 2712;
pub const Z_UTIL_X2_1357: u32 = 2714;
pub const Z_UTIL_X2_1358: u32 = 2716;
pub const Z_UTIL_X2_1359: u32 = 2718;
pub const Z_UTIL_X2_1360: u32 = 2720;
pub const Z_UTIL_X2_1361: u32 = 2722;
pub const Z_UTIL_X2_1362: u32 = 2724;
pub const Z_UTIL_X2_1363: u32 = 2726;
pub const Z_UTIL_X2_1364: u32 = 2728;
pub const Z_UTIL_X2_1365: u32 = 2730;
pub const Z_UTIL_X2_1366: u32 = 2732;
pub const Z_UTIL_X2_1367: u32 = 2734;
pub const Z_UTIL_X2_1368: u32 = 2736;
pub const Z_UTIL_X2_1369: u32 = 2738;
pub const Z_UTIL_X2_1370: u32 = 2740;
pub const Z_UTIL_X2_1371: u32 = 2742;
pub const Z_UTIL_X2_1372: u32 = 2744;
pub const Z_UTIL_X2_1373: u32 = 2746;
pub const Z_UTIL_X2_1374: u32 = 2748;
pub const Z_UTIL_X2_1375: u32 = 2750;
pub const Z_UTIL_X2_1376: u32 = 2752;
pub const Z_UTIL_X2_1377: u32 = 2754;
pub const Z_UTIL_X2_1378: u32 = 2756;
pub const Z_UTIL_X2_1379: u32 = 2758;
pub const Z_UTIL_X2_1380: u32 = 2760;
pub const Z_UTIL_X2_1381: u32 = 2762;
pub const Z_UTIL_X2_1382: u32 = 2764;
pub const Z_UTIL_X2_1383: u32 = 2766;
pub const Z_UTIL_X2_1384: u32 = 2768;
pub const Z_UTIL_X2_1385: u32 = 2770;
pub const Z_UTIL_X2_1386: u32 = 2772;
pub const Z_UTIL_X2_1387: u32 = 2774;
pub const Z_UTIL_X2_1388: u32 = 2776;
pub const Z_UTIL_X2_1389: u32 = 2778;
pub const Z_UTIL_X2_1390: u32 = 2780;
pub const Z_UTIL_X2_1391: u32 = 2782;
pub const Z_UTIL_X2_1392: u32 = 2784;
pub const Z_UTIL_X2_1393: u32 = 2786;
pub const Z_UTIL_X2_1394: u32 = 2788;
pub const Z_UTIL_X2_1395: u32 = 2790;
pub const Z_UTIL_X2_1396: u32 = 2792;
pub const Z_UTIL_X2_1397: u32 = 2794;
pub const Z_UTIL_X2_1398: u32 = 2796;
pub const Z_UTIL_X2_1399: u32 = 2798;
pub const Z_UTIL_X2_1400: u32 = 2800;
pub const Z_UTIL_X2_1401: u32 = 2802;
pub const Z_UTIL_X2_1402: u32 = 2804;
pub const Z_UTIL_X2_1403: u32 = 2806;
pub const Z_UTIL_X2_1404: u32 = 2808;
pub const Z_UTIL_X2_1405: u32 = 2810;
pub const Z_UTIL_X2_1406: u32 = 2812;
pub const Z_UTIL_X2_1407: u32 = 2814;
pub const Z_UTIL_X2_1408: u32 = 2816;
pub const Z_UTIL_X2_1409: u32 = 2818;
pub const Z_UTIL_X2_1410: u32 = 2820;
pub const Z_UTIL_X2_1411: u32 = 2822;
pub const Z_UTIL_X2_1412: u32 = 2824;
pub const Z_UTIL_X2_1413: u32 = 2826;
pub const Z_UTIL_X2_1414: u32 = 2828;
pub const Z_UTIL_X2_1415: u32 = 2830;
pub const Z_UTIL_X2_1416: u32 = 2832;
pub const Z_UTIL_X2_1417: u32 = 2834;
pub const Z_UTIL_X2_1418: u32 = 2836;
pub const Z_UTIL_X2_1419: u32 = 2838;
pub const Z_UTIL_X2_1420: u32 = 2840;
pub const Z_UTIL_X2_1421: u32 = 2842;
pub const Z_UTIL_X2_1422: u32 = 2844;
pub const Z_UTIL_X2_1423: u32 = 2846;
pub const Z_UTIL_X2_1424: u32 = 2848;
pub const Z_UTIL_X2_1425: u32 = 2850;
pub const Z_UTIL_X2_1426: u32 = 2852;
pub const Z_UTIL_X2_1427: u32 = 2854;
pub const Z_UTIL_X2_1428: u32 = 2856;
pub const Z_UTIL_X2_1429: u32 = 2858;
pub const Z_UTIL_X2_1430: u32 = 2860;
pub const Z_UTIL_X2_1431: u32 = 2862;
pub const Z_UTIL_X2_1432: u32 = 2864;
pub const Z_UTIL_X2_1433: u32 = 2866;
pub const Z_UTIL_X2_1434: u32 = 2868;
pub const Z_UTIL_X2_1435: u32 = 2870;
pub const Z_UTIL_X2_1436: u32 = 2872;
pub const Z_UTIL_X2_1437: u32 = 2874;
pub const Z_UTIL_X2_1438: u32 = 2876;
pub const Z_UTIL_X2_1439: u32 = 2878;
pub const Z_UTIL_X2_1440: u32 = 2880;
pub const Z_UTIL_X2_1441: u32 = 2882;
pub const Z_UTIL_X2_1442: u32 = 2884;
pub const Z_UTIL_X2_1443: u32 = 2886;
pub const Z_UTIL_X2_1444: u32 = 2888;
pub const Z_UTIL_X2_1445: u32 = 2890;
pub const Z_UTIL_X2_1446: u32 = 2892;
pub const Z_UTIL_X2_1447: u32 = 2894;
pub const Z_UTIL_X2_1448: u32 = 2896;
pub const Z_UTIL_X2_1449: u32 = 2898;
pub const Z_UTIL_X2_1450: u32 = 2900;
pub const Z_UTIL_X2_1451: u32 = 2902;
pub const Z_UTIL_X2_1452: u32 = 2904;
pub const Z_UTIL_X2_1453: u32 = 2906;
pub const Z_UTIL_X2_1454: u32 = 2908;
pub const Z_UTIL_X2_1455: u32 = 2910;
pub const Z_UTIL_X2_1456: u32 = 2912;
pub const Z_UTIL_X2_1457: u32 = 2914;
pub const Z_UTIL_X2_1458: u32 = 2916;
pub const Z_UTIL_X2_1459: u32 = 2918;
pub const Z_UTIL_X2_1460: u32 = 2920;
pub const Z_UTIL_X2_1461: u32 = 2922;
pub const Z_UTIL_X2_1462: u32 = 2924;
pub const Z_UTIL_X2_1463: u32 = 2926;
pub const Z_UTIL_X2_1464: u32 = 2928;
pub const Z_UTIL_X2_1465: u32 = 2930;
pub const Z_UTIL_X2_1466: u32 = 2932;
pub const Z_UTIL_X2_1467: u32 = 2934;
pub const Z_UTIL_X2_1468: u32 = 2936;
pub const Z_UTIL_X2_1469: u32 = 2938;
pub const Z_UTIL_X2_1470: u32 = 2940;
pub const Z_UTIL_X2_1471: u32 = 2942;
pub const Z_UTIL_X2_1472: u32 = 2944;
pub const Z_UTIL_X2_1473: u32 = 2946;
pub const Z_UTIL_X2_1474: u32 = 2948;
pub const Z_UTIL_X2_1475: u32 = 2950;
pub const Z_UTIL_X2_1476: u32 = 2952;
pub const Z_UTIL_X2_1477: u32 = 2954;
pub const Z_UTIL_X2_1478: u32 = 2956;
pub const Z_UTIL_X2_1479: u32 = 2958;
pub const Z_UTIL_X2_1480: u32 = 2960;
pub const Z_UTIL_X2_1481: u32 = 2962;
pub const Z_UTIL_X2_1482: u32 = 2964;
pub const Z_UTIL_X2_1483: u32 = 2966;
pub const Z_UTIL_X2_1484: u32 = 2968;
pub const Z_UTIL_X2_1485: u32 = 2970;
pub const Z_UTIL_X2_1486: u32 = 2972;
pub const Z_UTIL_X2_1487: u32 = 2974;
pub const Z_UTIL_X2_1488: u32 = 2976;
pub const Z_UTIL_X2_1489: u32 = 2978;
pub const Z_UTIL_X2_1490: u32 = 2980;
pub const Z_UTIL_X2_1491: u32 = 2982;
pub const Z_UTIL_X2_1492: u32 = 2984;
pub const Z_UTIL_X2_1493: u32 = 2986;
pub const Z_UTIL_X2_1494: u32 = 2988;
pub const Z_UTIL_X2_1495: u32 = 2990;
pub const Z_UTIL_X2_1496: u32 = 2992;
pub const Z_UTIL_X2_1497: u32 = 2994;
pub const Z_UTIL_X2_1498: u32 = 2996;
pub const Z_UTIL_X2_1499: u32 = 2998;
pub const Z_UTIL_X2_1500: u32 = 3000;
pub const Z_UTIL_X2_1501: u32 = 3002;
pub const Z_UTIL_X2_1502: u32 = 3004;
pub const Z_UTIL_X2_1503: u32 = 3006;
pub const Z_UTIL_X2_1504: u32 = 3008;
pub const Z_UTIL_X2_1505: u32 = 3010;
pub const Z_UTIL_X2_1506: u32 = 3012;
pub const Z_UTIL_X2_1507: u32 = 3014;
pub const Z_UTIL_X2_1508: u32 = 3016;
pub const Z_UTIL_X2_1509: u32 = 3018;
pub const Z_UTIL_X2_1510: u32 = 3020;
pub const Z_UTIL_X2_1511: u32 = 3022;
pub const Z_UTIL_X2_1512: u32 = 3024;
pub const Z_UTIL_X2_1513: u32 = 3026;
pub const Z_UTIL_X2_1514: u32 = 3028;
pub const Z_UTIL_X2_1515: u32 = 3030;
pub const Z_UTIL_X2_1516: u32 = 3032;
pub const Z_UTIL_X2_1517: u32 = 3034;
pub const Z_UTIL_X2_1518: u32 = 3036;
pub const Z_UTIL_X2_1519: u32 = 3038;
pub const Z_UTIL_X2_1520: u32 = 3040;
pub const Z_UTIL_X2_1521: u32 = 3042;
pub const Z_UTIL_X2_1522: u32 = 3044;
pub const Z_UTIL_X2_1523: u32 = 3046;
pub const Z_UTIL_X2_1524: u32 = 3048;
pub const Z_UTIL_X2_1525: u32 = 3050;
pub const Z_UTIL_X2_1526: u32 = 3052;
pub const Z_UTIL_X2_1527: u32 = 3054;
pub const Z_UTIL_X2_1528: u32 = 3056;
pub const Z_UTIL_X2_1529: u32 = 3058;
pub const Z_UTIL_X2_1530: u32 = 3060;
pub const Z_UTIL_X2_1531: u32 = 3062;
pub const Z_UTIL_X2_1532: u32 = 3064;
pub const Z_UTIL_X2_1533: u32 = 3066;
pub const Z_UTIL_X2_1534: u32 = 3068;
pub const Z_UTIL_X2_1535: u32 = 3070;
pub const Z_UTIL_X2_1536: u32 = 3072;
pub const Z_UTIL_X2_1537: u32 = 3074;
pub const Z_UTIL_X2_1538: u32 = 3076;
pub const Z_UTIL_X2_1539: u32 = 3078;
pub const Z_UTIL_X2_1540: u32 = 3080;
pub const Z_UTIL_X2_1541: u32 = 3082;
pub const Z_UTIL_X2_1542: u32 = 3084;
pub const Z_UTIL_X2_1543: u32 = 3086;
pub const Z_UTIL_X2_1544: u32 = 3088;
pub const Z_UTIL_X2_1545: u32 = 3090;
pub const Z_UTIL_X2_1546: u32 = 3092;
pub const Z_UTIL_X2_1547: u32 = 3094;
pub const Z_UTIL_X2_1548: u32 = 3096;
pub const Z_UTIL_X2_1549: u32 = 3098;
pub const Z_UTIL_X2_1550: u32 = 3100;
pub const Z_UTIL_X2_1551: u32 = 3102;
pub const Z_UTIL_X2_1552: u32 = 3104;
pub const Z_UTIL_X2_1553: u32 = 3106;
pub const Z_UTIL_X2_1554: u32 = 3108;
pub const Z_UTIL_X2_1555: u32 = 3110;
pub const Z_UTIL_X2_1556: u32 = 3112;
pub const Z_UTIL_X2_1557: u32 = 3114;
pub const Z_UTIL_X2_1558: u32 = 3116;
pub const Z_UTIL_X2_1559: u32 = 3118;
pub const Z_UTIL_X2_1560: u32 = 3120;
pub const Z_UTIL_X2_1561: u32 = 3122;
pub const Z_UTIL_X2_1562: u32 = 3124;
pub const Z_UTIL_X2_1563: u32 = 3126;
pub const Z_UTIL_X2_1564: u32 = 3128;
pub const Z_UTIL_X2_1565: u32 = 3130;
pub const Z_UTIL_X2_1566: u32 = 3132;
pub const Z_UTIL_X2_1567: u32 = 3134;
pub const Z_UTIL_X2_1568: u32 = 3136;
pub const Z_UTIL_X2_1569: u32 = 3138;
pub const Z_UTIL_X2_1570: u32 = 3140;
pub const Z_UTIL_X2_1571: u32 = 3142;
pub const Z_UTIL_X2_1572: u32 = 3144;
pub const Z_UTIL_X2_1573: u32 = 3146;
pub const Z_UTIL_X2_1574: u32 = 3148;
pub const Z_UTIL_X2_1575: u32 = 3150;
pub const Z_UTIL_X2_1576: u32 = 3152;
pub const Z_UTIL_X2_1577: u32 = 3154;
pub const Z_UTIL_X2_1578: u32 = 3156;
pub const Z_UTIL_X2_1579: u32 = 3158;
pub const Z_UTIL_X2_1580: u32 = 3160;
pub const Z_UTIL_X2_1581: u32 = 3162;
pub const Z_UTIL_X2_1582: u32 = 3164;
pub const Z_UTIL_X2_1583: u32 = 3166;
pub const Z_UTIL_X2_1584: u32 = 3168;
pub const Z_UTIL_X2_1585: u32 = 3170;
pub const Z_UTIL_X2_1586: u32 = 3172;
pub const Z_UTIL_X2_1587: u32 = 3174;
pub const Z_UTIL_X2_1588: u32 = 3176;
pub const Z_UTIL_X2_1589: u32 = 3178;
pub const Z_UTIL_X2_1590: u32 = 3180;
pub const Z_UTIL_X2_1591: u32 = 3182;
pub const Z_UTIL_X2_1592: u32 = 3184;
pub const Z_UTIL_X2_1593: u32 = 3186;
pub const Z_UTIL_X2_1594: u32 = 3188;
pub const Z_UTIL_X2_1595: u32 = 3190;
pub const Z_UTIL_X2_1596: u32 = 3192;
pub const Z_UTIL_X2_1597: u32 = 3194;
pub const Z_UTIL_X2_1598: u32 = 3196;
pub const Z_UTIL_X2_1599: u32 = 3198;
pub const Z_UTIL_X2_1600: u32 = 3200;
pub const Z_UTIL_X2_1601: u32 = 3202;
pub const Z_UTIL_X2_1602: u32 = 3204;
pub const Z_UTIL_X2_1603: u32 = 3206;
pub const Z_UTIL_X2_1604: u32 = 3208;
pub const Z_UTIL_X2_1605: u32 = 3210;
pub const Z_UTIL_X2_1606: u32 = 3212;
pub const Z_UTIL_X2_1607: u32 = 3214;
pub const Z_UTIL_X2_1608: u32 = 3216;
pub const Z_UTIL_X2_1609: u32 = 3218;
pub const Z_UTIL_X2_1610: u32 = 3220;
pub const Z_UTIL_X2_1611: u32 = 3222;
pub const Z_UTIL_X2_1612: u32 = 3224;
pub const Z_UTIL_X2_1613: u32 = 3226;
pub const Z_UTIL_X2_1614: u32 = 3228;
pub const Z_UTIL_X2_1615: u32 = 3230;
pub const Z_UTIL_X2_1616: u32 = 3232;
pub const Z_UTIL_X2_1617: u32 = 3234;
pub const Z_UTIL_X2_1618: u32 = 3236;
pub const Z_UTIL_X2_1619: u32 = 3238;
pub const Z_UTIL_X2_1620: u32 = 3240;
pub const Z_UTIL_X2_1621: u32 = 3242;
pub const Z_UTIL_X2_1622: u32 = 3244;
pub const Z_UTIL_X2_1623: u32 = 3246;
pub const Z_UTIL_X2_1624: u32 = 3248;
pub const Z_UTIL_X2_1625: u32 = 3250;
pub const Z_UTIL_X2_1626: u32 = 3252;
pub const Z_UTIL_X2_1627: u32 = 3254;
pub const Z_UTIL_X2_1628: u32 = 3256;
pub const Z_UTIL_X2_1629: u32 = 3258;
pub const Z_UTIL_X2_1630: u32 = 3260;
pub const Z_UTIL_X2_1631: u32 = 3262;
pub const Z_UTIL_X2_1632: u32 = 3264;
pub const Z_UTIL_X2_1633: u32 = 3266;
pub const Z_UTIL_X2_1634: u32 = 3268;
pub const Z_UTIL_X2_1635: u32 = 3270;
pub const Z_UTIL_X2_1636: u32 = 3272;
pub const Z_UTIL_X2_1637: u32 = 3274;
pub const Z_UTIL_X2_1638: u32 = 3276;
pub const Z_UTIL_X2_1639: u32 = 3278;
pub const Z_UTIL_X2_1640: u32 = 3280;
pub const Z_UTIL_X2_1641: u32 = 3282;
pub const Z_UTIL_X2_1642: u32 = 3284;
pub const Z_UTIL_X2_1643: u32 = 3286;
pub const Z_UTIL_X2_1644: u32 = 3288;
pub const Z_UTIL_X2_1645: u32 = 3290;
pub const Z_UTIL_X2_1646: u32 = 3292;
pub const Z_UTIL_X2_1647: u32 = 3294;
pub const Z_UTIL_X2_1648: u32 = 3296;
pub const Z_UTIL_X2_1649: u32 = 3298;
pub const Z_UTIL_X2_1650: u32 = 3300;
pub const Z_UTIL_X2_1651: u32 = 3302;
pub const Z_UTIL_X2_1652: u32 = 3304;
pub const Z_UTIL_X2_1653: u32 = 3306;
pub const Z_UTIL_X2_1654: u32 = 3308;
pub const Z_UTIL_X2_1655: u32 = 3310;
pub const Z_UTIL_X2_1656: u32 = 3312;
pub const Z_UTIL_X2_1657: u32 = 3314;
pub const Z_UTIL_X2_1658: u32 = 3316;
pub const Z_UTIL_X2_1659: u32 = 3318;
pub const Z_UTIL_X2_1660: u32 = 3320;
pub const Z_UTIL_X2_1661: u32 = 3322;
pub const Z_UTIL_X2_1662: u32 = 3324;
pub const Z_UTIL_X2_1663: u32 = 3326;
pub const Z_UTIL_X2_1664: u32 = 3328;
pub const Z_UTIL_X2_1665: u32 = 3330;
pub const Z_UTIL_X2_1666: u32 = 3332;
pub const Z_UTIL_X2_1667: u32 = 3334;
pub const Z_UTIL_X2_1668: u32 = 3336;
pub const Z_UTIL_X2_1669: u32 = 3338;
pub const Z_UTIL_X2_1670: u32 = 3340;
pub const Z_UTIL_X2_1671: u32 = 3342;
pub const Z_UTIL_X2_1672: u32 = 3344;
pub const Z_UTIL_X2_1673: u32 = 3346;
pub const Z_UTIL_X2_1674: u32 = 3348;
pub const Z_UTIL_X2_1675: u32 = 3350;
pub const Z_UTIL_X2_1676: u32 = 3352;
pub const Z_UTIL_X2_1677: u32 = 3354;
pub const Z_UTIL_X2_1678: u32 = 3356;
pub const Z_UTIL_X2_1679: u32 = 3358;
pub const Z_UTIL_X2_1680: u32 = 3360;
pub const Z_UTIL_X2_1681: u32 = 3362;
pub const Z_UTIL_X2_1682: u32 = 3364;
pub const Z_UTIL_X2_1683: u32 = 3366;
pub const Z_UTIL_X2_1684: u32 = 3368;
pub const Z_UTIL_X2_1685: u32 = 3370;
pub const Z_UTIL_X2_1686: u32 = 3372;
pub const Z_UTIL_X2_1687: u32 = 3374;
pub const Z_UTIL_X2_1688: u32 = 3376;
pub const Z_UTIL_X2_1689: u32 = 3378;
pub const Z_UTIL_X2_1690: u32 = 3380;
pub const Z_UTIL_X2_1691: u32 = 3382;
pub const Z_UTIL_X2_1692: u32 = 3384;
pub const Z_UTIL_X2_1693: u32 = 3386;
pub const Z_UTIL_X2_1694: u32 = 3388;
pub const Z_UTIL_X2_1695: u32 = 3390;
pub const Z_UTIL_X2_1696: u32 = 3392;
pub const Z_UTIL_X2_1697: u32 = 3394;
pub const Z_UTIL_X2_1698: u32 = 3396;
pub const Z_UTIL_X2_1699: u32 = 3398;
pub const Z_UTIL_X2_1700: u32 = 3400;
pub const Z_UTIL_X2_1701: u32 = 3402;
pub const Z_UTIL_X2_1702: u32 = 3404;
pub const Z_UTIL_X2_1703: u32 = 3406;
pub const Z_UTIL_X2_1704: u32 = 3408;
pub const Z_UTIL_X2_1705: u32 = 3410;
pub const Z_UTIL_X2_1706: u32 = 3412;
pub const Z_UTIL_X2_1707: u32 = 3414;
pub const Z_UTIL_X2_1708: u32 = 3416;
pub const Z_UTIL_X2_1709: u32 = 3418;
pub const Z_UTIL_X2_1710: u32 = 3420;
pub const Z_UTIL_X2_1711: u32 = 3422;
pub const Z_UTIL_X2_1712: u32 = 3424;
pub const Z_UTIL_X2_1713: u32 = 3426;
pub const Z_UTIL_X2_1714: u32 = 3428;
pub const Z_UTIL_X2_1715: u32 = 3430;
pub const Z_UTIL_X2_1716: u32 = 3432;
pub const Z_UTIL_X2_1717: u32 = 3434;
pub const Z_UTIL_X2_1718: u32 = 3436;
pub const Z_UTIL_X2_1719: u32 = 3438;
pub const Z_UTIL_X2_1720: u32 = 3440;
pub const Z_UTIL_X2_1721: u32 = 3442;
pub const Z_UTIL_X2_1722: u32 = 3444;
pub const Z_UTIL_X2_1723: u32 = 3446;
pub const Z_UTIL_X2_1724: u32 = 3448;
pub const Z_UTIL_X2_1725: u32 = 3450;
pub const Z_UTIL_X2_1726: u32 = 3452;
pub const Z_UTIL_X2_1727: u32 = 3454;
pub const Z_UTIL_X2_1728: u32 = 3456;
pub const Z_UTIL_X2_1729: u32 = 3458;
pub const Z_UTIL_X2_1730: u32 = 3460;
pub const Z_UTIL_X2_1731: u32 = 3462;
pub const Z_UTIL_X2_1732: u32 = 3464;
pub const Z_UTIL_X2_1733: u32 = 3466;
pub const Z_UTIL_X2_1734: u32 = 3468;
pub const Z_UTIL_X2_1735: u32 = 3470;
pub const Z_UTIL_X2_1736: u32 = 3472;
pub const Z_UTIL_X2_1737: u32 = 3474;
pub const Z_UTIL_X2_1738: u32 = 3476;
pub const Z_UTIL_X2_1739: u32 = 3478;
pub const Z_UTIL_X2_1740: u32 = 3480;
pub const Z_UTIL_X2_1741: u32 = 3482;
pub const Z_UTIL_X2_1742: u32 = 3484;
pub const Z_UTIL_X2_1743: u32 = 3486;
pub const Z_UTIL_X2_1744: u32 = 3488;
pub const Z_UTIL_X2_1745: u32 = 3490;
pub const Z_UTIL_X2_1746: u32 = 3492;
pub const Z_UTIL_X2_1747: u32 = 3494;
pub const Z_UTIL_X2_1748: u32 = 3496;
pub const Z_UTIL_X2_1749: u32 = 3498;
pub const Z_UTIL_X2_1750: u32 = 3500;
pub const Z_UTIL_X2_1751: u32 = 3502;
pub const Z_UTIL_X2_1752: u32 = 3504;
pub const Z_UTIL_X2_1753: u32 = 3506;
pub const Z_UTIL_X2_1754: u32 = 3508;
pub const Z_UTIL_X2_1755: u32 = 3510;
pub const Z_UTIL_X2_1756: u32 = 3512;
pub const Z_UTIL_X2_1757: u32 = 3514;
pub const Z_UTIL_X2_1758: u32 = 3516;
pub const Z_UTIL_X2_1759: u32 = 3518;
pub const Z_UTIL_X2_1760: u32 = 3520;
pub const Z_UTIL_X2_1761: u32 = 3522;
pub const Z_UTIL_X2_1762: u32 = 3524;
pub const Z_UTIL_X2_1763: u32 = 3526;
pub const Z_UTIL_X2_1764: u32 = 3528;
pub const Z_UTIL_X2_1765: u32 = 3530;
pub const Z_UTIL_X2_1766: u32 = 3532;
pub const Z_UTIL_X2_1767: u32 = 3534;
pub const Z_UTIL_X2_1768: u32 = 3536;
pub const Z_UTIL_X2_1769: u32 = 3538;
pub const Z_UTIL_X2_1770: u32 = 3540;
pub const Z_UTIL_X2_1771: u32 = 3542;
pub const Z_UTIL_X2_1772: u32 = 3544;
pub const Z_UTIL_X2_1773: u32 = 3546;
pub const Z_UTIL_X2_1774: u32 = 3548;
pub const Z_UTIL_X2_1775: u32 = 3550;
pub const Z_UTIL_X2_1776: u32 = 3552;
pub const Z_UTIL_X2_1777: u32 = 3554;
pub const Z_UTIL_X2_1778: u32 = 3556;
pub const Z_UTIL_X2_1779: u32 = 3558;
pub const Z_UTIL_X2_1780: u32 = 3560;
pub const Z_UTIL_X2_1781: u32 = 3562;
pub const Z_UTIL_X2_1782: u32 = 3564;
pub const Z_UTIL_X2_1783: u32 = 3566;
pub const Z_UTIL_X2_1784: u32 = 3568;
pub const Z_UTIL_X2_1785: u32 = 3570;
pub const Z_UTIL_X2_1786: u32 = 3572;
pub const Z_UTIL_X2_1787: u32 = 3574;
pub const Z_UTIL_X2_1788: u32 = 3576;
pub const Z_UTIL_X2_1789: u32 = 3578;
pub const Z_UTIL_X2_1790: u32 = 3580;
pub const Z_UTIL_X2_1791: u32 = 3582;
pub const Z_UTIL_X2_1792: u32 = 3584;
pub const Z_UTIL_X2_1793: u32 = 3586;
pub const Z_UTIL_X2_1794: u32 = 3588;
pub const Z_UTIL_X2_1795: u32 = 3590;
pub const Z_UTIL_X2_1796: u32 = 3592;
pub const Z_UTIL_X2_1797: u32 = 3594;
pub const Z_UTIL_X2_1798: u32 = 3596;
pub const Z_UTIL_X2_1799: u32 = 3598;
pub const Z_UTIL_X2_1800: u32 = 3600;
pub const Z_UTIL_X2_1801: u32 = 3602;
pub const Z_UTIL_X2_1802: u32 = 3604;
pub const Z_UTIL_X2_1803: u32 = 3606;
pub const Z_UTIL_X2_1804: u32 = 3608;
pub const Z_UTIL_X2_1805: u32 = 3610;
pub const Z_UTIL_X2_1806: u32 = 3612;
pub const Z_UTIL_X2_1807: u32 = 3614;
pub const Z_UTIL_X2_1808: u32 = 3616;
pub const Z_UTIL_X2_1809: u32 = 3618;
pub const Z_UTIL_X2_1810: u32 = 3620;
pub const Z_UTIL_X2_1811: u32 = 3622;
pub const Z_UTIL_X2_1812: u32 = 3624;
pub const Z_UTIL_X2_1813: u32 = 3626;
pub const Z_UTIL_X2_1814: u32 = 3628;
pub const Z_UTIL_X2_1815: u32 = 3630;
pub const Z_UTIL_X2_1816: u32 = 3632;
pub const Z_UTIL_X2_1817: u32 = 3634;
pub const Z_UTIL_X2_1818: u32 = 3636;
pub const Z_UTIL_X2_1819: u32 = 3638;
pub const Z_UTIL_X2_1820: u32 = 3640;
pub const Z_UTIL_X2_1821: u32 = 3642;
pub const Z_UTIL_X2_1822: u32 = 3644;
pub const Z_UTIL_X2_1823: u32 = 3646;
pub const Z_UTIL_X2_1824: u32 = 3648;
pub const Z_UTIL_X2_1825: u32 = 3650;
pub const Z_UTIL_X2_1826: u32 = 3652;
pub const Z_UTIL_X2_1827: u32 = 3654;
pub const Z_UTIL_X2_1828: u32 = 3656;
pub const Z_UTIL_X2_1829: u32 = 3658;
pub const Z_UTIL_X2_1830: u32 = 3660;
pub const Z_UTIL_X2_1831: u32 = 3662;
pub const Z_UTIL_X2_1832: u32 = 3664;
pub const Z_UTIL_X2_1833: u32 = 3666;
pub const Z_UTIL_X2_1834: u32 = 3668;
pub const Z_UTIL_X2_1835: u32 = 3670;
pub const Z_UTIL_X2_1836: u32 = 3672;
pub const Z_UTIL_X2_1837: u32 = 3674;
pub const Z_UTIL_X2_1838: u32 = 3676;
pub const Z_UTIL_X2_1839: u32 = 3678;
pub const Z_UTIL_X2_1840: u32 = 3680;
pub const Z_UTIL_X2_1841: u32 = 3682;
pub const Z_UTIL_X2_1842: u32 = 3684;
pub const Z_UTIL_X2_1843: u32 = 3686;
pub const Z_UTIL_X2_1844: u32 = 3688;
pub const Z_UTIL_X2_1845: u32 = 3690;
pub const Z_UTIL_X2_1846: u32 = 3692;
pub const Z_UTIL_X2_1847: u32 = 3694;
pub const Z_UTIL_X2_1848: u32 = 3696;
pub const Z_UTIL_X2_1849: u32 = 3698;
pub const Z_UTIL_X2_1850: u32 = 3700;
pub const Z_UTIL_X2_1851: u32 = 3702;
pub const Z_UTIL_X2_1852: u32 = 3704;
pub const Z_UTIL_X2_1853: u32 = 3706;
pub const Z_UTIL_X2_1854: u32 = 3708;
pub const Z_UTIL_X2_1855: u32 = 3710;
pub const Z_UTIL_X2_1856: u32 = 3712;
pub const Z_UTIL_X2_1857: u32 = 3714;
pub const Z_UTIL_X2_1858: u32 = 3716;
pub const Z_UTIL_X2_1859: u32 = 3718;
pub const Z_UTIL_X2_1860: u32 = 3720;
pub const Z_UTIL_X2_1861: u32 = 3722;
pub const Z_UTIL_X2_1862: u32 = 3724;
pub const Z_UTIL_X2_1863: u32 = 3726;
pub const Z_UTIL_X2_1864: u32 = 3728;
pub const Z_UTIL_X2_1865: u32 = 3730;
pub const Z_UTIL_X2_1866: u32 = 3732;
pub const Z_UTIL_X2_1867: u32 = 3734;
pub const Z_UTIL_X2_1868: u32 = 3736;
pub const Z_UTIL_X2_1869: u32 = 3738;
pub const Z_UTIL_X2_1870: u32 = 3740;
pub const Z_UTIL_X2_1871: u32 = 3742;
pub const Z_UTIL_X2_1872: u32 = 3744;
pub const Z_UTIL_X2_1873: u32 = 3746;
pub const Z_UTIL_X2_1874: u32 = 3748;
pub const Z_UTIL_X2_1875: u32 = 3750;
pub const Z_UTIL_X2_1876: u32 = 3752;
pub const Z_UTIL_X2_1877: u32 = 3754;
pub const Z_UTIL_X2_1878: u32 = 3756;
pub const Z_UTIL_X2_1879: u32 = 3758;
pub const Z_UTIL_X2_1880: u32 = 3760;
pub const Z_UTIL_X2_1881: u32 = 3762;
pub const Z_UTIL_X2_1882: u32 = 3764;
pub const Z_UTIL_X2_1883: u32 = 3766;
pub const Z_UTIL_X2_1884: u32 = 3768;
pub const Z_UTIL_X2_1885: u32 = 3770;
pub const Z_UTIL_X2_1886: u32 = 3772;
pub const Z_UTIL_X2_1887: u32 = 3774;
pub const Z_UTIL_X2_1888: u32 = 3776;
pub const Z_UTIL_X2_1889: u32 = 3778;
pub const Z_UTIL_X2_1890: u32 = 3780;
pub const Z_UTIL_X2_1891: u32 = 3782;
pub const Z_UTIL_X2_1892: u32 = 3784;
pub const Z_UTIL_X2_1893: u32 = 3786;
pub const Z_UTIL_X2_1894: u32 = 3788;
pub const Z_UTIL_X2_1895: u32 = 3790;
pub const Z_UTIL_X2_1896: u32 = 3792;
pub const Z_UTIL_X2_1897: u32 = 3794;
pub const Z_UTIL_X2_1898: u32 = 3796;
pub const Z_UTIL_X2_1899: u32 = 3798;
pub const Z_UTIL_X2_1900: u32 = 3800;
pub const Z_UTIL_X2_1901: u32 = 3802;
pub const Z_UTIL_X2_1902: u32 = 3804;
pub const Z_UTIL_X2_1903: u32 = 3806;
pub const Z_UTIL_X2_1904: u32 = 3808;
pub const Z_UTIL_X2_1905: u32 = 3810;
pub const Z_UTIL_X2_1906: u32 = 3812;
pub const Z_UTIL_X2_1907: u32 = 3814;
pub const Z_UTIL_X2_1908: u32 = 3816;
pub const Z_UTIL_X2_1909: u32 = 3818;
pub const Z_UTIL_X2_1910: u32 = 3820;
pub const Z_UTIL_X2_1911: u32 = 3822;
pub const Z_UTIL_X2_1912: u32 = 3824;
pub const Z_UTIL_X2_1913: u32 = 3826;
pub const Z_UTIL_X2_1914: u32 = 3828;
pub const Z_UTIL_X2_1915: u32 = 3830;
pub const Z_UTIL_X2_1916: u32 = 3832;
pub const Z_UTIL_X2_1917: u32 = 3834;
pub const Z_UTIL_X2_1918: u32 = 3836;
pub const Z_UTIL_X2_1919: u32 = 3838;
pub const Z_UTIL_X2_1920: u32 = 3840;
pub const Z_UTIL_X2_1921: u32 = 3842;
pub const Z_UTIL_X2_1922: u32 = 3844;
pub const Z_UTIL_X2_1923: u32 = 3846;
pub const Z_UTIL_X2_1924: u32 = 3848;
pub const Z_UTIL_X2_1925: u32 = 3850;
pub const Z_UTIL_X2_1926: u32 = 3852;
pub const Z_UTIL_X2_1927: u32 = 3854;
pub const Z_UTIL_X2_1928: u32 = 3856;
pub const Z_UTIL_X2_1929: u32 = 3858;
pub const Z_UTIL_X2_1930: u32 = 3860;
pub const Z_UTIL_X2_1931: u32 = 3862;
pub const Z_UTIL_X2_1932: u32 = 3864;
pub const Z_UTIL_X2_1933: u32 = 3866;
pub const Z_UTIL_X2_1934: u32 = 3868;
pub const Z_UTIL_X2_1935: u32 = 3870;
pub const Z_UTIL_X2_1936: u32 = 3872;
pub const Z_UTIL_X2_1937: u32 = 3874;
pub const Z_UTIL_X2_1938: u32 = 3876;
pub const Z_UTIL_X2_1939: u32 = 3878;
pub const Z_UTIL_X2_1940: u32 = 3880;
pub const Z_UTIL_X2_1941: u32 = 3882;
pub const Z_UTIL_X2_1942: u32 = 3884;
pub const Z_UTIL_X2_1943: u32 = 3886;
pub const Z_UTIL_X2_1944: u32 = 3888;
pub const Z_UTIL_X2_1945: u32 = 3890;
pub const Z_UTIL_X2_1946: u32 = 3892;
pub const Z_UTIL_X2_1947: u32 = 3894;
pub const Z_UTIL_X2_1948: u32 = 3896;
pub const Z_UTIL_X2_1949: u32 = 3898;
pub const Z_UTIL_X2_1950: u32 = 3900;
pub const Z_UTIL_X2_1951: u32 = 3902;
pub const Z_UTIL_X2_1952: u32 = 3904;
pub const Z_UTIL_X2_1953: u32 = 3906;
pub const Z_UTIL_X2_1954: u32 = 3908;
pub const Z_UTIL_X2_1955: u32 = 3910;
pub const Z_UTIL_X2_1956: u32 = 3912;
pub const Z_UTIL_X2_1957: u32 = 3914;
pub const Z_UTIL_X2_1958: u32 = 3916;
pub const Z_UTIL_X2_1959: u32 = 3918;
pub const Z_UTIL_X2_1960: u32 = 3920;
pub const Z_UTIL_X2_1961: u32 = 3922;
pub const Z_UTIL_X2_1962: u32 = 3924;
pub const Z_UTIL_X2_1963: u32 = 3926;
pub const Z_UTIL_X2_1964: u32 = 3928;
pub const Z_UTIL_X2_1965: u32 = 3930;
pub const Z_UTIL_X2_1966: u32 = 3932;
pub const Z_UTIL_X2_1967: u32 = 3934;
pub const Z_UTIL_X2_1968: u32 = 3936;
pub const Z_UTIL_X2_1969: u32 = 3938;
pub const Z_UTIL_X2_1970: u32 = 3940;
pub const Z_UTIL_X2_1971: u32 = 3942;
pub const Z_UTIL_X2_1972: u32 = 3944;
pub const Z_UTIL_X2_1973: u32 = 3946;
pub const Z_UTIL_X2_1974: u32 = 3948;
pub const Z_UTIL_X2_1975: u32 = 3950;
pub const Z_UTIL_X2_1976: u32 = 3952;
pub const Z_UTIL_X2_1977: u32 = 3954;
pub const Z_UTIL_X2_1978: u32 = 3956;
pub const Z_UTIL_X2_1979: u32 = 3958;
pub const Z_UTIL_X2_1980: u32 = 3960;
pub const Z_UTIL_X2_1981: u32 = 3962;
pub const Z_UTIL_X2_1982: u32 = 3964;
pub const Z_UTIL_X2_1983: u32 = 3966;
pub const Z_UTIL_X2_1984: u32 = 3968;
pub const Z_UTIL_X2_1985: u32 = 3970;
pub const Z_UTIL_X2_1986: u32 = 3972;
pub const Z_UTIL_X2_1987: u32 = 3974;
pub const Z_UTIL_X2_1988: u32 = 3976;
pub const Z_UTIL_X2_1989: u32 = 3978;
pub const Z_UTIL_X2_1990: u32 = 3980;
pub const Z_UTIL_X2_1991: u32 = 3982;
pub const Z_UTIL_X2_1992: u32 = 3984;
pub const Z_UTIL_X2_1993: u32 = 3986;
pub const Z_UTIL_X2_1994: u32 = 3988;
pub const Z_UTIL_X2_1995: u32 = 3990;
pub const Z_UTIL_X2_1996: u32 = 3992;
pub const Z_UTIL_X2_1997: u32 = 3994;
pub const Z_UTIL_X2_1998: u32 = 3996;
pub const Z_UTIL_X2_1999: u32 = 3998;
pub const Z_UTIL_X2_2000: u32 = 4000;
pub const Z_UTIL_X2_2001: u32 = 4002;
pub const Z_UTIL_X2_2002: u32 = 4004;
pub const Z_UTIL_X2_2003: u32 = 4006;
pub const Z_UTIL_X2_2004: u32 = 4008;
pub const Z_UTIL_X2_2005: u32 = 4010;
pub const Z_UTIL_X2_2006: u32 = 4012;
pub const Z_UTIL_X2_2007: u32 = 4014;
pub const Z_UTIL_X2_2008: u32 = 4016;
pub const Z_UTIL_X2_2009: u32 = 4018;
pub const Z_UTIL_X2_2010: u32 = 4020;
pub const Z_UTIL_X2_2011: u32 = 4022;
pub const Z_UTIL_X2_2012: u32 = 4024;
pub const Z_UTIL_X2_2013: u32 = 4026;
pub const Z_UTIL_X2_2014: u32 = 4028;
pub const Z_UTIL_X2_2015: u32 = 4030;
pub const Z_UTIL_X2_2016: u32 = 4032;
pub const Z_UTIL_X2_2017: u32 = 4034;
pub const Z_UTIL_X2_2018: u32 = 4036;
pub const Z_UTIL_X2_2019: u32 = 4038;
pub const Z_UTIL_X2_2020: u32 = 4040;
pub const Z_UTIL_X2_2021: u32 = 4042;
pub const Z_UTIL_X2_2022: u32 = 4044;
pub const Z_UTIL_X2_2023: u32 = 4046;
pub const Z_UTIL_X2_2024: u32 = 4048;
pub const Z_UTIL_X2_2025: u32 = 4050;
pub const Z_UTIL_X2_2026: u32 = 4052;
pub const Z_UTIL_X2_2027: u32 = 4054;
pub const Z_UTIL_X2_2028: u32 = 4056;
pub const Z_UTIL_X2_2029: u32 = 4058;
pub const Z_UTIL_X2_2030: u32 = 4060;
pub const Z_UTIL_X2_2031: u32 = 4062;
pub const Z_UTIL_X2_2032: u32 = 4064;
pub const Z_UTIL_X2_2033: u32 = 4066;
pub const Z_UTIL_X2_2034: u32 = 4068;
pub const Z_UTIL_X2_2035: u32 = 4070;
pub const Z_UTIL_X2_2036: u32 = 4072;
pub const Z_UTIL_X2_2037: u32 = 4074;
pub const Z_UTIL_X2_2038: u32 = 4076;
pub const Z_UTIL_X2_2039: u32 = 4078;
pub const Z_UTIL_X2_2040: u32 = 4080;
pub const Z_UTIL_X2_2041: u32 = 4082;
pub const Z_UTIL_X2_2042: u32 = 4084;
pub const Z_UTIL_X2_2043: u32 = 4086;
pub const Z_UTIL_X2_2044: u32 = 4088;
pub const Z_UTIL_X2_2045: u32 = 4090;
pub const Z_UTIL_X2_2046: u32 = 4092;
pub const Z_UTIL_X2_2047: u32 = 4094;
pub const Z_UTIL_X2_2048: u32 = 4096;
pub const Z_UTIL_X2_2049: u32 = 4098;
pub const Z_UTIL_X2_2050: u32 = 4100;
pub const Z_UTIL_X2_2051: u32 = 4102;
pub const Z_UTIL_X2_2052: u32 = 4104;
pub const Z_UTIL_X2_2053: u32 = 4106;
pub const Z_UTIL_X2_2054: u32 = 4108;
pub const Z_UTIL_X2_2055: u32 = 4110;
pub const Z_UTIL_X2_2056: u32 = 4112;
pub const Z_UTIL_X2_2057: u32 = 4114;
pub const Z_UTIL_X2_2058: u32 = 4116;
pub const Z_UTIL_X2_2059: u32 = 4118;
pub const Z_UTIL_X2_2060: u32 = 4120;
pub const Z_UTIL_X2_2061: u32 = 4122;
pub const Z_UTIL_X2_2062: u32 = 4124;
pub const Z_UTIL_X2_2063: u32 = 4126;
pub const Z_UTIL_X2_2064: u32 = 4128;
pub const Z_UTIL_X2_2065: u32 = 4130;
pub const Z_UTIL_X2_2066: u32 = 4132;
pub const Z_UTIL_X2_2067: u32 = 4134;
pub const Z_UTIL_X2_2068: u32 = 4136;
pub const Z_UTIL_X2_2069: u32 = 4138;
pub const Z_UTIL_X2_2070: u32 = 4140;
pub const Z_UTIL_X2_2071: u32 = 4142;
pub const Z_UTIL_X2_2072: u32 = 4144;
pub const Z_UTIL_X2_2073: u32 = 4146;
pub const Z_UTIL_X2_2074: u32 = 4148;
pub const Z_UTIL_X2_2075: u32 = 4150;
pub const Z_UTIL_X2_2076: u32 = 4152;
pub const Z_UTIL_X2_2077: u32 = 4154;
pub const Z_UTIL_X2_2078: u32 = 4156;
pub const Z_UTIL_X2_2079: u32 = 4158;
pub const Z_UTIL_X2_2080: u32 = 4160;
pub const Z_UTIL_X2_2081: u32 = 4162;
pub const Z_UTIL_X2_2082: u32 = 4164;
pub const Z_UTIL_X2_2083: u32 = 4166;
pub const Z_UTIL_X2_2084: u32 = 4168;
pub const Z_UTIL_X2_2085: u32 = 4170;
pub const Z_UTIL_X2_2086: u32 = 4172;
pub const Z_UTIL_X2_2087: u32 = 4174;
pub const Z_UTIL_X2_2088: u32 = 4176;
pub const Z_UTIL_X2_2089: u32 = 4178;
pub const Z_UTIL_X2_2090: u32 = 4180;
pub const Z_UTIL_X2_2091: u32 = 4182;
pub const Z_UTIL_X2_2092: u32 = 4184;
pub const Z_UTIL_X2_2093: u32 = 4186;
pub const Z_UTIL_X2_2094: u32 = 4188;
pub const Z_UTIL_X2_2095: u32 = 4190;
pub const Z_UTIL_X2_2096: u32 = 4192;
pub const Z_UTIL_X2_2097: u32 = 4194;
pub const Z_UTIL_X2_2098: u32 = 4196;
pub const Z_UTIL_X2_2099: u32 = 4198;
pub const Z_UTIL_X2_2100: u32 = 4200;
pub const Z_UTIL_X2_2101: u32 = 4202;
pub const Z_UTIL_X2_2102: u32 = 4204;
pub const Z_UTIL_X2_2103: u32 = 4206;
pub const Z_UTIL_X2_2104: u32 = 4208;
pub const Z_UTIL_X2_2105: u32 = 4210;
pub const Z_UTIL_X2_2106: u32 = 4212;
pub const Z_UTIL_X2_2107: u32 = 4214;
pub const Z_UTIL_X2_2108: u32 = 4216;
pub const Z_UTIL_X2_2109: u32 = 4218;
pub const Z_UTIL_X2_2110: u32 = 4220;
pub const Z_UTIL_X2_2111: u32 = 4222;
pub const Z_UTIL_X2_2112: u32 = 4224;
pub const Z_UTIL_X2_2113: u32 = 4226;
pub const Z_UTIL_X2_2114: u32 = 4228;
pub const Z_UTIL_X2_2115: u32 = 4230;
pub const Z_UTIL_X2_2116: u32 = 4232;
pub const Z_UTIL_X2_2117: u32 = 4234;
pub const Z_UTIL_X2_2118: u32 = 4236;
pub const Z_UTIL_X2_2119: u32 = 4238;
pub const Z_UTIL_X2_2120: u32 = 4240;
pub const Z_UTIL_X2_2121: u32 = 4242;
pub const Z_UTIL_X2_2122: u32 = 4244;
pub const Z_UTIL_X2_2123: u32 = 4246;
pub const Z_UTIL_X2_2124: u32 = 4248;
pub const Z_UTIL_X2_2125: u32 = 4250;
pub const Z_UTIL_X2_2126: u32 = 4252;
pub const Z_UTIL_X2_2127: u32 = 4254;
pub const Z_UTIL_X2_2128: u32 = 4256;
pub const Z_UTIL_X2_2129: u32 = 4258;
pub const Z_UTIL_X2_2130: u32 = 4260;
pub const Z_UTIL_X2_2131: u32 = 4262;
pub const Z_UTIL_X2_2132: u32 = 4264;
pub const Z_UTIL_X2_2133: u32 = 4266;
pub const Z_UTIL_X2_2134: u32 = 4268;
pub const Z_UTIL_X2_2135: u32 = 4270;
pub const Z_UTIL_X2_2136: u32 = 4272;
pub const Z_UTIL_X2_2137: u32 = 4274;
pub const Z_UTIL_X2_2138: u32 = 4276;
pub const Z_UTIL_X2_2139: u32 = 4278;
pub const Z_UTIL_X2_2140: u32 = 4280;
pub const Z_UTIL_X2_2141: u32 = 4282;
pub const Z_UTIL_X2_2142: u32 = 4284;
pub const Z_UTIL_X2_2143: u32 = 4286;
pub const Z_UTIL_X2_2144: u32 = 4288;
pub const Z_UTIL_X2_2145: u32 = 4290;
pub const Z_UTIL_X2_2146: u32 = 4292;
pub const Z_UTIL_X2_2147: u32 = 4294;
pub const Z_UTIL_X2_2148: u32 = 4296;
pub const Z_UTIL_X2_2149: u32 = 4298;
pub const Z_UTIL_X2_2150: u32 = 4300;
pub const Z_UTIL_X2_2151: u32 = 4302;
pub const Z_UTIL_X2_2152: u32 = 4304;
pub const Z_UTIL_X2_2153: u32 = 4306;
pub const Z_UTIL_X2_2154: u32 = 4308;
pub const Z_UTIL_X2_2155: u32 = 4310;
pub const Z_UTIL_X2_2156: u32 = 4312;
pub const Z_UTIL_X2_2157: u32 = 4314;
pub const Z_UTIL_X2_2158: u32 = 4316;
pub const Z_UTIL_X2_2159: u32 = 4318;
pub const Z_UTIL_X2_2160: u32 = 4320;
pub const Z_UTIL_X2_2161: u32 = 4322;
pub const Z_UTIL_X2_2162: u32 = 4324;
pub const Z_UTIL_X2_2163: u32 = 4326;
pub const Z_UTIL_X2_2164: u32 = 4328;
pub const Z_UTIL_X2_2165: u32 = 4330;
pub const Z_UTIL_X2_2166: u32 = 4332;
pub const Z_UTIL_X2_2167: u32 = 4334;
pub const Z_UTIL_X2_2168: u32 = 4336;
pub const Z_UTIL_X2_2169: u32 = 4338;
pub const Z_UTIL_X2_2170: u32 = 4340;
pub const Z_UTIL_X2_2171: u32 = 4342;
pub const Z_UTIL_X2_2172: u32 = 4344;
pub const Z_UTIL_X2_2173: u32 = 4346;
pub const Z_UTIL_X2_2174: u32 = 4348;
pub const Z_UTIL_X2_2175: u32 = 4350;
pub const Z_UTIL_X2_2176: u32 = 4352;
pub const Z_UTIL_X2_2177: u32 = 4354;
pub const Z_UTIL_X2_2178: u32 = 4356;
pub const Z_UTIL_X2_2179: u32 = 4358;
pub const Z_UTIL_X2_2180: u32 = 4360;
pub const Z_UTIL_X2_2181: u32 = 4362;
pub const Z_UTIL_X2_2182: u32 = 4364;
pub const Z_UTIL_X2_2183: u32 = 4366;
pub const Z_UTIL_X2_2184: u32 = 4368;
pub const Z_UTIL_X2_2185: u32 = 4370;
pub const Z_UTIL_X2_2186: u32 = 4372;
pub const Z_UTIL_X2_2187: u32 = 4374;
pub const Z_UTIL_X2_2188: u32 = 4376;
pub const Z_UTIL_X2_2189: u32 = 4378;
pub const Z_UTIL_X2_2190: u32 = 4380;
pub const Z_UTIL_X2_2191: u32 = 4382;
pub const Z_UTIL_X2_2192: u32 = 4384;
pub const Z_UTIL_X2_2193: u32 = 4386;
pub const Z_UTIL_X2_2194: u32 = 4388;
pub const Z_UTIL_X2_2195: u32 = 4390;
pub const Z_UTIL_X2_2196: u32 = 4392;
pub const Z_UTIL_X2_2197: u32 = 4394;
pub const Z_UTIL_X2_2198: u32 = 4396;
pub const Z_UTIL_X2_2199: u32 = 4398;
pub const Z_UTIL_X2_2200: u32 = 4400;
pub const Z_UTIL_X2_2201: u32 = 4402;
pub const Z_UTIL_X2_2202: u32 = 4404;
pub const Z_UTIL_X2_2203: u32 = 4406;
pub const Z_UTIL_X2_2204: u32 = 4408;
pub const Z_UTIL_X2_2205: u32 = 4410;
pub const Z_UTIL_X2_2206: u32 = 4412;
pub const Z_UTIL_X2_2207: u32 = 4414;
pub const Z_UTIL_X2_2208: u32 = 4416;
pub const Z_UTIL_X2_2209: u32 = 4418;
pub const Z_UTIL_X2_2210: u32 = 4420;
pub const Z_UTIL_X2_2211: u32 = 4422;
pub const Z_UTIL_X2_2212: u32 = 4424;
pub const Z_UTIL_X2_2213: u32 = 4426;
pub const Z_UTIL_X2_2214: u32 = 4428;
pub const Z_UTIL_X2_2215: u32 = 4430;
pub const Z_UTIL_X2_2216: u32 = 4432;
pub const Z_UTIL_X2_2217: u32 = 4434;
pub const Z_UTIL_X2_2218: u32 = 4436;
pub const Z_UTIL_X2_2219: u32 = 4438;
pub const Z_UTIL_X2_2220: u32 = 4440;
pub const Z_UTIL_X2_2221: u32 = 4442;
pub const Z_UTIL_X2_2222: u32 = 4444;
pub const Z_UTIL_X2_2223: u32 = 4446;
pub const Z_UTIL_X2_2224: u32 = 4448;
pub const Z_UTIL_X2_2225: u32 = 4450;
pub const Z_UTIL_X2_2226: u32 = 4452;
pub const Z_UTIL_X2_2227: u32 = 4454;
pub const Z_UTIL_X2_2228: u32 = 4456;
pub const Z_UTIL_X2_2229: u32 = 4458;
pub const Z_UTIL_X2_2230: u32 = 4460;
pub const Z_UTIL_X2_2231: u32 = 4462;
pub const Z_UTIL_X2_2232: u32 = 4464;
pub const Z_UTIL_X2_2233: u32 = 4466;
pub const Z_UTIL_X2_2234: u32 = 4468;
pub const Z_UTIL_X2_2235: u32 = 4470;
pub const Z_UTIL_X2_2236: u32 = 4472;
pub const Z_UTIL_X2_2237: u32 = 4474;
pub const Z_UTIL_X2_2238: u32 = 4476;
pub const Z_UTIL_X2_2239: u32 = 4478;
pub const Z_UTIL_X2_2240: u32 = 4480;
pub const Z_UTIL_X2_2241: u32 = 4482;
pub const Z_UTIL_X2_2242: u32 = 4484;
pub const Z_UTIL_X2_2243: u32 = 4486;
pub const Z_UTIL_X2_2244: u32 = 4488;
pub const Z_UTIL_X2_2245: u32 = 4490;
pub const Z_UTIL_X2_2246: u32 = 4492;
pub const Z_UTIL_X2_2247: u32 = 4494;
pub const Z_UTIL_X2_2248: u32 = 4496;
pub const Z_UTIL_X2_2249: u32 = 4498;
pub const Z_UTIL_X2_2250: u32 = 4500;
pub const Z_UTIL_X2_2251: u32 = 4502;
pub const Z_UTIL_X2_2252: u32 = 4504;
pub const Z_UTIL_X2_2253: u32 = 4506;
pub const Z_UTIL_X2_2254: u32 = 4508;
pub const Z_UTIL_X2_2255: u32 = 4510;
pub const Z_UTIL_X2_2256: u32 = 4512;
pub const Z_UTIL_X2_2257: u32 = 4514;
pub const Z_UTIL_X2_2258: u32 = 4516;
pub const Z_UTIL_X2_2259: u32 = 4518;
pub const Z_UTIL_X2_2260: u32 = 4520;
pub const Z_UTIL_X2_2261: u32 = 4522;
pub const Z_UTIL_X2_2262: u32 = 4524;
pub const Z_UTIL_X2_2263: u32 = 4526;
pub const Z_UTIL_X2_2264: u32 = 4528;
pub const Z_UTIL_X2_2265: u32 = 4530;
pub const Z_UTIL_X2_2266: u32 = 4532;
pub const Z_UTIL_X2_2267: u32 = 4534;
pub const Z_UTIL_X2_2268: u32 = 4536;
pub const Z_UTIL_X2_2269: u32 = 4538;
pub const Z_UTIL_X2_2270: u32 = 4540;
pub const Z_UTIL_X2_2271: u32 = 4542;
pub const Z_UTIL_X2_2272: u32 = 4544;
pub const Z_UTIL_X2_2273: u32 = 4546;
pub const Z_UTIL_X2_2274: u32 = 4548;
pub const Z_UTIL_X2_2275: u32 = 4550;
pub const Z_UTIL_X2_2276: u32 = 4552;
pub const Z_UTIL_X2_2277: u32 = 4554;
pub const Z_UTIL_X2_2278: u32 = 4556;
pub const Z_UTIL_X2_2279: u32 = 4558;
pub const Z_UTIL_X2_2280: u32 = 4560;
pub const Z_UTIL_X2_2281: u32 = 4562;
pub const Z_UTIL_X2_2282: u32 = 4564;
pub const Z_UTIL_X2_2283: u32 = 4566;
pub const Z_UTIL_X2_2284: u32 = 4568;
pub const Z_UTIL_X2_2285: u32 = 4570;
pub const Z_UTIL_X2_2286: u32 = 4572;
pub const Z_UTIL_X2_2287: u32 = 4574;
pub const Z_UTIL_X2_2288: u32 = 4576;
pub const Z_UTIL_X2_2289: u32 = 4578;
pub const Z_UTIL_X2_2290: u32 = 4580;
pub const Z_UTIL_X2_2291: u32 = 4582;
pub const Z_UTIL_X2_2292: u32 = 4584;
pub const Z_UTIL_X2_2293: u32 = 4586;
pub const Z_UTIL_X2_2294: u32 = 4588;
pub const Z_UTIL_X2_2295: u32 = 4590;
pub const Z_UTIL_X2_2296: u32 = 4592;
pub const Z_UTIL_X2_2297: u32 = 4594;
pub const Z_UTIL_X2_2298: u32 = 4596;
pub const Z_UTIL_X2_2299: u32 = 4598;
pub const Z_UTIL_X2_2300: u32 = 4600;
pub const Z_UTIL_X2_2301: u32 = 4602;
pub const Z_UTIL_X2_2302: u32 = 4604;
pub const Z_UTIL_X2_2303: u32 = 4606;
pub const Z_UTIL_X2_2304: u32 = 4608;
pub const Z_UTIL_X2_2305: u32 = 4610;
pub const Z_UTIL_X2_2306: u32 = 4612;
pub const Z_UTIL_X2_2307: u32 = 4614;
pub const Z_UTIL_X2_2308: u32 = 4616;
pub const Z_UTIL_X2_2309: u32 = 4618;
pub const Z_UTIL_X2_2310: u32 = 4620;
pub const Z_UTIL_X2_2311: u32 = 4622;
pub const Z_UTIL_X2_2312: u32 = 4624;
pub const Z_UTIL_X2_2313: u32 = 4626;
pub const Z_UTIL_X2_2314: u32 = 4628;
pub const Z_UTIL_X2_2315: u32 = 4630;
pub const Z_UTIL_X2_2316: u32 = 4632;
pub const Z_UTIL_X2_2317: u32 = 4634;
pub const Z_UTIL_X2_2318: u32 = 4636;
pub const Z_UTIL_X2_2319: u32 = 4638;
pub const Z_UTIL_X2_2320: u32 = 4640;
pub const Z_UTIL_X2_2321: u32 = 4642;
pub const Z_UTIL_X2_2322: u32 = 4644;
pub const Z_UTIL_X2_2323: u32 = 4646;
pub const Z_UTIL_X2_2324: u32 = 4648;
pub const Z_UTIL_X2_2325: u32 = 4650;
pub const Z_UTIL_X2_2326: u32 = 4652;
pub const Z_UTIL_X2_2327: u32 = 4654;
pub const Z_UTIL_X2_2328: u32 = 4656;
pub const Z_UTIL_X2_2329: u32 = 4658;
pub const Z_UTIL_X2_2330: u32 = 4660;
pub const Z_UTIL_X2_2331: u32 = 4662;
pub const Z_UTIL_X2_2332: u32 = 4664;
pub const Z_UTIL_X2_2333: u32 = 4666;
pub const Z_UTIL_X2_2334: u32 = 4668;
pub const Z_UTIL_X2_2335: u32 = 4670;
pub const Z_UTIL_X2_2336: u32 = 4672;
pub const Z_UTIL_X2_2337: u32 = 4674;
pub const Z_UTIL_X2_2338: u32 = 4676;
pub const Z_UTIL_X2_2339: u32 = 4678;
pub const Z_UTIL_X2_2340: u32 = 4680;
pub const Z_UTIL_X2_2341: u32 = 4682;
pub const Z_UTIL_X2_2342: u32 = 4684;
pub const Z_UTIL_X2_2343: u32 = 4686;
pub const Z_UTIL_X2_2344: u32 = 4688;
pub const Z_UTIL_X2_2345: u32 = 4690;
pub const Z_UTIL_X2_2346: u32 = 4692;
pub const Z_UTIL_X2_2347: u32 = 4694;
pub const Z_UTIL_X2_2348: u32 = 4696;
pub const Z_UTIL_X2_2349: u32 = 4698;
pub const Z_UTIL_X2_2350: u32 = 4700;
pub const Z_UTIL_X2_2351: u32 = 4702;
pub const Z_UTIL_X2_2352: u32 = 4704;
pub const Z_UTIL_X2_2353: u32 = 4706;
pub const Z_UTIL_X2_2354: u32 = 4708;
pub const Z_UTIL_X2_2355: u32 = 4710;
pub const Z_UTIL_X2_2356: u32 = 4712;
pub const Z_UTIL_X2_2357: u32 = 4714;
pub const Z_UTIL_X2_2358: u32 = 4716;
pub const Z_UTIL_X2_2359: u32 = 4718;
pub const Z_UTIL_X2_2360: u32 = 4720;
pub const Z_UTIL_X2_2361: u32 = 4722;
pub const Z_UTIL_X2_2362: u32 = 4724;
pub const Z_UTIL_X2_2363: u32 = 4726;
pub const Z_UTIL_X2_2364: u32 = 4728;
pub const Z_UTIL_X2_2365: u32 = 4730;
pub const Z_UTIL_X2_2366: u32 = 4732;
pub const Z_UTIL_X2_2367: u32 = 4734;
pub const Z_UTIL_X2_2368: u32 = 4736;
pub const Z_UTIL_X2_2369: u32 = 4738;
pub const Z_UTIL_X2_2370: u32 = 4740;
pub const Z_UTIL_X2_2371: u32 = 4742;
pub const Z_UTIL_X2_2372: u32 = 4744;
pub const Z_UTIL_X2_2373: u32 = 4746;
pub const Z_UTIL_X2_2374: u32 = 4748;
pub const Z_UTIL_X2_2375: u32 = 4750;
pub const Z_UTIL_X2_2376: u32 = 4752;
pub const Z_UTIL_X2_2377: u32 = 4754;
pub const Z_UTIL_X2_2378: u32 = 4756;
pub const Z_UTIL_X2_2379: u32 = 4758;
pub const Z_UTIL_X2_2380: u32 = 4760;
pub const Z_UTIL_X2_2381: u32 = 4762;
pub const Z_UTIL_X2_2382: u32 = 4764;
pub const Z_UTIL_X2_2383: u32 = 4766;
pub const Z_UTIL_X2_2384: u32 = 4768;
pub const Z_UTIL_X2_2385: u32 = 4770;
pub const Z_UTIL_X2_2386: u32 = 4772;
pub const Z_UTIL_X2_2387: u32 = 4774;
pub const Z_UTIL_X2_2388: u32 = 4776;
pub const Z_UTIL_X2_2389: u32 = 4778;
pub const Z_UTIL_X2_2390: u32 = 4780;
pub const Z_UTIL_X2_2391: u32 = 4782;
pub const Z_UTIL_X2_2392: u32 = 4784;
pub const Z_UTIL_X2_2393: u32 = 4786;
pub const Z_UTIL_X2_2394: u32 = 4788;
pub const Z_UTIL_X2_2395: u32 = 4790;
pub const Z_UTIL_X2_2396: u32 = 4792;
pub const Z_UTIL_X2_2397: u32 = 4794;
pub const Z_UTIL_X2_2398: u32 = 4796;
pub const Z_UTIL_X2_2399: u32 = 4798;
pub const Z_UTIL_X2_2400: u32 = 4800;
pub const Z_UTIL_X2_2401: u32 = 4802;
pub const Z_UTIL_X2_2402: u32 = 4804;
pub const Z_UTIL_X2_2403: u32 = 4806;
pub const Z_UTIL_X2_2404: u32 = 4808;
pub const Z_UTIL_X2_2405: u32 = 4810;
pub const Z_UTIL_X2_2406: u32 = 4812;
pub const Z_UTIL_X2_2407: u32 = 4814;
pub const Z_UTIL_X2_2408: u32 = 4816;
pub const Z_UTIL_X2_2409: u32 = 4818;
pub const Z_UTIL_X2_2410: u32 = 4820;
pub const Z_UTIL_X2_2411: u32 = 4822;
pub const Z_UTIL_X2_2412: u32 = 4824;
pub const Z_UTIL_X2_2413: u32 = 4826;
pub const Z_UTIL_X2_2414: u32 = 4828;
pub const Z_UTIL_X2_2415: u32 = 4830;
pub const Z_UTIL_X2_2416: u32 = 4832;
pub const Z_UTIL_X2_2417: u32 = 4834;
pub const Z_UTIL_X2_2418: u32 = 4836;
pub const Z_UTIL_X2_2419: u32 = 4838;
pub const Z_UTIL_X2_2420: u32 = 4840;
pub const Z_UTIL_X2_2421: u32 = 4842;
pub const Z_UTIL_X2_2422: u32 = 4844;
pub const Z_UTIL_X2_2423: u32 = 4846;
pub const Z_UTIL_X2_2424: u32 = 4848;
pub const Z_UTIL_X2_2425: u32 = 4850;
pub const Z_UTIL_X2_2426: u32 = 4852;
pub const Z_UTIL_X2_2427: u32 = 4854;
pub const Z_UTIL_X2_2428: u32 = 4856;
pub const Z_UTIL_X2_2429: u32 = 4858;
pub const Z_UTIL_X2_2430: u32 = 4860;
pub const Z_UTIL_X2_2431: u32 = 4862;
pub const Z_UTIL_X2_2432: u32 = 4864;
pub const Z_UTIL_X2_2433: u32 = 4866;
pub const Z_UTIL_X2_2434: u32 = 4868;
pub const Z_UTIL_X2_2435: u32 = 4870;
pub const Z_UTIL_X2_2436: u32 = 4872;
pub const Z_UTIL_X2_2437: u32 = 4874;
pub const Z_UTIL_X2_2438: u32 = 4876;
pub const Z_UTIL_X2_2439: u32 = 4878;
pub const Z_UTIL_X2_2440: u32 = 4880;
pub const Z_UTIL_X2_2441: u32 = 4882;
pub const Z_UTIL_X2_2442: u32 = 4884;
pub const Z_UTIL_X2_2443: u32 = 4886;
pub const Z_UTIL_X2_2444: u32 = 4888;
pub const Z_UTIL_X2_2445: u32 = 4890;
pub const Z_UTIL_X2_2446: u32 = 4892;
pub const Z_UTIL_X2_2447: u32 = 4894;
pub const Z_UTIL_X2_2448: u32 = 4896;
pub const Z_UTIL_X2_2449: u32 = 4898;
pub const Z_UTIL_X2_2450: u32 = 4900;
pub const Z_UTIL_X2_2451: u32 = 4902;
pub const Z_UTIL_X2_2452: u32 = 4904;
pub const Z_UTIL_X2_2453: u32 = 4906;
pub const Z_UTIL_X2_2454: u32 = 4908;
pub const Z_UTIL_X2_2455: u32 = 4910;
pub const Z_UTIL_X2_2456: u32 = 4912;
pub const Z_UTIL_X2_2457: u32 = 4914;
pub const Z_UTIL_X2_2458: u32 = 4916;
pub const Z_UTIL_X2_2459: u32 = 4918;
pub const Z_UTIL_X2_2460: u32 = 4920;
pub const Z_UTIL_X2_2461: u32 = 4922;
pub const Z_UTIL_X2_2462: u32 = 4924;
pub const Z_UTIL_X2_2463: u32 = 4926;
pub const Z_UTIL_X2_2464: u32 = 4928;
pub const Z_UTIL_X2_2465: u32 = 4930;
pub const Z_UTIL_X2_2466: u32 = 4932;
pub const Z_UTIL_X2_2467: u32 = 4934;
pub const Z_UTIL_X2_2468: u32 = 4936;
pub const Z_UTIL_X2_2469: u32 = 4938;
pub const Z_UTIL_X2_2470: u32 = 4940;
pub const Z_UTIL_X2_2471: u32 = 4942;
pub const Z_UTIL_X2_2472: u32 = 4944;
pub const Z_UTIL_X2_2473: u32 = 4946;
pub const Z_UTIL_X2_2474: u32 = 4948;
pub const Z_UTIL_X2_2475: u32 = 4950;
pub const Z_UTIL_X2_2476: u32 = 4952;
pub const Z_UTIL_X2_2477: u32 = 4954;
pub const Z_UTIL_X2_2478: u32 = 4956;
pub const Z_UTIL_X2_2479: u32 = 4958;
pub const Z_UTIL_X2_2480: u32 = 4960;
pub const Z_UTIL_X2_2481: u32 = 4962;
pub const Z_UTIL_X2_2482: u32 = 4964;
pub const Z_UTIL_X2_2483: u32 = 4966;
pub const Z_UTIL_X2_2484: u32 = 4968;
pub const Z_UTIL_X2_2485: u32 = 4970;
pub const Z_UTIL_X2_2486: u32 = 4972;
pub const Z_UTIL_X2_2487: u32 = 4974;
pub const Z_UTIL_X2_2488: u32 = 4976;
pub const Z_UTIL_X2_2489: u32 = 4978;
pub const Z_UTIL_X2_2490: u32 = 4980;
pub const Z_UTIL_X2_2491: u32 = 4982;
pub const Z_UTIL_X2_2492: u32 = 4984;
pub const Z_UTIL_X2_2493: u32 = 4986;
pub const Z_UTIL_X2_2494: u32 = 4988;
pub const Z_UTIL_X2_2495: u32 = 4990;
pub const Z_UTIL_X2_2496: u32 = 4992;
pub const Z_UTIL_X2_2497: u32 = 4994;
pub const Z_UTIL_X2_2498: u32 = 4996;
pub const Z_UTIL_X2_2499: u32 = 4998;
pub const Z_UTIL_X2_2500: u32 = 5000;
pub const Z_UTIL_X2_2501: u32 = 5002;
pub const Z_UTIL_X2_2502: u32 = 5004;
pub const Z_UTIL_X2_2503: u32 = 5006;
pub const Z_UTIL_X2_2504: u32 = 5008;
pub const Z_UTIL_X2_2505: u32 = 5010;
pub const Z_UTIL_X2_2506: u32 = 5012;
pub const Z_UTIL_X2_2507: u32 = 5014;
pub const Z_UTIL_X2_2508: u32 = 5016;
pub const Z_UTIL_X2_2509: u32 = 5018;
pub const Z_UTIL_X2_2510: u32 = 5020;
pub const Z_UTIL_X2_2511: u32 = 5022;
pub const Z_UTIL_X2_2512: u32 = 5024;
pub const Z_UTIL_X2_2513: u32 = 5026;
pub const Z_UTIL_X2_2514: u32 = 5028;
pub const Z_UTIL_X2_2515: u32 = 5030;
pub const Z_UTIL_X2_2516: u32 = 5032;
pub const Z_UTIL_X2_2517: u32 = 5034;
pub const Z_UTIL_X2_2518: u32 = 5036;
pub const Z_UTIL_X2_2519: u32 = 5038;
pub const Z_UTIL_X2_2520: u32 = 5040;
pub const Z_UTIL_X2_2521: u32 = 5042;
pub const Z_UTIL_X2_2522: u32 = 5044;
pub const Z_UTIL_X2_2523: u32 = 5046;
pub const Z_UTIL_X2_2524: u32 = 5048;
pub const Z_UTIL_X2_2525: u32 = 5050;
pub const Z_UTIL_X2_2526: u32 = 5052;
pub const Z_UTIL_X2_2527: u32 = 5054;
pub const Z_UTIL_X2_2528: u32 = 5056;
pub const Z_UTIL_X2_2529: u32 = 5058;
pub const Z_UTIL_X2_2530: u32 = 5060;
pub const Z_UTIL_X2_2531: u32 = 5062;
pub const Z_UTIL_X2_2532: u32 = 5064;
pub const Z_UTIL_X2_2533: u32 = 5066;
pub const Z_UTIL_X2_2534: u32 = 5068;
pub const Z_UTIL_X2_2535: u32 = 5070;
pub const Z_UTIL_X2_2536: u32 = 5072;
pub const Z_UTIL_X2_2537: u32 = 5074;
pub const Z_UTIL_X2_2538: u32 = 5076;
pub const Z_UTIL_X2_2539: u32 = 5078;
pub const Z_UTIL_X2_2540: u32 = 5080;
pub const Z_UTIL_X2_2541: u32 = 5082;
pub const Z_UTIL_X2_2542: u32 = 5084;
pub const Z_UTIL_X2_2543: u32 = 5086;
pub const Z_UTIL_X2_2544: u32 = 5088;
pub const Z_UTIL_X2_2545: u32 = 5090;
pub const Z_UTIL_X2_2546: u32 = 5092;
pub const Z_UTIL_X2_2547: u32 = 5094;
pub const Z_UTIL_X2_2548: u32 = 5096;
pub const Z_UTIL_X2_2549: u32 = 5098;
pub const Z_UTIL_X2_2550: u32 = 5100;
pub const Z_UTIL_X2_2551: u32 = 5102;
pub const Z_UTIL_X2_2552: u32 = 5104;
pub const Z_UTIL_X2_2553: u32 = 5106;
pub const Z_UTIL_X2_2554: u32 = 5108;
pub const Z_UTIL_X2_2555: u32 = 5110;
pub const Z_UTIL_X2_2556: u32 = 5112;
pub const Z_UTIL_X2_2557: u32 = 5114;
pub const Z_UTIL_X2_2558: u32 = 5116;
pub const Z_UTIL_X2_2559: u32 = 5118;
pub const Z_UTIL_X2_2560: u32 = 5120;
pub const Z_UTIL_X2_2561: u32 = 5122;
pub const Z_UTIL_X2_2562: u32 = 5124;
pub const Z_UTIL_X2_2563: u32 = 5126;
pub const Z_UTIL_X2_2564: u32 = 5128;
pub const Z_UTIL_X2_2565: u32 = 5130;
pub const Z_UTIL_X2_2566: u32 = 5132;
pub const Z_UTIL_X2_2567: u32 = 5134;
pub const Z_UTIL_X2_2568: u32 = 5136;
pub const Z_UTIL_X2_2569: u32 = 5138;
pub const Z_UTIL_X2_2570: u32 = 5140;
pub const Z_UTIL_X2_2571: u32 = 5142;
pub const Z_UTIL_X2_2572: u32 = 5144;
pub const Z_UTIL_X2_2573: u32 = 5146;
pub const Z_UTIL_X2_2574: u32 = 5148;
pub const Z_UTIL_X2_2575: u32 = 5150;
pub const Z_UTIL_X2_2576: u32 = 5152;
pub const Z_UTIL_X2_2577: u32 = 5154;
pub const Z_UTIL_X2_2578: u32 = 5156;
pub const Z_UTIL_X2_2579: u32 = 5158;
pub const Z_UTIL_X2_2580: u32 = 5160;
pub const Z_UTIL_X2_2581: u32 = 5162;
pub const Z_UTIL_X2_2582: u32 = 5164;
pub const Z_UTIL_X2_2583: u32 = 5166;
pub const Z_UTIL_X2_2584: u32 = 5168;
pub const Z_UTIL_X2_2585: u32 = 5170;
pub const Z_UTIL_X2_2586: u32 = 5172;
pub const Z_UTIL_X2_2587: u32 = 5174;
pub const Z_UTIL_X2_2588: u32 = 5176;
pub const Z_UTIL_X2_2589: u32 = 5178;
pub const Z_UTIL_X2_2590: u32 = 5180;
pub const Z_UTIL_X2_2591: u32 = 5182;
pub const Z_UTIL_X2_2592: u32 = 5184;
pub const Z_UTIL_X2_2593: u32 = 5186;
pub const Z_UTIL_X2_2594: u32 = 5188;
pub const Z_UTIL_X2_2595: u32 = 5190;
pub const Z_UTIL_X2_2596: u32 = 5192;
pub const Z_UTIL_X2_2597: u32 = 5194;
pub const Z_UTIL_X2_2598: u32 = 5196;
pub const Z_UTIL_X2_2599: u32 = 5198;
pub const Z_UTIL_X2_2600: u32 = 5200;
pub const Z_UTIL_X2_2601: u32 = 5202;
pub const Z_UTIL_X2_2602: u32 = 5204;
pub const Z_UTIL_X2_2603: u32 = 5206;
pub const Z_UTIL_X2_2604: u32 = 5208;
pub const Z_UTIL_X2_2605: u32 = 5210;
pub const Z_UTIL_X2_2606: u32 = 5212;
pub const Z_UTIL_X2_2607: u32 = 5214;
pub const Z_UTIL_X2_2608: u32 = 5216;
pub const Z_UTIL_X2_2609: u32 = 5218;
pub const Z_UTIL_X2_2610: u32 = 5220;
pub const Z_UTIL_X2_2611: u32 = 5222;
pub const Z_UTIL_X2_2612: u32 = 5224;
pub const Z_UTIL_X2_2613: u32 = 5226;
pub const Z_UTIL_X2_2614: u32 = 5228;
pub const Z_UTIL_X2_2615: u32 = 5230;
pub const Z_UTIL_X2_2616: u32 = 5232;
pub const Z_UTIL_X2_2617: u32 = 5234;
pub const Z_UTIL_X2_2618: u32 = 5236;
pub const Z_UTIL_X2_2619: u32 = 5238;
pub const Z_UTIL_X2_2620: u32 = 5240;
pub const Z_UTIL_X2_2621: u32 = 5242;
pub const Z_UTIL_X2_2622: u32 = 5244;
pub const Z_UTIL_X2_2623: u32 = 5246;
pub const Z_UTIL_X2_2624: u32 = 5248;
pub const Z_UTIL_X2_2625: u32 = 5250;
pub const Z_UTIL_X2_2626: u32 = 5252;
pub const Z_UTIL_X2_2627: u32 = 5254;
pub const Z_UTIL_X2_2628: u32 = 5256;
pub const Z_UTIL_X2_2629: u32 = 5258;
pub const Z_UTIL_X2_2630: u32 = 5260;
pub const Z_UTIL_X2_2631: u32 = 5262;
pub const Z_UTIL_X2_2632: u32 = 5264;
pub const Z_UTIL_X2_2633: u32 = 5266;
pub const Z_UTIL_X2_2634: u32 = 5268;
pub const Z_UTIL_X2_2635: u32 = 5270;
pub const Z_UTIL_X2_2636: u32 = 5272;
pub const Z_UTIL_X2_2637: u32 = 5274;
pub const Z_UTIL_X2_2638: u32 = 5276;
pub const Z_UTIL_X2_2639: u32 = 5278;
pub const Z_UTIL_X2_2640: u32 = 5280;
pub const Z_UTIL_X2_2641: u32 = 5282;
pub const Z_UTIL_X2_2642: u32 = 5284;
pub const Z_UTIL_X2_2643: u32 = 5286;
pub const Z_UTIL_X2_2644: u32 = 5288;
pub const Z_UTIL_X2_2645: u32 = 5290;
pub const Z_UTIL_X2_2646: u32 = 5292;
pub const Z_UTIL_X2_2647: u32 = 5294;
pub const Z_UTIL_X2_2648: u32 = 5296;
pub const Z_UTIL_X2_2649: u32 = 5298;
pub const Z_UTIL_X2_2650: u32 = 5300;
pub const Z_UTIL_X2_2651: u32 = 5302;
pub const Z_UTIL_X2_2652: u32 = 5304;
pub const Z_UTIL_X2_2653: u32 = 5306;
pub const Z_UTIL_X2_2654: u32 = 5308;
pub const Z_UTIL_X2_2655: u32 = 5310;
pub const Z_UTIL_X2_2656: u32 = 5312;
pub const Z_UTIL_X2_2657: u32 = 5314;
pub const Z_UTIL_X2_2658: u32 = 5316;
pub const Z_UTIL_X2_2659: u32 = 5318;
pub const Z_UTIL_X2_2660: u32 = 5320;
pub const Z_UTIL_X2_2661: u32 = 5322;
pub const Z_UTIL_X2_2662: u32 = 5324;
pub const Z_UTIL_X2_2663: u32 = 5326;
pub const Z_UTIL_X2_2664: u32 = 5328;
pub const Z_UTIL_X2_2665: u32 = 5330;
pub const Z_UTIL_X2_2666: u32 = 5332;
pub const Z_UTIL_X2_2667: u32 = 5334;
pub const Z_UTIL_X2_2668: u32 = 5336;
pub const Z_UTIL_X2_2669: u32 = 5338;
pub const Z_UTIL_X2_2670: u32 = 5340;
pub const Z_UTIL_X2_2671: u32 = 5342;
pub const Z_UTIL_X2_2672: u32 = 5344;
pub const Z_UTIL_X2_2673: u32 = 5346;
pub const Z_UTIL_X2_2674: u32 = 5348;
pub const Z_UTIL_X2_2675: u32 = 5350;
pub const Z_UTIL_X2_2676: u32 = 5352;
pub const Z_UTIL_X2_2677: u32 = 5354;
pub const Z_UTIL_X2_2678: u32 = 5356;
pub const Z_UTIL_X2_2679: u32 = 5358;
pub const Z_UTIL_X2_2680: u32 = 5360;
pub const Z_UTIL_X2_2681: u32 = 5362;
pub const Z_UTIL_X2_2682: u32 = 5364;
pub const Z_UTIL_X2_2683: u32 = 5366;
pub const Z_UTIL_X2_2684: u32 = 5368;
pub const Z_UTIL_X2_2685: u32 = 5370;
pub const Z_UTIL_X2_2686: u32 = 5372;
pub const Z_UTIL_X2_2687: u32 = 5374;
pub const Z_UTIL_X2_2688: u32 = 5376;
pub const Z_UTIL_X2_2689: u32 = 5378;
pub const Z_UTIL_X2_2690: u32 = 5380;
pub const Z_UTIL_X2_2691: u32 = 5382;
pub const Z_UTIL_X2_2692: u32 = 5384;
pub const Z_UTIL_X2_2693: u32 = 5386;
pub const Z_UTIL_X2_2694: u32 = 5388;
pub const Z_UTIL_X2_2695: u32 = 5390;
pub const Z_UTIL_X2_2696: u32 = 5392;
pub const Z_UTIL_X2_2697: u32 = 5394;
pub const Z_UTIL_X2_2698: u32 = 5396;
pub const Z_UTIL_X2_2699: u32 = 5398;
pub const Z_UTIL_X2_2700: u32 = 5400;
pub const Z_UTIL_X2_2701: u32 = 5402;
pub const Z_UTIL_X2_2702: u32 = 5404;
pub const Z_UTIL_X2_2703: u32 = 5406;
pub const Z_UTIL_X2_2704: u32 = 5408;
pub const Z_UTIL_X2_2705: u32 = 5410;
pub const Z_UTIL_X2_2706: u32 = 5412;
pub const Z_UTIL_X2_2707: u32 = 5414;
pub const Z_UTIL_X2_2708: u32 = 5416;
pub const Z_UTIL_X2_2709: u32 = 5418;
pub const Z_UTIL_X2_2710: u32 = 5420;
pub const Z_UTIL_X2_2711: u32 = 5422;
pub const Z_UTIL_X2_2712: u32 = 5424;
pub const Z_UTIL_X2_2713: u32 = 5426;
pub const Z_UTIL_X2_2714: u32 = 5428;
pub const Z_UTIL_X2_2715: u32 = 5430;
pub const Z_UTIL_X2_2716: u32 = 5432;
pub const Z_UTIL_X2_2717: u32 = 5434;
pub const Z_UTIL_X2_2718: u32 = 5436;
pub const Z_UTIL_X2_2719: u32 = 5438;
pub const Z_UTIL_X2_2720: u32 = 5440;
pub const Z_UTIL_X2_2721: u32 = 5442;
pub const Z_UTIL_X2_2722: u32 = 5444;
pub const Z_UTIL_X2_2723: u32 = 5446;
pub const Z_UTIL_X2_2724: u32 = 5448;
pub const Z_UTIL_X2_2725: u32 = 5450;
pub const Z_UTIL_X2_2726: u32 = 5452;
pub const Z_UTIL_X2_2727: u32 = 5454;
pub const Z_UTIL_X2_2728: u32 = 5456;
pub const Z_UTIL_X2_2729: u32 = 5458;
pub const Z_UTIL_X2_2730: u32 = 5460;
pub const Z_UTIL_X2_2731: u32 = 5462;
pub const Z_UTIL_X2_2732: u32 = 5464;
pub const Z_UTIL_X2_2733: u32 = 5466;
pub const Z_UTIL_X2_2734: u32 = 5468;
pub const Z_UTIL_X2_2735: u32 = 5470;
pub const Z_UTIL_X2_2736: u32 = 5472;
pub const Z_UTIL_X2_2737: u32 = 5474;
pub const Z_UTIL_X2_2738: u32 = 5476;
pub const Z_UTIL_X2_2739: u32 = 5478;
pub const Z_UTIL_X2_2740: u32 = 5480;
pub const Z_UTIL_X2_2741: u32 = 5482;
pub const Z_UTIL_X2_2742: u32 = 5484;
pub const Z_UTIL_X2_2743: u32 = 5486;
pub const Z_UTIL_X2_2744: u32 = 5488;
pub const Z_UTIL_X2_2745: u32 = 5490;
pub const Z_UTIL_X2_2746: u32 = 5492;
pub const Z_UTIL_X2_2747: u32 = 5494;
pub const Z_UTIL_X2_2748: u32 = 5496;
pub const Z_UTIL_X2_2749: u32 = 5498;
pub const Z_UTIL_X2_2750: u32 = 5500;
pub const Z_UTIL_X2_2751: u32 = 5502;
pub const Z_UTIL_X2_2752: u32 = 5504;
pub const Z_UTIL_X2_2753: u32 = 5506;
pub const Z_UTIL_X2_2754: u32 = 5508;
pub const Z_UTIL_X2_2755: u32 = 5510;
pub const Z_UTIL_X2_2756: u32 = 5512;
pub const Z_UTIL_X2_2757: u32 = 5514;
pub const Z_UTIL_X2_2758: u32 = 5516;
pub const Z_UTIL_X2_2759: u32 = 5518;
pub const Z_UTIL_X2_2760: u32 = 5520;
pub const Z_UTIL_X2_2761: u32 = 5522;
pub const Z_UTIL_X2_2762: u32 = 5524;
pub const Z_UTIL_X2_2763: u32 = 5526;
pub const Z_UTIL_X2_2764: u32 = 5528;
pub const Z_UTIL_X2_2765: u32 = 5530;
pub const Z_UTIL_X2_2766: u32 = 5532;
pub const Z_UTIL_X2_2767: u32 = 5534;
pub const Z_UTIL_X2_2768: u32 = 5536;
pub const Z_UTIL_X2_2769: u32 = 5538;
pub const Z_UTIL_X2_2770: u32 = 5540;
pub const Z_UTIL_X2_2771: u32 = 5542;
pub const Z_UTIL_X2_2772: u32 = 5544;
pub const Z_UTIL_X2_2773: u32 = 5546;
pub const Z_UTIL_X2_2774: u32 = 5548;
pub const Z_UTIL_X2_2775: u32 = 5550;
pub const Z_UTIL_X2_2776: u32 = 5552;
pub const Z_UTIL_X2_2777: u32 = 5554;
pub const Z_UTIL_X2_2778: u32 = 5556;
pub const Z_UTIL_X2_2779: u32 = 5558;
pub const Z_UTIL_X2_2780: u32 = 5560;
pub const Z_UTIL_X2_2781: u32 = 5562;
pub const Z_UTIL_X2_2782: u32 = 5564;
pub const Z_UTIL_X2_2783: u32 = 5566;
pub const Z_UTIL_X2_2784: u32 = 5568;
pub const Z_UTIL_X2_2785: u32 = 5570;
pub const Z_UTIL_X2_2786: u32 = 5572;
pub const Z_UTIL_X2_2787: u32 = 5574;
pub const Z_UTIL_X2_2788: u32 = 5576;
pub const Z_UTIL_X2_2789: u32 = 5578;
pub const Z_UTIL_X2_2790: u32 = 5580;
pub const Z_UTIL_X2_2791: u32 = 5582;
pub const Z_UTIL_X2_2792: u32 = 5584;
pub const Z_UTIL_X2_2793: u32 = 5586;
pub const Z_UTIL_X2_2794: u32 = 5588;
pub const Z_UTIL_X2_2795: u32 = 5590;
pub const Z_UTIL_X2_2796: u32 = 5592;
pub const Z_UTIL_X2_2797: u32 = 5594;
pub const Z_UTIL_X2_2798: u32 = 5596;
pub const Z_UTIL_X2_2799: u32 = 5598;
pub const Z_UTIL_X2_2800: u32 = 5600;
pub const Z_UTIL_X2_2801: u32 = 5602;
pub const Z_UTIL_X2_2802: u32 = 5604;
pub const Z_UTIL_X2_2803: u32 = 5606;
pub const Z_UTIL_X2_2804: u32 = 5608;
pub const Z_UTIL_X2_2805: u32 = 5610;
pub const Z_UTIL_X2_2806: u32 = 5612;
pub const Z_UTIL_X2_2807: u32 = 5614;
pub const Z_UTIL_X2_2808: u32 = 5616;
pub const Z_UTIL_X2_2809: u32 = 5618;
pub const Z_UTIL_X2_2810: u32 = 5620;
pub const Z_UTIL_X2_2811: u32 = 5622;
pub const Z_UTIL_X2_2812: u32 = 5624;
pub const Z_UTIL_X2_2813: u32 = 5626;
pub const Z_UTIL_X2_2814: u32 = 5628;
pub const Z_UTIL_X2_2815: u32 = 5630;
pub const Z_UTIL_X2_2816: u32 = 5632;
pub const Z_UTIL_X2_2817: u32 = 5634;
pub const Z_UTIL_X2_2818: u32 = 5636;
pub const Z_UTIL_X2_2819: u32 = 5638;
pub const Z_UTIL_X2_2820: u32 = 5640;
pub const Z_UTIL_X2_2821: u32 = 5642;
pub const Z_UTIL_X2_2822: u32 = 5644;
pub const Z_UTIL_X2_2823: u32 = 5646;
pub const Z_UTIL_X2_2824: u32 = 5648;
pub const Z_UTIL_X2_2825: u32 = 5650;
pub const Z_UTIL_X2_2826: u32 = 5652;
pub const Z_UTIL_X2_2827: u32 = 5654;
pub const Z_UTIL_X2_2828: u32 = 5656;
pub const Z_UTIL_X2_2829: u32 = 5658;
pub const Z_UTIL_X2_2830: u32 = 5660;
pub const Z_UTIL_X2_2831: u32 = 5662;
pub const Z_UTIL_X2_2832: u32 = 5664;
pub const Z_UTIL_X2_2833: u32 = 5666;
pub const Z_UTIL_X2_2834: u32 = 5668;
pub const Z_UTIL_X2_2835: u32 = 5670;
pub const Z_UTIL_X2_2836: u32 = 5672;
pub const Z_UTIL_X2_2837: u32 = 5674;
pub const Z_UTIL_X2_2838: u32 = 5676;
pub const Z_UTIL_X2_2839: u32 = 5678;
pub const Z_UTIL_X2_2840: u32 = 5680;
pub const Z_UTIL_X2_2841: u32 = 5682;
pub const Z_UTIL_X2_2842: u32 = 5684;
pub const Z_UTIL_X2_2843: u32 = 5686;
pub const Z_UTIL_X2_2844: u32 = 5688;
pub const Z_UTIL_X2_2845: u32 = 5690;
pub const Z_UTIL_X2_2846: u32 = 5692;
pub const Z_UTIL_X2_2847: u32 = 5694;
pub const Z_UTIL_X2_2848: u32 = 5696;
pub const Z_UTIL_X2_2849: u32 = 5698;
pub const Z_UTIL_X2_2850: u32 = 5700;
pub const Z_UTIL_X2_2851: u32 = 5702;
pub const Z_UTIL_X2_2852: u32 = 5704;
pub const Z_UTIL_X2_2853: u32 = 5706;
pub const Z_UTIL_X2_2854: u32 = 5708;
pub const Z_UTIL_X2_2855: u32 = 5710;
pub const Z_UTIL_X2_2856: u32 = 5712;
pub const Z_UTIL_X2_2857: u32 = 5714;
pub const Z_UTIL_X2_2858: u32 = 5716;
pub const Z_UTIL_X2_2859: u32 = 5718;
pub const Z_UTIL_X2_2860: u32 = 5720;
pub const Z_UTIL_X2_2861: u32 = 5722;
pub const Z_UTIL_X2_2862: u32 = 5724;
pub const Z_UTIL_X2_2863: u32 = 5726;
pub const Z_UTIL_X2_2864: u32 = 5728;
pub const Z_UTIL_X2_2865: u32 = 5730;
pub const Z_UTIL_X2_2866: u32 = 5732;
pub const Z_UTIL_X2_2867: u32 = 5734;
pub const Z_UTIL_X2_2868: u32 = 5736;
pub const Z_UTIL_X2_2869: u32 = 5738;
pub const Z_UTIL_X2_2870: u32 = 5740;
pub const Z_UTIL_X2_2871: u32 = 5742;
pub const Z_UTIL_X2_2872: u32 = 5744;
pub const Z_UTIL_X2_2873: u32 = 5746;
pub const Z_UTIL_X2_2874: u32 = 5748;
pub const Z_UTIL_X2_2875: u32 = 5750;
pub const Z_UTIL_X2_2876: u32 = 5752;
pub const Z_UTIL_X2_2877: u32 = 5754;
pub const Z_UTIL_X2_2878: u32 = 5756;
pub const Z_UTIL_X2_2879: u32 = 5758;
pub const Z_UTIL_X2_2880: u32 = 5760;
pub const Z_UTIL_X2_2881: u32 = 5762;
pub const Z_UTIL_X2_2882: u32 = 5764;
pub const Z_UTIL_X2_2883: u32 = 5766;
pub const Z_UTIL_X2_2884: u32 = 5768;
pub const Z_UTIL_X2_2885: u32 = 5770;
pub const Z_UTIL_X2_2886: u32 = 5772;
pub const Z_UTIL_X2_2887: u32 = 5774;
pub const Z_UTIL_X2_2888: u32 = 5776;
pub const Z_UTIL_X2_2889: u32 = 5778;
pub const Z_UTIL_X2_2890: u32 = 5780;
pub const Z_UTIL_X2_2891: u32 = 5782;
pub const Z_UTIL_X2_2892: u32 = 5784;
pub const Z_UTIL_X2_2893: u32 = 5786;
pub const Z_UTIL_X2_2894: u32 = 5788;
pub const Z_UTIL_X2_2895: u32 = 5790;
pub const Z_UTIL_X2_2896: u32 = 5792;
pub const Z_UTIL_X2_2897: u32 = 5794;
pub const Z_UTIL_X2_2898: u32 = 5796;
pub const Z_UTIL_X2_2899: u32 = 5798;
pub const Z_UTIL_X2_2900: u32 = 5800;
pub const Z_UTIL_X2_2901: u32 = 5802;
pub const Z_UTIL_X2_2902: u32 = 5804;
pub const Z_UTIL_X2_2903: u32 = 5806;
pub const Z_UTIL_X2_2904: u32 = 5808;
pub const Z_UTIL_X2_2905: u32 = 5810;
pub const Z_UTIL_X2_2906: u32 = 5812;
pub const Z_UTIL_X2_2907: u32 = 5814;
pub const Z_UTIL_X2_2908: u32 = 5816;
pub const Z_UTIL_X2_2909: u32 = 5818;
pub const Z_UTIL_X2_2910: u32 = 5820;
pub const Z_UTIL_X2_2911: u32 = 5822;
pub const Z_UTIL_X2_2912: u32 = 5824;
pub const Z_UTIL_X2_2913: u32 = 5826;
pub const Z_UTIL_X2_2914: u32 = 5828;
pub const Z_UTIL_X2_2915: u32 = 5830;
pub const Z_UTIL_X2_2916: u32 = 5832;
pub const Z_UTIL_X2_2917: u32 = 5834;
pub const Z_UTIL_X2_2918: u32 = 5836;
pub const Z_UTIL_X2_2919: u32 = 5838;
pub const Z_UTIL_X2_2920: u32 = 5840;
pub const Z_UTIL_X2_2921: u32 = 5842;
pub const Z_UTIL_X2_2922: u32 = 5844;
pub const Z_UTIL_X2_2923: u32 = 5846;
pub const Z_UTIL_X2_2924: u32 = 5848;
pub const Z_UTIL_X2_2925: u32 = 5850;
pub const Z_UTIL_X2_2926: u32 = 5852;
pub const Z_UTIL_X2_2927: u32 = 5854;
pub const Z_UTIL_X2_2928: u32 = 5856;
pub const Z_UTIL_X2_2929: u32 = 5858;
pub const Z_UTIL_X2_2930: u32 = 5860;
pub const Z_UTIL_X2_2931: u32 = 5862;
pub const Z_UTIL_X2_2932: u32 = 5864;
pub const Z_UTIL_X2_2933: u32 = 5866;
pub const Z_UTIL_X2_2934: u32 = 5868;
pub const Z_UTIL_X2_2935: u32 = 5870;
pub const Z_UTIL_X2_2936: u32 = 5872;
pub const Z_UTIL_X2_2937: u32 = 5874;
pub const Z_UTIL_X2_2938: u32 = 5876;
pub const Z_UTIL_X2_2939: u32 = 5878;
pub const Z_UTIL_X2_2940: u32 = 5880;
pub const Z_UTIL_X2_2941: u32 = 5882;
pub const Z_UTIL_X2_2942: u32 = 5884;
pub const Z_UTIL_X2_2943: u32 = 5886;
pub const Z_UTIL_X2_2944: u32 = 5888;
pub const Z_UTIL_X2_2945: u32 = 5890;
pub const Z_UTIL_X2_2946: u32 = 5892;
pub const Z_UTIL_X2_2947: u32 = 5894;
pub const Z_UTIL_X2_2948: u32 = 5896;
pub const Z_UTIL_X2_2949: u32 = 5898;
pub const Z_UTIL_X2_2950: u32 = 5900;
pub const Z_UTIL_X2_2951: u32 = 5902;
pub const Z_UTIL_X2_2952: u32 = 5904;
pub const Z_UTIL_X2_2953: u32 = 5906;
pub const Z_UTIL_X2_2954: u32 = 5908;
pub const Z_UTIL_X2_2955: u32 = 5910;
pub const Z_UTIL_X2_2956: u32 = 5912;
pub const Z_UTIL_X2_2957: u32 = 5914;
pub const Z_UTIL_X2_2958: u32 = 5916;
pub const Z_UTIL_X2_2959: u32 = 5918;
pub const Z_UTIL_X2_2960: u32 = 5920;
pub const Z_UTIL_X2_2961: u32 = 5922;
pub const Z_UTIL_X2_2962: u32 = 5924;
pub const Z_UTIL_X2_2963: u32 = 5926;
pub const Z_UTIL_X2_2964: u32 = 5928;
pub const Z_UTIL_X2_2965: u32 = 5930;
pub const Z_UTIL_X2_2966: u32 = 5932;
pub const Z_UTIL_X2_2967: u32 = 5934;
pub const Z_UTIL_X2_2968: u32 = 5936;
pub const Z_UTIL_X2_2969: u32 = 5938;
pub const Z_UTIL_X2_2970: u32 = 5940;
pub const Z_UTIL_X2_2971: u32 = 5942;
pub const Z_UTIL_X2_2972: u32 = 5944;
pub const Z_UTIL_X2_2973: u32 = 5946;
pub const Z_UTIL_X2_2974: u32 = 5948;
pub const Z_UTIL_X2_2975: u32 = 5950;
pub const Z_UTIL_X2_2976: u32 = 5952;
pub const Z_UTIL_X2_2977: u32 = 5954;
pub const Z_UTIL_X2_2978: u32 = 5956;
pub const Z_UTIL_X2_2979: u32 = 5958;
pub const Z_UTIL_X2_2980: u32 = 5960;
pub const Z_UTIL_X2_2981: u32 = 5962;
pub const Z_UTIL_X2_2982: u32 = 5964;
pub const Z_UTIL_X2_2983: u32 = 5966;
pub const Z_UTIL_X2_2984: u32 = 5968;
pub const Z_UTIL_X2_2985: u32 = 5970;
pub const Z_UTIL_X2_2986: u32 = 5972;
pub const Z_UTIL_X2_2987: u32 = 5974;
pub const Z_UTIL_X2_2988: u32 = 5976;
pub const Z_UTIL_X2_2989: u32 = 5978;
pub const Z_UTIL_X2_2990: u32 = 5980;
pub const Z_UTIL_X2_2991: u32 = 5982;
pub const Z_UTIL_X2_2992: u32 = 5984;
pub const Z_UTIL_X2_2993: u32 = 5986;
pub const Z_UTIL_X2_2994: u32 = 5988;
pub const Z_UTIL_X2_2995: u32 = 5990;
pub const Z_UTIL_X2_2996: u32 = 5992;
pub const Z_UTIL_X2_2997: u32 = 5994;
pub const Z_UTIL_X2_2998: u32 = 5996;
pub const Z_UTIL_X2_2999: u32 = 5998;
pub const Z_UTIL_X2_3000: u32 = 6000;
pub const Z_UTIL_X2_3001: u32 = 6002;
pub const Z_UTIL_X2_3002: u32 = 6004;
pub const Z_UTIL_X2_3003: u32 = 6006;
pub const Z_UTIL_X2_3004: u32 = 6008;
pub const Z_UTIL_X2_3005: u32 = 6010;
pub const Z_UTIL_X2_3006: u32 = 6012;
pub const Z_UTIL_X2_3007: u32 = 6014;
pub const Z_UTIL_X2_3008: u32 = 6016;
pub const Z_UTIL_X2_3009: u32 = 6018;
pub const Z_UTIL_X2_3010: u32 = 6020;
pub const Z_UTIL_X2_3011: u32 = 6022;
pub const Z_UTIL_X2_3012: u32 = 6024;
pub const Z_UTIL_X2_3013: u32 = 6026;
pub const Z_UTIL_X2_3014: u32 = 6028;
pub const Z_UTIL_X2_3015: u32 = 6030;
pub const Z_UTIL_X2_3016: u32 = 6032;
pub const Z_UTIL_X2_3017: u32 = 6034;
pub const Z_UTIL_X2_3018: u32 = 6036;
pub const Z_UTIL_X2_3019: u32 = 6038;
pub const Z_UTIL_X2_3020: u32 = 6040;
pub const Z_UTIL_X2_3021: u32 = 6042;
pub const Z_UTIL_X2_3022: u32 = 6044;
pub const Z_UTIL_X2_3023: u32 = 6046;
pub const Z_UTIL_X2_3024: u32 = 6048;
pub const Z_UTIL_X2_3025: u32 = 6050;
pub const Z_UTIL_X2_3026: u32 = 6052;
pub const Z_UTIL_X2_3027: u32 = 6054;
pub const Z_UTIL_X2_3028: u32 = 6056;
pub const Z_UTIL_X2_3029: u32 = 6058;
pub const Z_UTIL_X2_3030: u32 = 6060;
pub const Z_UTIL_X2_3031: u32 = 6062;
pub const Z_UTIL_X2_3032: u32 = 6064;
pub const Z_UTIL_X2_3033: u32 = 6066;
pub const Z_UTIL_X2_3034: u32 = 6068;
pub const Z_UTIL_X2_3035: u32 = 6070;
pub const Z_UTIL_X2_3036: u32 = 6072;
pub const Z_UTIL_X2_3037: u32 = 6074;
pub const Z_UTIL_X2_3038: u32 = 6076;
pub const Z_UTIL_X2_3039: u32 = 6078;
pub const Z_UTIL_X2_3040: u32 = 6080;
pub const Z_UTIL_X2_3041: u32 = 6082;
pub const Z_UTIL_X2_3042: u32 = 6084;
pub const Z_UTIL_X2_3043: u32 = 6086;
pub const Z_UTIL_X2_3044: u32 = 6088;
pub const Z_UTIL_X2_3045: u32 = 6090;
pub const Z_UTIL_X2_3046: u32 = 6092;
pub const Z_UTIL_X2_3047: u32 = 6094;
pub const Z_UTIL_X2_3048: u32 = 6096;
pub const Z_UTIL_X2_3049: u32 = 6098;
pub const Z_UTIL_X2_3050: u32 = 6100;
pub const Z_UTIL_X2_3051: u32 = 6102;
pub const Z_UTIL_X2_3052: u32 = 6104;
pub const Z_UTIL_X2_3053: u32 = 6106;
pub const Z_UTIL_X2_3054: u32 = 6108;
pub const Z_UTIL_X2_3055: u32 = 6110;
pub const Z_UTIL_X2_3056: u32 = 6112;
pub const Z_UTIL_X2_3057: u32 = 6114;
pub const Z_UTIL_X2_3058: u32 = 6116;
pub const Z_UTIL_X2_3059: u32 = 6118;
pub const Z_UTIL_X2_3060: u32 = 6120;
pub const Z_UTIL_X2_3061: u32 = 6122;
pub const Z_UTIL_X2_3062: u32 = 6124;
pub const Z_UTIL_X2_3063: u32 = 6126;
pub const Z_UTIL_X2_3064: u32 = 6128;
pub const Z_UTIL_X2_3065: u32 = 6130;
pub const Z_UTIL_X2_3066: u32 = 6132;
pub const Z_UTIL_X2_3067: u32 = 6134;
pub const Z_UTIL_X2_3068: u32 = 6136;
pub const Z_UTIL_X2_3069: u32 = 6138;
pub const Z_UTIL_X2_3070: u32 = 6140;
pub const Z_UTIL_X2_3071: u32 = 6142;
pub const Z_UTIL_X2_3072: u32 = 6144;
pub const Z_UTIL_X2_3073: u32 = 6146;
pub const Z_UTIL_X2_3074: u32 = 6148;
pub const Z_UTIL_X2_3075: u32 = 6150;
pub const Z_UTIL_X2_3076: u32 = 6152;
pub const Z_UTIL_X2_3077: u32 = 6154;
pub const Z_UTIL_X2_3078: u32 = 6156;
pub const Z_UTIL_X2_3079: u32 = 6158;
pub const Z_UTIL_X2_3080: u32 = 6160;
pub const Z_UTIL_X2_3081: u32 = 6162;
pub const Z_UTIL_X2_3082: u32 = 6164;
pub const Z_UTIL_X2_3083: u32 = 6166;
pub const Z_UTIL_X2_3084: u32 = 6168;
pub const Z_UTIL_X2_3085: u32 = 6170;
pub const Z_UTIL_X2_3086: u32 = 6172;
pub const Z_UTIL_X2_3087: u32 = 6174;
pub const Z_UTIL_X2_3088: u32 = 6176;
pub const Z_UTIL_X2_3089: u32 = 6178;
pub const Z_UTIL_X2_3090: u32 = 6180;
pub const Z_UTIL_X2_3091: u32 = 6182;
pub const Z_UTIL_X2_3092: u32 = 6184;
pub const Z_UTIL_X2_3093: u32 = 6186;
pub const Z_UTIL_X2_3094: u32 = 6188;
pub const Z_UTIL_X2_3095: u32 = 6190;
pub const Z_UTIL_X2_3096: u32 = 6192;
pub const Z_UTIL_X2_3097: u32 = 6194;
pub const Z_UTIL_X2_3098: u32 = 6196;
pub const Z_UTIL_X2_3099: u32 = 6198;
pub const Z_UTIL_X2_3100: u32 = 6200;
pub const Z_UTIL_X2_3101: u32 = 6202;
pub const Z_UTIL_X2_3102: u32 = 6204;
pub const Z_UTIL_X2_3103: u32 = 6206;
pub const Z_UTIL_X2_3104: u32 = 6208;
pub const Z_UTIL_X2_3105: u32 = 6210;
pub const Z_UTIL_X2_3106: u32 = 6212;
pub const Z_UTIL_X2_3107: u32 = 6214;
pub const Z_UTIL_X2_3108: u32 = 6216;
pub const Z_UTIL_X2_3109: u32 = 6218;
pub const Z_UTIL_X2_3110: u32 = 6220;
pub const Z_UTIL_X2_3111: u32 = 6222;
pub const Z_UTIL_X2_3112: u32 = 6224;
pub const Z_UTIL_X2_3113: u32 = 6226;
pub const Z_UTIL_X2_3114: u32 = 6228;
pub const Z_UTIL_X2_3115: u32 = 6230;
pub const Z_UTIL_X2_3116: u32 = 6232;
pub const Z_UTIL_X2_3117: u32 = 6234;
pub const Z_UTIL_X2_3118: u32 = 6236;
pub const Z_UTIL_X2_3119: u32 = 6238;
pub const Z_UTIL_X2_3120: u32 = 6240;
pub const Z_UTIL_X2_3121: u32 = 6242;
pub const Z_UTIL_X2_3122: u32 = 6244;
pub const Z_UTIL_X2_3123: u32 = 6246;
pub const Z_UTIL_X2_3124: u32 = 6248;
pub const Z_UTIL_X2_3125: u32 = 6250;
pub const Z_UTIL_X2_3126: u32 = 6252;
pub const Z_UTIL_X2_3127: u32 = 6254;
pub const Z_UTIL_X2_3128: u32 = 6256;
pub const Z_UTIL_X2_3129: u32 = 6258;
pub const Z_UTIL_X2_3130: u32 = 6260;
pub const Z_UTIL_X2_3131: u32 = 6262;
pub const Z_UTIL_X2_3132: u32 = 6264;
pub const Z_UTIL_X2_3133: u32 = 6266;
pub const Z_UTIL_X2_3134: u32 = 6268;
pub const Z_UTIL_X2_3135: u32 = 6270;
pub const Z_UTIL_X2_3136: u32 = 6272;
pub const Z_UTIL_X2_3137: u32 = 6274;
pub const Z_UTIL_X2_3138: u32 = 6276;
pub const Z_UTIL_X2_3139: u32 = 6278;
pub const Z_UTIL_X2_3140: u32 = 6280;
pub const Z_UTIL_X2_3141: u32 = 6282;
pub const Z_UTIL_X2_3142: u32 = 6284;
pub const Z_UTIL_X2_3143: u32 = 6286;
pub const Z_UTIL_X2_3144: u32 = 6288;
pub const Z_UTIL_X2_3145: u32 = 6290;
pub const Z_UTIL_X2_3146: u32 = 6292;
pub const Z_UTIL_X2_3147: u32 = 6294;
pub const Z_UTIL_X2_3148: u32 = 6296;
pub const Z_UTIL_X2_3149: u32 = 6298;
pub const Z_UTIL_X2_3150: u32 = 6300;
pub const Z_UTIL_X2_3151: u32 = 6302;
pub const Z_UTIL_X2_3152: u32 = 6304;
pub const Z_UTIL_X2_3153: u32 = 6306;
pub const Z_UTIL_X2_3154: u32 = 6308;
pub const Z_UTIL_X2_3155: u32 = 6310;
pub const Z_UTIL_X2_3156: u32 = 6312;
pub const Z_UTIL_X2_3157: u32 = 6314;
pub const Z_UTIL_X2_3158: u32 = 6316;
pub const Z_UTIL_X2_3159: u32 = 6318;
pub const Z_UTIL_X2_3160: u32 = 6320;
pub const Z_UTIL_X2_3161: u32 = 6322;
pub const Z_UTIL_X2_3162: u32 = 6324;
pub const Z_UTIL_X2_3163: u32 = 6326;
pub const Z_UTIL_X2_3164: u32 = 6328;
pub const Z_UTIL_X2_3165: u32 = 6330;
pub const Z_UTIL_X2_3166: u32 = 6332;
pub const Z_UTIL_X2_3167: u32 = 6334;
pub const Z_UTIL_X2_3168: u32 = 6336;
pub const Z_UTIL_X2_3169: u32 = 6338;
pub const Z_UTIL_X2_3170: u32 = 6340;
pub const Z_UTIL_X2_3171: u32 = 6342;
pub const Z_UTIL_X2_3172: u32 = 6344;
pub const Z_UTIL_X2_3173: u32 = 6346;
pub const Z_UTIL_X2_3174: u32 = 6348;
pub const Z_UTIL_X2_3175: u32 = 6350;
pub const Z_UTIL_X2_3176: u32 = 6352;
pub const Z_UTIL_X2_3177: u32 = 6354;
pub const Z_UTIL_X2_3178: u32 = 6356;
pub const Z_UTIL_X2_3179: u32 = 6358;
pub const Z_UTIL_X2_3180: u32 = 6360;
pub const Z_UTIL_X2_3181: u32 = 6362;
pub const Z_UTIL_X2_3182: u32 = 6364;
pub const Z_UTIL_X2_3183: u32 = 6366;
pub const Z_UTIL_X2_3184: u32 = 6368;
pub const Z_UTIL_X2_3185: u32 = 6370;
pub const Z_UTIL_X2_3186: u32 = 6372;
pub const Z_UTIL_X2_3187: u32 = 6374;
pub const Z_UTIL_X2_3188: u32 = 6376;
pub const Z_UTIL_X2_3189: u32 = 6378;
pub const Z_UTIL_X2_3190: u32 = 6380;
pub const Z_UTIL_X2_3191: u32 = 6382;
pub const Z_UTIL_X2_3192: u32 = 6384;
pub const Z_UTIL_X2_3193: u32 = 6386;
pub const Z_UTIL_X2_3194: u32 = 6388;
pub const Z_UTIL_X2_3195: u32 = 6390;
pub const Z_UTIL_X2_3196: u32 = 6392;
pub const Z_UTIL_X2_3197: u32 = 6394;
pub const Z_UTIL_X2_3198: u32 = 6396;
pub const Z_UTIL_X2_3199: u32 = 6398;
pub const Z_UTIL_X2_3200: u32 = 6400;
pub const Z_UTIL_X2_3201: u32 = 6402;
pub const Z_UTIL_X2_3202: u32 = 6404;
pub const Z_UTIL_X2_3203: u32 = 6406;
pub const Z_UTIL_X2_3204: u32 = 6408;
pub const Z_UTIL_X2_3205: u32 = 6410;
pub const Z_UTIL_X2_3206: u32 = 6412;
pub const Z_UTIL_X2_3207: u32 = 6414;
pub const Z_UTIL_X2_3208: u32 = 6416;
pub const Z_UTIL_X2_3209: u32 = 6418;
pub const Z_UTIL_X2_3210: u32 = 6420;
pub const Z_UTIL_X2_3211: u32 = 6422;
pub const Z_UTIL_X2_3212: u32 = 6424;
pub const Z_UTIL_X2_3213: u32 = 6426;
pub const Z_UTIL_X2_3214: u32 = 6428;
pub const Z_UTIL_X2_3215: u32 = 6430;
pub const Z_UTIL_X2_3216: u32 = 6432;
pub const Z_UTIL_X2_3217: u32 = 6434;
pub const Z_UTIL_X2_3218: u32 = 6436;
pub const Z_UTIL_X2_3219: u32 = 6438;
pub const Z_UTIL_X2_3220: u32 = 6440;
pub const Z_UTIL_X2_3221: u32 = 6442;
pub const Z_UTIL_X2_3222: u32 = 6444;
pub const Z_UTIL_X2_3223: u32 = 6446;
pub const Z_UTIL_X2_3224: u32 = 6448;
pub const Z_UTIL_X2_3225: u32 = 6450;
pub const Z_UTIL_X2_3226: u32 = 6452;
pub const Z_UTIL_X2_3227: u32 = 6454;
pub const Z_UTIL_X2_3228: u32 = 6456;
pub const Z_UTIL_X2_3229: u32 = 6458;
pub const Z_UTIL_X2_3230: u32 = 6460;
pub const Z_UTIL_X2_3231: u32 = 6462;
pub const Z_UTIL_X2_3232: u32 = 6464;
pub const Z_UTIL_X2_3233: u32 = 6466;
pub const Z_UTIL_X2_3234: u32 = 6468;
pub const Z_UTIL_X2_3235: u32 = 6470;
pub const Z_UTIL_X2_3236: u32 = 6472;
pub const Z_UTIL_X2_3237: u32 = 6474;
pub const Z_UTIL_X2_3238: u32 = 6476;
pub const Z_UTIL_X2_3239: u32 = 6478;
pub const Z_UTIL_X2_3240: u32 = 6480;
pub const Z_UTIL_X2_3241: u32 = 6482;
pub const Z_UTIL_X2_3242: u32 = 6484;
pub const Z_UTIL_X2_3243: u32 = 6486;
pub const Z_UTIL_X2_3244: u32 = 6488;
pub const Z_UTIL_X2_3245: u32 = 6490;
pub const Z_UTIL_X2_3246: u32 = 6492;
pub const Z_UTIL_X2_3247: u32 = 6494;
pub const Z_UTIL_X2_3248: u32 = 6496;
pub const Z_UTIL_X2_3249: u32 = 6498;
pub const Z_UTIL_X2_3250: u32 = 6500;
pub const Z_UTIL_X2_3251: u32 = 6502;
pub const Z_UTIL_X2_3252: u32 = 6504;
pub const Z_UTIL_X2_3253: u32 = 6506;
pub const Z_UTIL_X2_3254: u32 = 6508;
pub const Z_UTIL_X2_3255: u32 = 6510;
pub const Z_UTIL_X2_3256: u32 = 6512;
pub const Z_UTIL_X2_3257: u32 = 6514;
pub const Z_UTIL_X2_3258: u32 = 6516;
pub const Z_UTIL_X2_3259: u32 = 6518;
pub const Z_UTIL_X2_3260: u32 = 6520;
pub const Z_UTIL_X2_3261: u32 = 6522;
pub const Z_UTIL_X2_3262: u32 = 6524;
pub const Z_UTIL_X2_3263: u32 = 6526;
pub const Z_UTIL_X2_3264: u32 = 6528;
pub const Z_UTIL_X2_3265: u32 = 6530;
pub const Z_UTIL_X2_3266: u32 = 6532;
pub const Z_UTIL_X2_3267: u32 = 6534;
pub const Z_UTIL_X2_3268: u32 = 6536;
pub const Z_UTIL_X2_3269: u32 = 6538;
pub const Z_UTIL_X2_3270: u32 = 6540;
pub const Z_UTIL_X2_3271: u32 = 6542;
pub const Z_UTIL_X2_3272: u32 = 6544;
pub const Z_UTIL_X2_3273: u32 = 6546;
pub const Z_UTIL_X2_3274: u32 = 6548;
pub const Z_UTIL_X2_3275: u32 = 6550;
pub const Z_UTIL_X2_3276: u32 = 6552;
pub const Z_UTIL_X2_3277: u32 = 6554;
pub const Z_UTIL_X2_3278: u32 = 6556;
pub const Z_UTIL_X2_3279: u32 = 6558;
pub const Z_UTIL_X2_3280: u32 = 6560;
pub const Z_UTIL_X2_3281: u32 = 6562;
pub const Z_UTIL_X2_3282: u32 = 6564;
pub const Z_UTIL_X2_3283: u32 = 6566;
pub const Z_UTIL_X2_3284: u32 = 6568;
pub const Z_UTIL_X2_3285: u32 = 6570;
pub const Z_UTIL_X2_3286: u32 = 6572;
pub const Z_UTIL_X2_3287: u32 = 6574;
pub const Z_UTIL_X2_3288: u32 = 6576;
pub const Z_UTIL_X2_3289: u32 = 6578;
pub const Z_UTIL_X2_3290: u32 = 6580;
pub const Z_UTIL_X2_3291: u32 = 6582;
pub const Z_UTIL_X2_3292: u32 = 6584;
pub const Z_UTIL_X2_3293: u32 = 6586;
pub const Z_UTIL_X2_3294: u32 = 6588;
pub const Z_UTIL_X2_3295: u32 = 6590;
pub const Z_UTIL_X2_3296: u32 = 6592;
pub const Z_UTIL_X2_3297: u32 = 6594;
pub const Z_UTIL_X2_3298: u32 = 6596;
pub const Z_UTIL_X2_3299: u32 = 6598;
pub const Z_UTIL_X2_3300: u32 = 6600;
pub const Z_UTIL_X2_3301: u32 = 6602;
pub const Z_UTIL_X2_3302: u32 = 6604;
pub const Z_UTIL_X2_3303: u32 = 6606;
pub const Z_UTIL_X2_3304: u32 = 6608;
pub const Z_UTIL_X2_3305: u32 = 6610;
pub const Z_UTIL_X2_3306: u32 = 6612;
pub const Z_UTIL_X2_3307: u32 = 6614;
pub const Z_UTIL_X2_3308: u32 = 6616;
pub const Z_UTIL_X2_3309: u32 = 6618;
pub const Z_UTIL_X2_3310: u32 = 6620;
pub const Z_UTIL_X2_3311: u32 = 6622;
pub const Z_UTIL_X2_3312: u32 = 6624;
pub const Z_UTIL_X2_3313: u32 = 6626;
pub const Z_UTIL_X2_3314: u32 = 6628;
pub const Z_UTIL_X2_3315: u32 = 6630;
pub const Z_UTIL_X2_3316: u32 = 6632;
pub const Z_UTIL_X2_3317: u32 = 6634;
pub const Z_UTIL_X2_3318: u32 = 6636;
pub const Z_UTIL_X2_3319: u32 = 6638;
pub const Z_UTIL_X2_3320: u32 = 6640;
pub const Z_UTIL_X2_3321: u32 = 6642;
pub const Z_UTIL_X2_3322: u32 = 6644;
pub const Z_UTIL_X2_3323: u32 = 6646;
pub const Z_UTIL_X2_3324: u32 = 6648;
pub const Z_UTIL_X2_3325: u32 = 6650;
pub const Z_UTIL_X2_3326: u32 = 6652;
pub const Z_UTIL_X2_3327: u32 = 6654;
pub const Z_UTIL_X2_3328: u32 = 6656;
pub const Z_UTIL_X2_3329: u32 = 6658;
pub const Z_UTIL_X2_3330: u32 = 6660;
pub const Z_UTIL_X2_3331: u32 = 6662;
pub const Z_UTIL_X2_3332: u32 = 6664;
pub const Z_UTIL_X2_3333: u32 = 6666;
pub const Z_UTIL_X2_3334: u32 = 6668;
pub const Z_UTIL_X2_3335: u32 = 6670;
pub const Z_UTIL_X2_3336: u32 = 6672;
pub const Z_UTIL_X2_3337: u32 = 6674;
pub const Z_UTIL_X2_3338: u32 = 6676;
pub const Z_UTIL_X2_3339: u32 = 6678;
pub const Z_UTIL_X2_3340: u32 = 6680;
pub const Z_UTIL_X2_3341: u32 = 6682;
pub const Z_UTIL_X2_3342: u32 = 6684;
pub const Z_UTIL_X2_3343: u32 = 6686;
pub const Z_UTIL_X2_3344: u32 = 6688;
pub const Z_UTIL_X2_3345: u32 = 6690;
pub const Z_UTIL_X2_3346: u32 = 6692;
pub const Z_UTIL_X2_3347: u32 = 6694;
pub const Z_UTIL_X2_3348: u32 = 6696;
pub const Z_UTIL_X2_3349: u32 = 6698;
pub const Z_UTIL_X2_3350: u32 = 6700;
pub const Z_UTIL_X2_3351: u32 = 6702;
pub const Z_UTIL_X2_3352: u32 = 6704;
pub const Z_UTIL_X2_3353: u32 = 6706;
pub const Z_UTIL_X2_3354: u32 = 6708;
pub const Z_UTIL_X2_3355: u32 = 6710;
pub const Z_UTIL_X2_3356: u32 = 6712;
pub const Z_UTIL_X2_3357: u32 = 6714;
pub const Z_UTIL_X2_3358: u32 = 6716;
pub const Z_UTIL_X2_3359: u32 = 6718;
pub const Z_UTIL_X2_3360: u32 = 6720;
pub const Z_UTIL_X2_3361: u32 = 6722;
pub const Z_UTIL_X2_3362: u32 = 6724;
pub const Z_UTIL_X2_3363: u32 = 6726;
pub const Z_UTIL_X2_3364: u32 = 6728;
pub const Z_UTIL_X2_3365: u32 = 6730;
pub const Z_UTIL_X2_3366: u32 = 6732;
pub const Z_UTIL_X2_3367: u32 = 6734;
pub const Z_UTIL_X2_3368: u32 = 6736;
pub const Z_UTIL_X2_3369: u32 = 6738;
pub const Z_UTIL_X2_3370: u32 = 6740;
pub const Z_UTIL_X2_3371: u32 = 6742;
pub const Z_UTIL_X2_3372: u32 = 6744;
pub const Z_UTIL_X2_3373: u32 = 6746;
pub const Z_UTIL_X2_3374: u32 = 6748;
pub const Z_UTIL_X2_3375: u32 = 6750;
pub const Z_UTIL_X2_3376: u32 = 6752;
pub const Z_UTIL_X2_3377: u32 = 6754;
pub const Z_UTIL_X2_3378: u32 = 6756;
pub const Z_UTIL_X2_3379: u32 = 6758;
pub const Z_UTIL_X2_3380: u32 = 6760;
pub const Z_UTIL_X2_3381: u32 = 6762;
pub const Z_UTIL_X2_3382: u32 = 6764;
pub const Z_UTIL_X2_3383: u32 = 6766;
pub const Z_UTIL_X2_3384: u32 = 6768;
pub const Z_UTIL_X2_3385: u32 = 6770;
pub const Z_UTIL_X2_3386: u32 = 6772;
pub const Z_UTIL_X2_3387: u32 = 6774;
pub const Z_UTIL_X2_3388: u32 = 6776;
pub const Z_UTIL_X2_3389: u32 = 6778;
pub const Z_UTIL_X2_3390: u32 = 6780;
pub const Z_UTIL_X2_3391: u32 = 6782;
pub const Z_UTIL_X2_3392: u32 = 6784;
pub const Z_UTIL_X2_3393: u32 = 6786;
pub const Z_UTIL_X2_3394: u32 = 6788;
pub const Z_UTIL_X2_3395: u32 = 6790;
pub const Z_UTIL_X2_3396: u32 = 6792;
pub const Z_UTIL_X2_3397: u32 = 6794;
pub const Z_UTIL_X2_3398: u32 = 6796;
pub const Z_UTIL_X2_3399: u32 = 6798;
pub const Z_UTIL_X2_3400: u32 = 6800;
pub const Z_UTIL_X2_3401: u32 = 6802;
pub const Z_UTIL_X2_3402: u32 = 6804;
pub const Z_UTIL_X2_3403: u32 = 6806;
pub const Z_UTIL_X2_3404: u32 = 6808;
pub const Z_UTIL_X2_3405: u32 = 6810;
pub const Z_UTIL_X2_3406: u32 = 6812;
pub const Z_UTIL_X2_3407: u32 = 6814;
pub const Z_UTIL_X2_3408: u32 = 6816;
pub const Z_UTIL_X2_3409: u32 = 6818;
pub const Z_UTIL_X2_3410: u32 = 6820;
pub const Z_UTIL_X2_3411: u32 = 6822;
pub const Z_UTIL_X2_3412: u32 = 6824;
pub const Z_UTIL_X2_3413: u32 = 6826;
pub const Z_UTIL_X2_3414: u32 = 6828;
pub const Z_UTIL_X2_3415: u32 = 6830;
pub const Z_UTIL_X2_3416: u32 = 6832;
pub const Z_UTIL_X2_3417: u32 = 6834;
pub const Z_UTIL_X2_3418: u32 = 6836;
pub const Z_UTIL_X2_3419: u32 = 6838;
pub const Z_UTIL_X2_3420: u32 = 6840;
pub const Z_UTIL_X2_3421: u32 = 6842;
pub const Z_UTIL_X2_3422: u32 = 6844;
pub const Z_UTIL_X2_3423: u32 = 6846;
pub const Z_UTIL_X2_3424: u32 = 6848;
pub const Z_UTIL_X2_3425: u32 = 6850;
pub const Z_UTIL_X2_3426: u32 = 6852;
pub const Z_UTIL_X2_3427: u32 = 6854;
pub const Z_UTIL_X2_3428: u32 = 6856;
pub const Z_UTIL_X2_3429: u32 = 6858;
pub const Z_UTIL_X2_3430: u32 = 6860;
pub const Z_UTIL_X2_3431: u32 = 6862;
pub const Z_UTIL_X2_3432: u32 = 6864;
pub const Z_UTIL_X2_3433: u32 = 6866;
pub const Z_UTIL_X2_3434: u32 = 6868;
pub const Z_UTIL_X2_3435: u32 = 6870;
pub const Z_UTIL_X2_3436: u32 = 6872;
pub const Z_UTIL_X2_3437: u32 = 6874;
pub const Z_UTIL_X2_3438: u32 = 6876;
pub const Z_UTIL_X2_3439: u32 = 6878;
pub const Z_UTIL_X2_3440: u32 = 6880;
pub const Z_UTIL_X2_3441: u32 = 6882;
pub const Z_UTIL_X2_3442: u32 = 6884;
pub const Z_UTIL_X2_3443: u32 = 6886;
pub const Z_UTIL_X2_3444: u32 = 6888;
pub const Z_UTIL_X2_3445: u32 = 6890;
pub const Z_UTIL_X2_3446: u32 = 6892;
pub const Z_UTIL_X2_3447: u32 = 6894;
pub const Z_UTIL_X2_3448: u32 = 6896;
pub const Z_UTIL_X2_3449: u32 = 6898;
pub const Z_UTIL_X2_3450: u32 = 6900;
pub const Z_UTIL_X2_3451: u32 = 6902;
pub const Z_UTIL_X2_3452: u32 = 6904;
pub const Z_UTIL_X2_3453: u32 = 6906;
pub const Z_UTIL_X2_3454: u32 = 6908;
pub const Z_UTIL_X2_3455: u32 = 6910;
pub const Z_UTIL_X2_3456: u32 = 6912;
pub const Z_UTIL_X2_3457: u32 = 6914;
pub const Z_UTIL_X2_3458: u32 = 6916;
pub const Z_UTIL_X2_3459: u32 = 6918;
pub const Z_UTIL_X2_3460: u32 = 6920;
pub const Z_UTIL_X2_3461: u32 = 6922;
pub const Z_UTIL_X2_3462: u32 = 6924;
pub const Z_UTIL_X2_3463: u32 = 6926;
pub const Z_UTIL_X2_3464: u32 = 6928;
pub const Z_UTIL_X2_3465: u32 = 6930;
pub const Z_UTIL_X2_3466: u32 = 6932;
pub const Z_UTIL_X2_3467: u32 = 6934;
pub const Z_UTIL_X2_3468: u32 = 6936;
pub const Z_UTIL_X2_3469: u32 = 6938;
pub const Z_UTIL_X2_3470: u32 = 6940;
pub const Z_UTIL_X2_3471: u32 = 6942;
pub const Z_UTIL_X2_3472: u32 = 6944;
pub const Z_UTIL_X2_3473: u32 = 6946;
pub const Z_UTIL_X2_3474: u32 = 6948;
pub const Z_UTIL_X2_3475: u32 = 6950;
pub const Z_UTIL_X2_3476: u32 = 6952;
pub const Z_UTIL_X2_3477: u32 = 6954;
pub const Z_UTIL_X2_3478: u32 = 6956;
pub const Z_UTIL_X2_3479: u32 = 6958;
pub const Z_UTIL_X2_3480: u32 = 6960;
pub const Z_UTIL_X2_3481: u32 = 6962;
pub const Z_UTIL_X2_3482: u32 = 6964;
pub const Z_UTIL_X2_3483: u32 = 6966;
pub const Z_UTIL_X2_3484: u32 = 6968;
pub const Z_UTIL_X2_3485: u32 = 6970;
pub const Z_UTIL_X2_3486: u32 = 6972;
pub const Z_UTIL_X2_3487: u32 = 6974;
pub const Z_UTIL_X2_3488: u32 = 6976;
pub const Z_UTIL_X2_3489: u32 = 6978;
pub const Z_UTIL_X2_3490: u32 = 6980;
pub const Z_UTIL_X2_3491: u32 = 6982;
pub const Z_UTIL_X2_3492: u32 = 6984;
pub const Z_UTIL_X2_3493: u32 = 6986;
pub const Z_UTIL_X2_3494: u32 = 6988;
pub const Z_UTIL_X2_3495: u32 = 6990;
pub const Z_UTIL_X2_3496: u32 = 6992;
pub const Z_UTIL_X2_3497: u32 = 6994;
pub const Z_UTIL_X2_3498: u32 = 6996;
pub const Z_UTIL_X2_3499: u32 = 6998;
pub const Z_UTIL_X2_3500: u32 = 7000;
pub const Z_UTIL_X2_3501: u32 = 7002;
pub const Z_UTIL_X2_3502: u32 = 7004;
pub const Z_UTIL_X2_3503: u32 = 7006;
pub const Z_UTIL_X2_3504: u32 = 7008;
pub const Z_UTIL_X2_3505: u32 = 7010;
pub const Z_UTIL_X2_3506: u32 = 7012;
pub const Z_UTIL_X2_3507: u32 = 7014;
pub const Z_UTIL_X2_3508: u32 = 7016;
pub const Z_UTIL_X2_3509: u32 = 7018;
pub const Z_UTIL_X2_3510: u32 = 7020;
pub const Z_UTIL_X2_3511: u32 = 7022;
pub const Z_UTIL_X2_3512: u32 = 7024;
pub const Z_UTIL_X2_3513: u32 = 7026;
pub const Z_UTIL_X2_3514: u32 = 7028;
pub const Z_UTIL_X2_3515: u32 = 7030;
pub const Z_UTIL_X2_3516: u32 = 7032;
pub const Z_UTIL_X2_3517: u32 = 7034;
pub const Z_UTIL_X2_3518: u32 = 7036;
pub const Z_UTIL_X2_3519: u32 = 7038;
pub const Z_UTIL_X2_3520: u32 = 7040;
pub const Z_UTIL_X2_3521: u32 = 7042;
pub const Z_UTIL_X2_3522: u32 = 7044;
pub const Z_UTIL_X2_3523: u32 = 7046;
pub const Z_UTIL_X2_3524: u32 = 7048;
pub const Z_UTIL_X2_3525: u32 = 7050;
pub const Z_UTIL_X2_3526: u32 = 7052;
pub const Z_UTIL_X2_3527: u32 = 7054;
pub const Z_UTIL_X2_3528: u32 = 7056;
pub const Z_UTIL_X2_3529: u32 = 7058;
pub const Z_UTIL_X2_3530: u32 = 7060;
pub const Z_UTIL_X2_3531: u32 = 7062;
pub const Z_UTIL_X2_3532: u32 = 7064;
pub const Z_UTIL_X2_3533: u32 = 7066;
pub const Z_UTIL_X2_3534: u32 = 7068;
pub const Z_UTIL_X2_3535: u32 = 7070;
pub const Z_UTIL_X2_3536: u32 = 7072;
pub const Z_UTIL_X2_3537: u32 = 7074;
pub const Z_UTIL_X2_3538: u32 = 7076;
pub const Z_UTIL_X2_3539: u32 = 7078;
pub const Z_UTIL_X2_3540: u32 = 7080;
pub const Z_UTIL_X2_3541: u32 = 7082;
pub const Z_UTIL_X2_3542: u32 = 7084;
pub const Z_UTIL_X2_3543: u32 = 7086;
pub const Z_UTIL_X2_3544: u32 = 7088;
pub const Z_UTIL_X2_3545: u32 = 7090;
pub const Z_UTIL_X2_3546: u32 = 7092;
pub const Z_UTIL_X2_3547: u32 = 7094;
pub const Z_UTIL_X2_3548: u32 = 7096;
pub const Z_UTIL_X2_3549: u32 = 7098;
pub const Z_UTIL_X2_3550: u32 = 7100;
pub const Z_UTIL_X2_3551: u32 = 7102;
pub const Z_UTIL_X2_3552: u32 = 7104;
pub const Z_UTIL_X2_3553: u32 = 7106;
pub const Z_UTIL_X2_3554: u32 = 7108;
pub const Z_UTIL_X2_3555: u32 = 7110;
pub const Z_UTIL_X2_3556: u32 = 7112;
pub const Z_UTIL_X2_3557: u32 = 7114;
pub const Z_UTIL_X2_3558: u32 = 7116;
pub const Z_UTIL_X2_3559: u32 = 7118;
pub const Z_UTIL_X2_3560: u32 = 7120;
pub const Z_UTIL_X2_3561: u32 = 7122;
pub const Z_UTIL_X2_3562: u32 = 7124;
pub const Z_UTIL_X2_3563: u32 = 7126;
pub const Z_UTIL_X2_3564: u32 = 7128;
pub const Z_UTIL_X2_3565: u32 = 7130;
pub const Z_UTIL_X2_3566: u32 = 7132;
pub const Z_UTIL_X2_3567: u32 = 7134;
pub const Z_UTIL_X2_3568: u32 = 7136;
pub const Z_UTIL_X2_3569: u32 = 7138;
pub const Z_UTIL_X2_3570: u32 = 7140;
pub const Z_UTIL_X2_3571: u32 = 7142;
pub const Z_UTIL_X2_3572: u32 = 7144;
pub const Z_UTIL_X2_3573: u32 = 7146;
pub const Z_UTIL_X2_3574: u32 = 7148;
pub const Z_UTIL_X2_3575: u32 = 7150;
pub const Z_UTIL_X2_3576: u32 = 7152;
pub const Z_UTIL_X2_3577: u32 = 7154;
pub const Z_UTIL_X2_3578: u32 = 7156;
pub const Z_UTIL_X2_3579: u32 = 7158;
pub const Z_UTIL_X2_3580: u32 = 7160;
pub const Z_UTIL_X2_3581: u32 = 7162;
pub const Z_UTIL_X2_3582: u32 = 7164;
pub const Z_UTIL_X2_3583: u32 = 7166;
pub const Z_UTIL_X2_3584: u32 = 7168;
pub const Z_UTIL_X2_3585: u32 = 7170;
pub const Z_UTIL_X2_3586: u32 = 7172;
pub const Z_UTIL_X2_3587: u32 = 7174;
pub const Z_UTIL_X2_3588: u32 = 7176;
pub const Z_UTIL_X2_3589: u32 = 7178;
pub const Z_UTIL_X2_3590: u32 = 7180;
pub const Z_UTIL_X2_3591: u32 = 7182;
pub const Z_UTIL_X2_3592: u32 = 7184;
pub const Z_UTIL_X2_3593: u32 = 7186;
pub const Z_UTIL_X2_3594: u32 = 7188;
pub const Z_UTIL_X2_3595: u32 = 7190;
pub const Z_UTIL_X2_3596: u32 = 7192;
pub const Z_UTIL_X2_3597: u32 = 7194;
pub const Z_UTIL_X2_3598: u32 = 7196;
pub const Z_UTIL_X2_3599: u32 = 7198;
pub const Z_UTIL_X2_3600: u32 = 7200;
pub const Z_UTIL_X2_3601: u32 = 7202;
pub const Z_UTIL_X2_3602: u32 = 7204;
pub const Z_UTIL_X2_3603: u32 = 7206;
pub const Z_UTIL_X2_3604: u32 = 7208;
pub const Z_UTIL_X2_3605: u32 = 7210;
pub const Z_UTIL_X2_3606: u32 = 7212;
pub const Z_UTIL_X2_3607: u32 = 7214;
pub const Z_UTIL_X2_3608: u32 = 7216;
pub const Z_UTIL_X2_3609: u32 = 7218;
pub const Z_UTIL_X2_3610: u32 = 7220;
pub const Z_UTIL_X2_3611: u32 = 7222;
pub const Z_UTIL_X2_3612: u32 = 7224;
pub const Z_UTIL_X2_3613: u32 = 7226;
pub const Z_UTIL_X2_3614: u32 = 7228;
pub const Z_UTIL_X2_3615: u32 = 7230;
pub const Z_UTIL_X2_3616: u32 = 7232;
pub const Z_UTIL_X2_3617: u32 = 7234;
pub const Z_UTIL_X2_3618: u32 = 7236;
pub const Z_UTIL_X2_3619: u32 = 7238;
pub const Z_UTIL_X2_3620: u32 = 7240;
pub const Z_UTIL_X2_3621: u32 = 7242;
pub const Z_UTIL_X2_3622: u32 = 7244;
pub const Z_UTIL_X2_3623: u32 = 7246;
pub const Z_UTIL_X2_3624: u32 = 7248;
pub const Z_UTIL_X2_3625: u32 = 7250;
pub const Z_UTIL_X2_3626: u32 = 7252;
pub const Z_UTIL_X2_3627: u32 = 7254;
pub const Z_UTIL_X2_3628: u32 = 7256;
pub const Z_UTIL_X2_3629: u32 = 7258;
pub const Z_UTIL_X2_3630: u32 = 7260;
pub const Z_UTIL_X2_3631: u32 = 7262;
pub const Z_UTIL_X2_3632: u32 = 7264;
pub const Z_UTIL_X2_3633: u32 = 7266;
pub const Z_UTIL_X2_3634: u32 = 7268;
pub const Z_UTIL_X2_3635: u32 = 7270;
pub const Z_UTIL_X2_3636: u32 = 7272;
pub const Z_UTIL_X2_3637: u32 = 7274;
pub const Z_UTIL_X2_3638: u32 = 7276;
pub const Z_UTIL_X2_3639: u32 = 7278;
pub const Z_UTIL_X2_3640: u32 = 7280;
pub const Z_UTIL_X2_3641: u32 = 7282;
pub const Z_UTIL_X2_3642: u32 = 7284;
pub const Z_UTIL_X2_3643: u32 = 7286;
pub const Z_UTIL_X2_3644: u32 = 7288;
pub const Z_UTIL_X2_3645: u32 = 7290;
pub const Z_UTIL_X2_3646: u32 = 7292;
pub const Z_UTIL_X2_3647: u32 = 7294;
pub const Z_UTIL_X2_3648: u32 = 7296;
pub const Z_UTIL_X2_3649: u32 = 7298;
pub const Z_UTIL_X2_3650: u32 = 7300;
pub const Z_UTIL_X2_3651: u32 = 7302;
pub const Z_UTIL_X2_3652: u32 = 7304;
pub const Z_UTIL_X2_3653: u32 = 7306;
pub const Z_UTIL_X2_3654: u32 = 7308;
pub const Z_UTIL_X2_3655: u32 = 7310;
pub const Z_UTIL_X2_3656: u32 = 7312;
pub const Z_UTIL_X2_3657: u32 = 7314;
pub const Z_UTIL_X2_3658: u32 = 7316;
pub const Z_UTIL_X2_3659: u32 = 7318;
pub const Z_UTIL_X2_3660: u32 = 7320;
pub const Z_UTIL_X2_3661: u32 = 7322;
pub const Z_UTIL_X2_3662: u32 = 7324;
pub const Z_UTIL_X2_3663: u32 = 7326;
pub const Z_UTIL_X2_3664: u32 = 7328;
pub const Z_UTIL_X2_3665: u32 = 7330;
pub const Z_UTIL_X2_3666: u32 = 7332;
pub const Z_UTIL_X2_3667: u32 = 7334;
pub const Z_UTIL_X2_3668: u32 = 7336;
pub const Z_UTIL_X2_3669: u32 = 7338;
pub const Z_UTIL_X2_3670: u32 = 7340;
pub const Z_UTIL_X2_3671: u32 = 7342;
pub const Z_UTIL_X2_3672: u32 = 7344;
pub const Z_UTIL_X2_3673: u32 = 7346;
pub const Z_UTIL_X2_3674: u32 = 7348;
pub const Z_UTIL_X2_3675: u32 = 7350;
pub const Z_UTIL_X2_3676: u32 = 7352;
pub const Z_UTIL_X2_3677: u32 = 7354;
pub const Z_UTIL_X2_3678: u32 = 7356;
pub const Z_UTIL_X2_3679: u32 = 7358;
pub const Z_UTIL_X2_3680: u32 = 7360;
pub const Z_UTIL_X2_3681: u32 = 7362;
pub const Z_UTIL_X2_3682: u32 = 7364;
pub const Z_UTIL_X2_3683: u32 = 7366;
pub const Z_UTIL_X2_3684: u32 = 7368;
pub const Z_UTIL_X2_3685: u32 = 7370;
pub const Z_UTIL_X2_3686: u32 = 7372;
pub const Z_UTIL_X2_3687: u32 = 7374;
pub const Z_UTIL_X2_3688: u32 = 7376;
pub const Z_UTIL_X2_3689: u32 = 7378;
pub const Z_UTIL_X2_3690: u32 = 7380;
pub const Z_UTIL_X2_3691: u32 = 7382;
pub const Z_UTIL_X2_3692: u32 = 7384;
pub const Z_UTIL_X2_3693: u32 = 7386;
pub const Z_UTIL_X2_3694: u32 = 7388;
pub const Z_UTIL_X2_3695: u32 = 7390;
pub const Z_UTIL_X2_3696: u32 = 7392;
pub const Z_UTIL_X2_3697: u32 = 7394;
pub const Z_UTIL_X2_3698: u32 = 7396;
pub const Z_UTIL_X2_3699: u32 = 7398;
pub const Z_UTIL_X2_3700: u32 = 7400;
pub const Z_UTIL_X2_3701: u32 = 7402;
pub const Z_UTIL_X2_3702: u32 = 7404;
pub const Z_UTIL_X2_3703: u32 = 7406;
pub const Z_UTIL_X2_3704: u32 = 7408;
pub const Z_UTIL_X2_3705: u32 = 7410;
pub const Z_UTIL_X2_3706: u32 = 7412;
pub const Z_UTIL_X2_3707: u32 = 7414;
pub const Z_UTIL_X2_3708: u32 = 7416;
pub const Z_UTIL_X2_3709: u32 = 7418;
pub const Z_UTIL_X2_3710: u32 = 7420;
pub const Z_UTIL_X2_3711: u32 = 7422;
pub const Z_UTIL_X2_3712: u32 = 7424;
pub const Z_UTIL_X2_3713: u32 = 7426;
pub const Z_UTIL_X2_3714: u32 = 7428;
pub const Z_UTIL_X2_3715: u32 = 7430;
pub const Z_UTIL_X2_3716: u32 = 7432;
pub const Z_UTIL_X2_3717: u32 = 7434;
pub const Z_UTIL_X2_3718: u32 = 7436;
pub const Z_UTIL_X2_3719: u32 = 7438;
pub const Z_UTIL_X2_3720: u32 = 7440;
pub const Z_UTIL_X2_3721: u32 = 7442;
pub const Z_UTIL_X2_3722: u32 = 7444;
pub const Z_UTIL_X2_3723: u32 = 7446;
pub const Z_UTIL_X2_3724: u32 = 7448;
pub const Z_UTIL_X2_3725: u32 = 7450;
pub const Z_UTIL_X2_3726: u32 = 7452;
pub const Z_UTIL_X2_3727: u32 = 7454;
pub const Z_UTIL_X2_3728: u32 = 7456;
pub const Z_UTIL_X2_3729: u32 = 7458;
pub const Z_UTIL_X2_3730: u32 = 7460;
pub const Z_UTIL_X2_3731: u32 = 7462;
pub const Z_UTIL_X2_3732: u32 = 7464;
pub const Z_UTIL_X2_3733: u32 = 7466;
pub const Z_UTIL_X2_3734: u32 = 7468;
pub const Z_UTIL_X2_3735: u32 = 7470;
pub const Z_UTIL_X2_3736: u32 = 7472;
pub const Z_UTIL_X2_3737: u32 = 7474;
pub const Z_UTIL_X2_3738: u32 = 7476;
pub const Z_UTIL_X2_3739: u32 = 7478;
pub const Z_UTIL_X2_3740: u32 = 7480;
pub const Z_UTIL_X2_3741: u32 = 7482;
pub const Z_UTIL_X2_3742: u32 = 7484;
pub const Z_UTIL_X2_3743: u32 = 7486;
pub const Z_UTIL_X2_3744: u32 = 7488;
pub const Z_UTIL_X2_3745: u32 = 7490;
pub const Z_UTIL_X2_3746: u32 = 7492;
pub const Z_UTIL_X2_3747: u32 = 7494;
pub const Z_UTIL_X2_3748: u32 = 7496;
pub const Z_UTIL_X2_3749: u32 = 7498;
pub const Z_UTIL_X2_3750: u32 = 7500;
pub const Z_UTIL_X2_3751: u32 = 7502;
pub const Z_UTIL_X2_3752: u32 = 7504;
pub const Z_UTIL_X2_3753: u32 = 7506;
pub const Z_UTIL_X2_3754: u32 = 7508;
pub const Z_UTIL_X2_3755: u32 = 7510;
pub const Z_UTIL_X2_3756: u32 = 7512;
pub const Z_UTIL_X2_3757: u32 = 7514;
pub const Z_UTIL_X2_3758: u32 = 7516;
pub const Z_UTIL_X2_3759: u32 = 7518;
pub const Z_UTIL_X2_3760: u32 = 7520;
pub const Z_UTIL_X2_3761: u32 = 7522;
pub const Z_UTIL_X2_3762: u32 = 7524;
pub const Z_UTIL_X2_3763: u32 = 7526;
pub const Z_UTIL_X2_3764: u32 = 7528;
pub const Z_UTIL_X2_3765: u32 = 7530;
pub const Z_UTIL_X2_3766: u32 = 7532;
pub const Z_UTIL_X2_3767: u32 = 7534;
pub const Z_UTIL_X2_3768: u32 = 7536;
pub const Z_UTIL_X2_3769: u32 = 7538;
pub const Z_UTIL_X2_3770: u32 = 7540;
pub const Z_UTIL_X2_3771: u32 = 7542;
pub const Z_UTIL_X2_3772: u32 = 7544;
pub const Z_UTIL_X2_3773: u32 = 7546;
pub const Z_UTIL_X2_3774: u32 = 7548;
pub const Z_UTIL_X2_3775: u32 = 7550;
pub const Z_UTIL_X2_3776: u32 = 7552;
pub const Z_UTIL_X2_3777: u32 = 7554;
pub const Z_UTIL_X2_3778: u32 = 7556;
pub const Z_UTIL_X2_3779: u32 = 7558;
pub const Z_UTIL_X2_3780: u32 = 7560;
pub const Z_UTIL_X2_3781: u32 = 7562;
pub const Z_UTIL_X2_3782: u32 = 7564;
pub const Z_UTIL_X2_3783: u32 = 7566;
pub const Z_UTIL_X2_3784: u32 = 7568;
pub const Z_UTIL_X2_3785: u32 = 7570;
pub const Z_UTIL_X2_3786: u32 = 7572;
pub const Z_UTIL_X2_3787: u32 = 7574;
pub const Z_UTIL_X2_3788: u32 = 7576;
pub const Z_UTIL_X2_3789: u32 = 7578;
pub const Z_UTIL_X2_3790: u32 = 7580;
pub const Z_UTIL_X2_3791: u32 = 7582;
pub const Z_UTIL_X2_3792: u32 = 7584;
pub const Z_UTIL_X2_3793: u32 = 7586;
pub const Z_UTIL_X2_3794: u32 = 7588;
pub const Z_UTIL_X2_3795: u32 = 7590;
pub const Z_UTIL_X2_3796: u32 = 7592;
pub const Z_UTIL_X2_3797: u32 = 7594;
pub const Z_UTIL_X2_3798: u32 = 7596;
pub const Z_UTIL_X2_3799: u32 = 7598;
pub const Z_UTIL_X2_3800: u32 = 7600;
pub const Z_UTIL_X2_3801: u32 = 7602;
pub const Z_UTIL_X2_3802: u32 = 7604;
pub const Z_UTIL_X2_3803: u32 = 7606;
pub const Z_UTIL_X2_3804: u32 = 7608;
pub const Z_UTIL_X2_3805: u32 = 7610;
pub const Z_UTIL_X2_3806: u32 = 7612;
pub const Z_UTIL_X2_3807: u32 = 7614;
pub const Z_UTIL_X2_3808: u32 = 7616;
pub const Z_UTIL_X2_3809: u32 = 7618;
pub const Z_UTIL_X2_3810: u32 = 7620;
pub const Z_UTIL_X2_3811: u32 = 7622;
pub const Z_UTIL_X2_3812: u32 = 7624;
pub const Z_UTIL_X2_3813: u32 = 7626;
pub const Z_UTIL_X2_3814: u32 = 7628;
pub const Z_UTIL_X2_3815: u32 = 7630;
pub const Z_UTIL_X2_3816: u32 = 7632;
pub const Z_UTIL_X2_3817: u32 = 7634;
pub const Z_UTIL_X2_3818: u32 = 7636;
pub const Z_UTIL_X2_3819: u32 = 7638;
pub const Z_UTIL_X2_3820: u32 = 7640;
pub const Z_UTIL_X2_3821: u32 = 7642;
pub const Z_UTIL_X2_3822: u32 = 7644;
pub const Z_UTIL_X2_3823: u32 = 7646;
pub const Z_UTIL_X2_3824: u32 = 7648;
pub const Z_UTIL_X2_3825: u32 = 7650;
pub const Z_UTIL_X2_3826: u32 = 7652;
pub const Z_UTIL_X2_3827: u32 = 7654;
pub const Z_UTIL_X2_3828: u32 = 7656;
pub const Z_UTIL_X2_3829: u32 = 7658;
pub const Z_UTIL_X2_3830: u32 = 7660;
pub const Z_UTIL_X2_3831: u32 = 7662;
pub const Z_UTIL_X2_3832: u32 = 7664;
pub const Z_UTIL_X2_3833: u32 = 7666;
pub const Z_UTIL_X2_3834: u32 = 7668;
pub const Z_UTIL_X2_3835: u32 = 7670;
pub const Z_UTIL_X2_3836: u32 = 7672;
pub const Z_UTIL_X2_3837: u32 = 7674;
pub const Z_UTIL_X2_3838: u32 = 7676;
pub const Z_UTIL_X2_3839: u32 = 7678;
pub const Z_UTIL_X2_3840: u32 = 7680;
pub const Z_UTIL_X2_3841: u32 = 7682;
pub const Z_UTIL_X2_3842: u32 = 7684;
pub const Z_UTIL_X2_3843: u32 = 7686;
pub const Z_UTIL_X2_3844: u32 = 7688;
pub const Z_UTIL_X2_3845: u32 = 7690;
pub const Z_UTIL_X2_3846: u32 = 7692;
pub const Z_UTIL_X2_3847: u32 = 7694;
pub const Z_UTIL_X2_3848: u32 = 7696;
pub const Z_UTIL_X2_3849: u32 = 7698;
pub const Z_UTIL_X2_3850: u32 = 7700;
pub const Z_UTIL_X2_3851: u32 = 7702;
pub const Z_UTIL_X2_3852: u32 = 7704;
pub const Z_UTIL_X2_3853: u32 = 7706;
pub const Z_UTIL_X2_3854: u32 = 7708;
pub const Z_UTIL_X2_3855: u32 = 7710;
pub const Z_UTIL_X2_3856: u32 = 7712;
pub const Z_UTIL_X2_3857: u32 = 7714;
pub const Z_UTIL_X2_3858: u32 = 7716;
pub const Z_UTIL_X2_3859: u32 = 7718;
pub const Z_UTIL_X2_3860: u32 = 7720;
pub const Z_UTIL_X2_3861: u32 = 7722;
pub const Z_UTIL_X2_3862: u32 = 7724;
pub const Z_UTIL_X2_3863: u32 = 7726;
pub const Z_UTIL_X2_3864: u32 = 7728;
pub const Z_UTIL_X2_3865: u32 = 7730;
pub const Z_UTIL_X2_3866: u32 = 7732;
pub const Z_UTIL_X2_3867: u32 = 7734;
pub const Z_UTIL_X2_3868: u32 = 7736;
pub const Z_UTIL_X2_3869: u32 = 7738;
pub const Z_UTIL_X2_3870: u32 = 7740;
pub const Z_UTIL_X2_3871: u32 = 7742;
pub const Z_UTIL_X2_3872: u32 = 7744;
pub const Z_UTIL_X2_3873: u32 = 7746;
pub const Z_UTIL_X2_3874: u32 = 7748;
pub const Z_UTIL_X2_3875: u32 = 7750;
pub const Z_UTIL_X2_3876: u32 = 7752;
pub const Z_UTIL_X2_3877: u32 = 7754;
pub const Z_UTIL_X2_3878: u32 = 7756;
pub const Z_UTIL_X2_3879: u32 = 7758;
pub const Z_UTIL_X2_3880: u32 = 7760;
pub const Z_UTIL_X2_3881: u32 = 7762;
pub const Z_UTIL_X2_3882: u32 = 7764;
pub const Z_UTIL_X2_3883: u32 = 7766;
pub const Z_UTIL_X2_3884: u32 = 7768;
pub const Z_UTIL_X2_3885: u32 = 7770;
pub const Z_UTIL_X2_3886: u32 = 7772;
pub const Z_UTIL_X2_3887: u32 = 7774;
pub const Z_UTIL_X2_3888: u32 = 7776;
pub const Z_UTIL_X2_3889: u32 = 7778;
pub const Z_UTIL_X2_3890: u32 = 7780;
pub const Z_UTIL_X2_3891: u32 = 7782;
pub const Z_UTIL_X2_3892: u32 = 7784;
pub const Z_UTIL_X2_3893: u32 = 7786;
pub const Z_UTIL_X2_3894: u32 = 7788;
pub const Z_UTIL_X2_3895: u32 = 7790;
pub const Z_UTIL_X2_3896: u32 = 7792;
pub const Z_UTIL_X2_3897: u32 = 7794;
pub const Z_UTIL_X2_3898: u32 = 7796;
pub const Z_UTIL_X2_3899: u32 = 7798;
pub const Z_UTIL_X2_3900: u32 = 7800;
pub const Z_UTIL_X2_3901: u32 = 7802;
pub const Z_UTIL_X2_3902: u32 = 7804;
pub const Z_UTIL_X2_3903: u32 = 7806;
pub const Z_UTIL_X2_3904: u32 = 7808;
pub const Z_UTIL_X2_3905: u32 = 7810;
pub const Z_UTIL_X2_3906: u32 = 7812;
pub const Z_UTIL_X2_3907: u32 = 7814;
pub const Z_UTIL_X2_3908: u32 = 7816;
pub const Z_UTIL_X2_3909: u32 = 7818;
pub const Z_UTIL_X2_3910: u32 = 7820;
pub const Z_UTIL_X2_3911: u32 = 7822;
pub const Z_UTIL_X2_3912: u32 = 7824;
pub const Z_UTIL_X2_3913: u32 = 7826;
pub const Z_UTIL_X2_3914: u32 = 7828;
pub const Z_UTIL_X2_3915: u32 = 7830;
pub const Z_UTIL_X2_3916: u32 = 7832;
pub const Z_UTIL_X2_3917: u32 = 7834;
pub const Z_UTIL_X2_3918: u32 = 7836;
pub const Z_UTIL_X2_3919: u32 = 7838;
pub const Z_UTIL_X2_3920: u32 = 7840;
pub const Z_UTIL_X2_3921: u32 = 7842;
pub const Z_UTIL_X2_3922: u32 = 7844;
pub const Z_UTIL_X2_3923: u32 = 7846;
pub const Z_UTIL_X2_3924: u32 = 7848;
pub const Z_UTIL_X2_3925: u32 = 7850;
pub const Z_UTIL_X2_3926: u32 = 7852;
pub const Z_UTIL_X2_3927: u32 = 7854;
pub const Z_UTIL_X2_3928: u32 = 7856;
pub const Z_UTIL_X2_3929: u32 = 7858;
pub const Z_UTIL_X2_3930: u32 = 7860;
pub const Z_UTIL_X2_3931: u32 = 7862;
pub const Z_UTIL_X2_3932: u32 = 7864;
pub const Z_UTIL_X2_3933: u32 = 7866;
pub const Z_UTIL_X2_3934: u32 = 7868;
pub const Z_UTIL_X2_3935: u32 = 7870;
pub const Z_UTIL_X2_3936: u32 = 7872;
pub const Z_UTIL_X2_3937: u32 = 7874;
pub const Z_UTIL_X2_3938: u32 = 7876;
pub const Z_UTIL_X2_3939: u32 = 7878;
pub const Z_UTIL_X2_3940: u32 = 7880;
pub const Z_UTIL_X2_3941: u32 = 7882;
pub const Z_UTIL_X2_3942: u32 = 7884;
pub const Z_UTIL_X2_3943: u32 = 7886;
pub const Z_UTIL_X2_3944: u32 = 7888;
pub const Z_UTIL_X2_3945: u32 = 7890;
pub const Z_UTIL_X2_3946: u32 = 7892;
pub const Z_UTIL_X2_3947: u32 = 7894;
pub const Z_UTIL_X2_3948: u32 = 7896;
pub const Z_UTIL_X2_3949: u32 = 7898;
pub const Z_UTIL_X2_3950: u32 = 7900;
pub const Z_UTIL_X2_3951: u32 = 7902;
pub const Z_UTIL_X2_3952: u32 = 7904;
pub const Z_UTIL_X2_3953: u32 = 7906;
pub const Z_UTIL_X2_3954: u32 = 7908;
pub const Z_UTIL_X2_3955: u32 = 7910;
pub const Z_UTIL_X2_3956: u32 = 7912;
pub const Z_UTIL_X2_3957: u32 = 7914;
pub const Z_UTIL_X2_3958: u32 = 7916;
pub const Z_UTIL_X2_3959: u32 = 7918;
pub const Z_UTIL_X2_3960: u32 = 7920;
pub const Z_UTIL_X2_3961: u32 = 7922;
pub const Z_UTIL_X2_3962: u32 = 7924;
pub const Z_UTIL_X2_3963: u32 = 7926;
pub const Z_UTIL_X2_3964: u32 = 7928;
pub const Z_UTIL_X2_3965: u32 = 7930;
pub const Z_UTIL_X2_3966: u32 = 7932;
pub const Z_UTIL_X2_3967: u32 = 7934;
pub const Z_UTIL_X2_3968: u32 = 7936;
pub const Z_UTIL_X2_3969: u32 = 7938;
pub const Z_UTIL_X2_3970: u32 = 7940;
pub const Z_UTIL_X2_3971: u32 = 7942;
pub const Z_UTIL_X2_3972: u32 = 7944;
pub const Z_UTIL_X2_3973: u32 = 7946;
pub const Z_UTIL_X2_3974: u32 = 7948;
pub const Z_UTIL_X2_3975: u32 = 7950;
pub const Z_UTIL_X2_3976: u32 = 7952;
pub const Z_UTIL_X2_3977: u32 = 7954;
pub const Z_UTIL_X2_3978: u32 = 7956;
pub const Z_UTIL_X2_3979: u32 = 7958;
pub const Z_UTIL_X2_3980: u32 = 7960;
pub const Z_UTIL_X2_3981: u32 = 7962;
pub const Z_UTIL_X2_3982: u32 = 7964;
pub const Z_UTIL_X2_3983: u32 = 7966;
pub const Z_UTIL_X2_3984: u32 = 7968;
pub const Z_UTIL_X2_3985: u32 = 7970;
pub const Z_UTIL_X2_3986: u32 = 7972;
pub const Z_UTIL_X2_3987: u32 = 7974;
pub const Z_UTIL_X2_3988: u32 = 7976;
pub const Z_UTIL_X2_3989: u32 = 7978;
pub const Z_UTIL_X2_3990: u32 = 7980;
pub const Z_UTIL_X2_3991: u32 = 7982;
pub const Z_UTIL_X2_3992: u32 = 7984;
pub const Z_UTIL_X2_3993: u32 = 7986;
pub const Z_UTIL_X2_3994: u32 = 7988;
pub const Z_UTIL_X2_3995: u32 = 7990;
pub const Z_UTIL_X2_3996: u32 = 7992;
pub const Z_UTIL_X2_3997: u32 = 7994;
pub const Z_UTIL_X2_3998: u32 = 7996;
pub const Z_UTIL_X2_3999: u32 = 7998;
pub const Z_UTIL_X2_4000: u32 = 8000;
pub const Z_UTIL_X2_4001: u32 = 8002;
pub const Z_UTIL_X2_4002: u32 = 8004;
pub const Z_UTIL_X2_4003: u32 = 8006;
pub const Z_UTIL_X2_4004: u32 = 8008;
pub const Z_UTIL_X2_4005: u32 = 8010;
pub const Z_UTIL_X2_4006: u32 = 8012;
pub const Z_UTIL_X2_4007: u32 = 8014;
pub const Z_UTIL_X2_4008: u32 = 8016;
pub const Z_UTIL_X2_4009: u32 = 8018;
pub const Z_UTIL_X2_4010: u32 = 8020;
pub const Z_UTIL_X2_4011: u32 = 8022;
pub const Z_UTIL_X2_4012: u32 = 8024;
pub const Z_UTIL_X2_4013: u32 = 8026;
pub const Z_UTIL_X2_4014: u32 = 8028;
pub const Z_UTIL_X2_4015: u32 = 8030;
pub const Z_UTIL_X2_4016: u32 = 8032;
pub const Z_UTIL_X2_4017: u32 = 8034;
pub const Z_UTIL_X2_4018: u32 = 8036;
pub const Z_UTIL_X2_4019: u32 = 8038;
pub const Z_UTIL_X2_4020: u32 = 8040;
pub const Z_UTIL_X2_4021: u32 = 8042;
pub const Z_UTIL_X2_4022: u32 = 8044;
pub const Z_UTIL_X2_4023: u32 = 8046;
pub const Z_UTIL_X2_4024: u32 = 8048;
pub const Z_UTIL_X2_4025: u32 = 8050;
pub const Z_UTIL_X2_4026: u32 = 8052;
pub const Z_UTIL_X2_4027: u32 = 8054;
pub const Z_UTIL_X2_4028: u32 = 8056;
pub const Z_UTIL_X2_4029: u32 = 8058;
pub const Z_UTIL_X2_4030: u32 = 8060;
pub const Z_UTIL_X2_4031: u32 = 8062;
pub const Z_UTIL_X2_4032: u32 = 8064;
pub const Z_UTIL_X2_4033: u32 = 8066;
pub const Z_UTIL_X2_4034: u32 = 8068;
pub const Z_UTIL_X2_4035: u32 = 8070;
pub const Z_UTIL_X2_4036: u32 = 8072;
pub const Z_UTIL_X2_4037: u32 = 8074;
pub const Z_UTIL_X2_4038: u32 = 8076;
pub const Z_UTIL_X2_4039: u32 = 8078;
pub const Z_UTIL_X2_4040: u32 = 8080;
pub const Z_UTIL_X2_4041: u32 = 8082;
pub const Z_UTIL_X2_4042: u32 = 8084;
pub const Z_UTIL_X2_4043: u32 = 8086;
pub const Z_UTIL_X2_4044: u32 = 8088;
pub const Z_UTIL_X2_4045: u32 = 8090;
pub const Z_UTIL_X2_4046: u32 = 8092;
pub const Z_UTIL_X2_4047: u32 = 8094;
pub const Z_UTIL_X2_4048: u32 = 8096;
pub const Z_UTIL_X2_4049: u32 = 8098;
pub const Z_UTIL_X2_4050: u32 = 8100;
pub const Z_UTIL_X2_4051: u32 = 8102;
pub const Z_UTIL_X2_4052: u32 = 8104;
pub const Z_UTIL_X2_4053: u32 = 8106;
pub const Z_UTIL_X2_4054: u32 = 8108;
pub const Z_UTIL_X2_4055: u32 = 8110;
pub const Z_UTIL_X2_4056: u32 = 8112;
pub const Z_UTIL_X2_4057: u32 = 8114;
pub const Z_UTIL_X2_4058: u32 = 8116;
pub const Z_UTIL_X2_4059: u32 = 8118;
pub const Z_UTIL_X2_4060: u32 = 8120;
pub const Z_UTIL_X2_4061: u32 = 8122;
pub const Z_UTIL_X2_4062: u32 = 8124;
pub const Z_UTIL_X2_4063: u32 = 8126;
pub const Z_UTIL_X2_4064: u32 = 8128;
pub const Z_UTIL_X2_4065: u32 = 8130;
pub const Z_UTIL_X2_4066: u32 = 8132;
pub const Z_UTIL_X2_4067: u32 = 8134;
pub const Z_UTIL_X2_4068: u32 = 8136;
pub const Z_UTIL_X2_4069: u32 = 8138;
pub const Z_UTIL_X2_4070: u32 = 8140;
pub const Z_UTIL_X2_4071: u32 = 8142;
pub const Z_UTIL_X2_4072: u32 = 8144;
pub const Z_UTIL_X2_4073: u32 = 8146;
pub const Z_UTIL_X2_4074: u32 = 8148;
pub const Z_UTIL_X2_4075: u32 = 8150;
pub const Z_UTIL_X2_4076: u32 = 8152;
pub const Z_UTIL_X2_4077: u32 = 8154;
pub const Z_UTIL_X2_4078: u32 = 8156;
pub const Z_UTIL_X2_4079: u32 = 8158;
pub const Z_UTIL_X2_4080: u32 = 8160;
pub const Z_UTIL_X2_4081: u32 = 8162;
pub const Z_UTIL_X2_4082: u32 = 8164;
pub const Z_UTIL_X2_4083: u32 = 8166;
pub const Z_UTIL_X2_4084: u32 = 8168;
pub const Z_UTIL_X2_4085: u32 = 8170;
pub const Z_UTIL_X2_4086: u32 = 8172;
pub const Z_UTIL_X2_4087: u32 = 8174;
pub const Z_UTIL_X2_4088: u32 = 8176;
pub const Z_UTIL_X2_4089: u32 = 8178;
pub const Z_UTIL_X2_4090: u32 = 8180;
pub const Z_UTIL_X2_4091: u32 = 8182;
pub const Z_UTIL_X2_4092: u32 = 8184;
pub const Z_UTIL_X2_4093: u32 = 8186;
pub const Z_UTIL_X2_4094: u32 = 8188;
pub const Z_UTIL_X2_4095: u32 = 8190;
pub const SYS_FOREVER_MS: i32 = -1;
pub const SYS_FOREVER_US: i32 = -1;
pub const Z_HZ_ms: u32 = 1000;
pub const Z_HZ_us: u32 = 1000000;
pub const Z_HZ_ns: u32 = 1000000000;
pub const SYS_SFLIST_FLAGS_MASK: u32 = 3;
pub const _NON_PREEMPT_THRESHOLD: u32 = 128;
pub const _PREEMPT_THRESHOLD: u32 = 127;
pub const K_SYSCALL_CLOCK_GETTIME: u32 = 0;
pub const K_SYSCALL_DEVICE_GET_BINDING: u32 = 1;
pub const K_SYSCALL_DEVICE_IS_READY: u32 = 2;
pub const K_SYSCALL_GPIO_GET_PENDING_INT: u32 = 3;
pub const K_SYSCALL_GPIO_PIN_CONFIGURE: u32 = 4;
pub const K_SYSCALL_GPIO_PIN_GET_CONFIG: u32 = 5;
pub const K_SYSCALL_GPIO_PIN_INTERRUPT_CONFIGURE: u32 = 6;
pub const K_SYSCALL_GPIO_PORT_CLEAR_BITS_RAW: u32 = 7;
pub const K_SYSCALL_GPIO_PORT_GET_DIRECTION: u32 = 8;
pub const K_SYSCALL_GPIO_PORT_GET_RAW: u32 = 9;
pub const K_SYSCALL_GPIO_PORT_SET_BITS_RAW: u32 = 10;
pub const K_SYSCALL_GPIO_PORT_SET_MASKED_RAW: u32 = 11;
pub const K_SYSCALL_GPIO_PORT_TOGGLE_BITS: u32 = 12;
pub const K_SYSCALL_K_BUSY_WAIT: u32 = 13;
pub const K_SYSCALL_K_CONDVAR_BROADCAST: u32 = 14;
pub const K_SYSCALL_K_CONDVAR_INIT: u32 = 15;
pub const K_SYSCALL_K_CONDVAR_SIGNAL: u32 = 16;
pub const K_SYSCALL_K_CONDVAR_WAIT: u32 = 17;
pub const K_SYSCALL_K_EVENT_CLEAR: u32 = 18;
pub const K_SYSCALL_K_EVENT_INIT: u32 = 19;
pub const K_SYSCALL_K_EVENT_POST: u32 = 20;
pub const K_SYSCALL_K_EVENT_SET: u32 = 21;
pub const K_SYSCALL_K_EVENT_SET_MASKED: u32 = 22;
pub const K_SYSCALL_K_EVENT_WAIT: u32 = 23;
pub const K_SYSCALL_K_EVENT_WAIT_ALL: u32 = 24;
pub const K_SYSCALL_K_FLOAT_DISABLE: u32 = 25;
pub const K_SYSCALL_K_FLOAT_ENABLE: u32 = 26;
pub const K_SYSCALL_K_FUTEX_WAIT: u32 = 27;
pub const K_SYSCALL_K_FUTEX_WAKE: u32 = 28;
pub const K_SYSCALL_K_IS_PREEMPT_THREAD: u32 = 29;
pub const K_SYSCALL_K_MSGQ_ALLOC_INIT: u32 = 30;
pub const K_SYSCALL_K_MSGQ_GET: u32 = 31;
pub const K_SYSCALL_K_MSGQ_GET_ATTRS: u32 = 32;
pub const K_SYSCALL_K_MSGQ_NUM_FREE_GET: u32 = 33;
pub const K_SYSCALL_K_MSGQ_NUM_USED_GET: u32 = 34;
pub const K_SYSCALL_K_MSGQ_PEEK: u32 = 35;
pub const K_SYSCALL_K_MSGQ_PEEK_AT: u32 = 36;
pub const K_SYSCALL_K_MSGQ_PURGE: u32 = 37;
pub const K_SYSCALL_K_MSGQ_PUT: u32 = 38;
pub const K_SYSCALL_K_MUTEX_INIT: u32 = 39;
pub const K_SYSCALL_K_MUTEX_LOCK: u32 = 40;
pub const K_SYSCALL_K_MUTEX_UNLOCK: u32 = 41;
pub const K_SYSCALL_K_OBJECT_ACCESS_GRANT: u32 = 42;
pub const K_SYSCALL_K_OBJECT_ALLOC: u32 = 43;
pub const K_SYSCALL_K_OBJECT_ALLOC_SIZE: u32 = 44;
pub const K_SYSCALL_K_OBJECT_RELEASE: u32 = 45;
pub const K_SYSCALL_K_PIPE_ALLOC_INIT: u32 = 46;
pub const K_SYSCALL_K_PIPE_BUFFER_FLUSH: u32 = 47;
pub const K_SYSCALL_K_PIPE_FLUSH: u32 = 48;
pub const K_SYSCALL_K_PIPE_GET: u32 = 49;
pub const K_SYSCALL_K_PIPE_PUT: u32 = 50;
pub const K_SYSCALL_K_PIPE_READ_AVAIL: u32 = 51;
pub const K_SYSCALL_K_PIPE_WRITE_AVAIL: u32 = 52;
pub const K_SYSCALL_K_POLL: u32 = 53;
pub const K_SYSCALL_K_POLL_SIGNAL_CHECK: u32 = 54;
pub const K_SYSCALL_K_POLL_SIGNAL_INIT: u32 = 55;
pub const K_SYSCALL_K_POLL_SIGNAL_RAISE: u32 = 56;
pub const K_SYSCALL_K_POLL_SIGNAL_RESET: u32 = 57;
pub const K_SYSCALL_K_QUEUE_ALLOC_APPEND: u32 = 58;
pub const K_SYSCALL_K_QUEUE_ALLOC_PREPEND: u32 = 59;
pub const K_SYSCALL_K_QUEUE_CANCEL_WAIT: u32 = 60;
pub const K_SYSCALL_K_QUEUE_GET: u32 = 61;
pub const K_SYSCALL_K_QUEUE_INIT: u32 = 62;
pub const K_SYSCALL_K_QUEUE_IS_EMPTY: u32 = 63;
pub const K_SYSCALL_K_QUEUE_PEEK_HEAD: u32 = 64;
pub const K_SYSCALL_K_QUEUE_PEEK_TAIL: u32 = 65;
pub const K_SYSCALL_K_SCHED_CURRENT_THREAD_QUERY: u32 = 66;
pub const K_SYSCALL_K_SEM_COUNT_GET: u32 = 67;
pub const K_SYSCALL_K_SEM_GIVE: u32 = 68;
pub const K_SYSCALL_K_SEM_INIT: u32 = 69;
pub const K_SYSCALL_K_SEM_RESET: u32 = 70;
pub const K_SYSCALL_K_SEM_TAKE: u32 = 71;
pub const K_SYSCALL_K_SLEEP: u32 = 72;
pub const K_SYSCALL_K_STACK_ALLOC_INIT: u32 = 73;
pub const K_SYSCALL_K_STACK_POP: u32 = 74;
pub const K_SYSCALL_K_STACK_PUSH: u32 = 75;
pub const K_SYSCALL_K_STR_OUT: u32 = 76;
pub const K_SYSCALL_K_THREAD_ABORT: u32 = 77;
pub const K_SYSCALL_K_THREAD_CREATE: u32 = 78;
pub const K_SYSCALL_K_THREAD_CUSTOM_DATA_GET: u32 = 79;
pub const K_SYSCALL_K_THREAD_CUSTOM_DATA_SET: u32 = 80;
pub const K_SYSCALL_K_THREAD_DEADLINE_SET: u32 = 81;
pub const K_SYSCALL_K_THREAD_JOIN: u32 = 82;
pub const K_SYSCALL_K_THREAD_NAME_COPY: u32 = 83;
pub const K_SYSCALL_K_THREAD_NAME_SET: u32 = 84;
pub const K_SYSCALL_K_THREAD_PRIORITY_GET: u32 = 85;
pub const K_SYSCALL_K_THREAD_PRIORITY_SET: u32 = 86;
pub const K_SYSCALL_K_THREAD_RESUME: u32 = 87;
pub const K_SYSCALL_K_THREAD_STACK_ALLOC: u32 = 88;
pub const K_SYSCALL_K_THREAD_STACK_FREE: u32 = 89;
pub const K_SYSCALL_K_THREAD_STACK_SPACE_GET: u32 = 90;
pub const K_SYSCALL_K_THREAD_START: u32 = 91;
pub const K_SYSCALL_K_THREAD_SUSPEND: u32 = 92;
pub const K_SYSCALL_K_THREAD_TIMEOUT_EXPIRES_TICKS: u32 = 93;
pub const K_SYSCALL_K_THREAD_TIMEOUT_REMAINING_TICKS: u32 = 94;
pub const K_SYSCALL_K_TIMER_EXPIRES_TICKS: u32 = 95;
pub const K_SYSCALL_K_TIMER_REMAINING_TICKS: u32 = 96;
pub const K_SYSCALL_K_TIMER_START: u32 = 97;
pub const K_SYSCALL_K_TIMER_STATUS_GET: u32 = 98;
pub const K_SYSCALL_K_TIMER_STATUS_SYNC: u32 = 99;
pub const K_SYSCALL_K_TIMER_STOP: u32 = 100;
pub const K_SYSCALL_K_TIMER_USER_DATA_GET: u32 = 101;
pub const K_SYSCALL_K_TIMER_USER_DATA_SET: u32 = 102;
pub const K_SYSCALL_K_UPTIME_TICKS: u32 = 103;
pub const K_SYSCALL_K_USLEEP: u32 = 104;
pub const K_SYSCALL_K_WAKEUP: u32 = 105;
pub const K_SYSCALL_K_YIELD: u32 = 106;
pub const K_SYSCALL_LOG_BUFFERED_CNT: u32 = 107;
pub const K_SYSCALL_LOG_FILTER_SET: u32 = 108;
pub const K_SYSCALL_LOG_PANIC: u32 = 109;
pub const K_SYSCALL_LOG_PROCESS: u32 = 110;
pub const K_SYSCALL_SYS_CLOCK_HW_CYCLES_PER_SEC_RUNTIME_GET: u32 = 111;
pub const K_SYSCALL_UART_CONFIGURE: u32 = 112;
pub const K_SYSCALL_UART_CONFIG_GET: u32 = 113;
pub const K_SYSCALL_UART_DRV_CMD: u32 = 114;
pub const K_SYSCALL_UART_ERR_CHECK: u32 = 115;
pub const K_SYSCALL_UART_IRQ_ERR_DISABLE: u32 = 116;
pub const K_SYSCALL_UART_IRQ_ERR_ENABLE: u32 = 117;
pub const K_SYSCALL_UART_IRQ_IS_PENDING: u32 = 118;
pub const K_SYSCALL_UART_IRQ_RX_DISABLE: u32 = 119;
pub const K_SYSCALL_UART_IRQ_RX_ENABLE: u32 = 120;
pub const K_SYSCALL_UART_IRQ_TX_DISABLE: u32 = 121;
pub const K_SYSCALL_UART_IRQ_TX_ENABLE: u32 = 122;
pub const K_SYSCALL_UART_IRQ_UPDATE: u32 = 123;
pub const K_SYSCALL_UART_LINE_CTRL_GET: u32 = 124;
pub const K_SYSCALL_UART_LINE_CTRL_SET: u32 = 125;
pub const K_SYSCALL_UART_POLL_IN: u32 = 126;
pub const K_SYSCALL_UART_POLL_IN_U16: u32 = 127;
pub const K_SYSCALL_UART_POLL_OUT: u32 = 128;
pub const K_SYSCALL_UART_POLL_OUT_U16: u32 = 129;
pub const K_SYSCALL_UART_RX_DISABLE: u32 = 130;
pub const K_SYSCALL_UART_RX_ENABLE: u32 = 131;
pub const K_SYSCALL_UART_RX_ENABLE_U16: u32 = 132;
pub const K_SYSCALL_UART_TX: u32 = 133;
pub const K_SYSCALL_UART_TX_ABORT: u32 = 134;
pub const K_SYSCALL_UART_TX_U16: u32 = 135;
pub const K_SYSCALL_ZEPHYR_FPUTC: u32 = 136;
pub const K_SYSCALL_ZEPHYR_FWRITE: u32 = 137;
pub const K_SYSCALL_ZEPHYR_READ_STDIN: u32 = 138;
pub const K_SYSCALL_ZEPHYR_WRITE_STDOUT: u32 = 139;
pub const K_SYSCALL_Z_LOG_MSG_SIMPLE_CREATE_0: u32 = 140;
pub const K_SYSCALL_Z_LOG_MSG_SIMPLE_CREATE_1: u32 = 141;
pub const K_SYSCALL_Z_LOG_MSG_SIMPLE_CREATE_2: u32 = 142;
pub const K_SYSCALL_Z_LOG_MSG_STATIC_CREATE: u32 = 143;
pub const K_SYSCALL_Z_SYS_MUTEX_KERNEL_LOCK: u32 = 144;
pub const K_SYSCALL_Z_SYS_MUTEX_KERNEL_UNLOCK: u32 = 145;
pub const K_SYSCALL_BAD: u32 = 146;
pub const K_SYSCALL_LIMIT: u32 = 147;
pub const K_SYSCALL_ADC_CHANNEL_SETUP: u32 = 148;
pub const K_SYSCALL_ADC_READ: u32 = 149;
pub const K_SYSCALL_ADC_READ_ASYNC: u32 = 150;
pub const K_SYSCALL_ATOMIC_ADD: u32 = 151;
pub const K_SYSCALL_ATOMIC_AND: u32 = 152;
pub const K_SYSCALL_ATOMIC_CAS: u32 = 153;
pub const K_SYSCALL_ATOMIC_NAND: u32 = 154;
pub const K_SYSCALL_ATOMIC_OR: u32 = 155;
pub const K_SYSCALL_ATOMIC_PTR_CAS: u32 = 156;
pub const K_SYSCALL_ATOMIC_PTR_SET: u32 = 157;
pub const K_SYSCALL_ATOMIC_SET: u32 = 158;
pub const K_SYSCALL_ATOMIC_SUB: u32 = 159;
pub const K_SYSCALL_ATOMIC_XOR: u32 = 160;
pub const K_SYSCALL_AUXDISPLAY_BACKLIGHT_GET: u32 = 161;
pub const K_SYSCALL_AUXDISPLAY_BACKLIGHT_SET: u32 = 162;
pub const K_SYSCALL_AUXDISPLAY_BRIGHTNESS_GET: u32 = 163;
pub const K_SYSCALL_AUXDISPLAY_BRIGHTNESS_SET: u32 = 164;
pub const K_SYSCALL_AUXDISPLAY_CAPABILITIES_GET: u32 = 165;
pub const K_SYSCALL_AUXDISPLAY_CLEAR: u32 = 166;
pub const K_SYSCALL_AUXDISPLAY_CURSOR_POSITION_GET: u32 = 167;
pub const K_SYSCALL_AUXDISPLAY_CURSOR_POSITION_SET: u32 = 168;
pub const K_SYSCALL_AUXDISPLAY_CURSOR_SET_ENABLED: u32 = 169;
pub const K_SYSCALL_AUXDISPLAY_CURSOR_SHIFT_SET: u32 = 170;
pub const K_SYSCALL_AUXDISPLAY_CUSTOM_CHARACTER_SET: u32 = 171;
pub const K_SYSCALL_AUXDISPLAY_CUSTOM_COMMAND: u32 = 172;
pub const K_SYSCALL_AUXDISPLAY_DISPLAY_OFF: u32 = 173;
pub const K_SYSCALL_AUXDISPLAY_DISPLAY_ON: u32 = 174;
pub const K_SYSCALL_AUXDISPLAY_DISPLAY_POSITION_GET: u32 = 175;
pub const K_SYSCALL_AUXDISPLAY_DISPLAY_POSITION_SET: u32 = 176;
pub const K_SYSCALL_AUXDISPLAY_IS_BUSY: u32 = 177;
pub const K_SYSCALL_AUXDISPLAY_POSITION_BLINKING_SET_ENABLED: u32 = 178;
pub const K_SYSCALL_AUXDISPLAY_WRITE: u32 = 179;
pub const K_SYSCALL_BBRAM_CHECK_INVALID: u32 = 180;
pub const K_SYSCALL_BBRAM_CHECK_POWER: u32 = 181;
pub const K_SYSCALL_BBRAM_CHECK_STANDBY_POWER: u32 = 182;
pub const K_SYSCALL_BBRAM_GET_SIZE: u32 = 183;
pub const K_SYSCALL_BBRAM_READ: u32 = 184;
pub const K_SYSCALL_BBRAM_WRITE: u32 = 185;
pub const K_SYSCALL_BC12_SET_RESULT_CB: u32 = 186;
pub const K_SYSCALL_BC12_SET_ROLE: u32 = 187;
pub const K_SYSCALL_CAN_ADD_RX_FILTER_MSGQ: u32 = 188;
pub const K_SYSCALL_CAN_CALC_TIMING: u32 = 189;
pub const K_SYSCALL_CAN_CALC_TIMING_DATA: u32 = 190;
pub const K_SYSCALL_CAN_GET_CAPABILITIES: u32 = 191;
pub const K_SYSCALL_CAN_GET_CORE_CLOCK: u32 = 192;
pub const K_SYSCALL_CAN_GET_MAX_BITRATE: u32 = 193;
pub const K_SYSCALL_CAN_GET_MAX_FILTERS: u32 = 194;
pub const K_SYSCALL_CAN_GET_STATE: u32 = 195;
pub const K_SYSCALL_CAN_GET_TIMING_DATA_MAX: u32 = 196;
pub const K_SYSCALL_CAN_GET_TIMING_DATA_MIN: u32 = 197;
pub const K_SYSCALL_CAN_GET_TIMING_MAX: u32 = 198;
pub const K_SYSCALL_CAN_GET_TIMING_MIN: u32 = 199;
pub const K_SYSCALL_CAN_RECOVER: u32 = 200;
pub const K_SYSCALL_CAN_REMOVE_RX_FILTER: u32 = 201;
pub const K_SYSCALL_CAN_SEND: u32 = 202;
pub const K_SYSCALL_CAN_SET_BITRATE: u32 = 203;
pub const K_SYSCALL_CAN_SET_BITRATE_DATA: u32 = 204;
pub const K_SYSCALL_CAN_SET_MODE: u32 = 205;
pub const K_SYSCALL_CAN_SET_TIMING: u32 = 206;
pub const K_SYSCALL_CAN_SET_TIMING_DATA: u32 = 207;
pub const K_SYSCALL_CAN_START: u32 = 208;
pub const K_SYSCALL_CAN_STATS_GET_ACK_ERRORS: u32 = 209;
pub const K_SYSCALL_CAN_STATS_GET_BIT0_ERRORS: u32 = 210;
pub const K_SYSCALL_CAN_STATS_GET_BIT1_ERRORS: u32 = 211;
pub const K_SYSCALL_CAN_STATS_GET_BIT_ERRORS: u32 = 212;
pub const K_SYSCALL_CAN_STATS_GET_CRC_ERRORS: u32 = 213;
pub const K_SYSCALL_CAN_STATS_GET_FORM_ERRORS: u32 = 214;
pub const K_SYSCALL_CAN_STATS_GET_RX_OVERRUNS: u32 = 215;
pub const K_SYSCALL_CAN_STATS_GET_STUFF_ERRORS: u32 = 216;
pub const K_SYSCALL_CAN_STOP: u32 = 217;
pub const K_SYSCALL_CHARGER_CHARGE_ENABLE: u32 = 218;
pub const K_SYSCALL_CHARGER_GET_PROP: u32 = 219;
pub const K_SYSCALL_CHARGER_SET_PROP: u32 = 220;
pub const K_SYSCALL_COUNTER_CANCEL_CHANNEL_ALARM: u32 = 221;
pub const K_SYSCALL_COUNTER_GET_FREQUENCY: u32 = 222;
pub const K_SYSCALL_COUNTER_GET_GUARD_PERIOD: u32 = 223;
pub const K_SYSCALL_COUNTER_GET_MAX_TOP_VALUE: u32 = 224;
pub const K_SYSCALL_COUNTER_GET_NUM_OF_CHANNELS: u32 = 225;
pub const K_SYSCALL_COUNTER_GET_PENDING_INT: u32 = 226;
pub const K_SYSCALL_COUNTER_GET_TOP_VALUE: u32 = 227;
pub const K_SYSCALL_COUNTER_GET_VALUE: u32 = 228;
pub const K_SYSCALL_COUNTER_GET_VALUE_64: u32 = 229;
pub const K_SYSCALL_COUNTER_IS_COUNTING_UP: u32 = 230;
pub const K_SYSCALL_COUNTER_SET_CHANNEL_ALARM: u32 = 231;
pub const K_SYSCALL_COUNTER_SET_GUARD_PERIOD: u32 = 232;
pub const K_SYSCALL_COUNTER_SET_TOP_VALUE: u32 = 233;
pub const K_SYSCALL_COUNTER_START: u32 = 234;
pub const K_SYSCALL_COUNTER_STOP: u32 = 235;
pub const K_SYSCALL_COUNTER_TICKS_TO_US: u32 = 236;
pub const K_SYSCALL_COUNTER_US_TO_TICKS: u32 = 237;
pub const K_SYSCALL_DAC_CHANNEL_SETUP: u32 = 238;
pub const K_SYSCALL_DAC_WRITE_VALUE: u32 = 239;
pub const K_SYSCALL_DEVMUX_SELECT_GET: u32 = 240;
pub const K_SYSCALL_DEVMUX_SELECT_SET: u32 = 241;
pub const K_SYSCALL_DMA_CHAN_FILTER: u32 = 242;
pub const K_SYSCALL_DMA_RELEASE_CHANNEL: u32 = 243;
pub const K_SYSCALL_DMA_REQUEST_CHANNEL: u32 = 244;
pub const K_SYSCALL_DMA_RESUME: u32 = 245;
pub const K_SYSCALL_DMA_START: u32 = 246;
pub const K_SYSCALL_DMA_STOP: u32 = 247;
pub const K_SYSCALL_DMA_SUSPEND: u32 = 248;
pub const K_SYSCALL_EEPROM_GET_SIZE: u32 = 249;
pub const K_SYSCALL_EEPROM_READ: u32 = 250;
pub const K_SYSCALL_EEPROM_WRITE: u32 = 251;
pub const K_SYSCALL_EMUL_FUEL_GAUGE_IS_BATTERY_CUTOFF: u32 = 252;
pub const K_SYSCALL_EMUL_FUEL_GAUGE_SET_BATTERY_CHARGING: u32 = 253;
pub const K_SYSCALL_ENTROPY_GET_ENTROPY: u32 = 254;
pub const K_SYSCALL_ESPI_CONFIG: u32 = 255;
pub const K_SYSCALL_ESPI_FLASH_ERASE: u32 = 256;
pub const K_SYSCALL_ESPI_GET_CHANNEL_STATUS: u32 = 257;
pub const K_SYSCALL_ESPI_READ_FLASH: u32 = 258;
pub const K_SYSCALL_ESPI_READ_LPC_REQUEST: u32 = 259;
pub const K_SYSCALL_ESPI_READ_REQUEST: u32 = 260;
pub const K_SYSCALL_ESPI_RECEIVE_OOB: u32 = 261;
pub const K_SYSCALL_ESPI_RECEIVE_VWIRE: u32 = 262;
pub const K_SYSCALL_ESPI_SAF_ACTIVATE: u32 = 263;
pub const K_SYSCALL_ESPI_SAF_CONFIG: u32 = 264;
pub const K_SYSCALL_ESPI_SAF_FLASH_ERASE: u32 = 265;
pub const K_SYSCALL_ESPI_SAF_FLASH_READ: u32 = 266;
pub const K_SYSCALL_ESPI_SAF_FLASH_UNSUCCESS: u32 = 267;
pub const K_SYSCALL_ESPI_SAF_FLASH_WRITE: u32 = 268;
pub const K_SYSCALL_ESPI_SAF_GET_CHANNEL_STATUS: u32 = 269;
pub const K_SYSCALL_ESPI_SAF_SET_PROTECTION_REGIONS: u32 = 270;
pub const K_SYSCALL_ESPI_SEND_OOB: u32 = 271;
pub const K_SYSCALL_ESPI_SEND_VWIRE: u32 = 272;
pub const K_SYSCALL_ESPI_WRITE_FLASH: u32 = 273;
pub const K_SYSCALL_ESPI_WRITE_LPC_REQUEST: u32 = 274;
pub const K_SYSCALL_ESPI_WRITE_REQUEST: u32 = 275;
pub const K_SYSCALL_FLASH_ERASE: u32 = 276;
pub const K_SYSCALL_FLASH_EX_OP: u32 = 277;
pub const K_SYSCALL_FLASH_GET_PAGE_COUNT: u32 = 278;
pub const K_SYSCALL_FLASH_GET_PAGE_INFO_BY_IDX: u32 = 279;
pub const K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS: u32 = 280;
pub const K_SYSCALL_FLASH_GET_PARAMETERS: u32 = 281;
pub const K_SYSCALL_FLASH_GET_WRITE_BLOCK_SIZE: u32 = 282;
pub const K_SYSCALL_FLASH_READ: u32 = 283;
pub const K_SYSCALL_FLASH_READ_JEDEC_ID: u32 = 284;
pub const K_SYSCALL_FLASH_SFDP_READ: u32 = 285;
pub const K_SYSCALL_FLASH_SIMULATOR_GET_MEMORY: u32 = 286;
pub const K_SYSCALL_FLASH_WRITE: u32 = 287;
pub const K_SYSCALL_FUEL_GAUGE_BATTERY_CUTOFF: u32 = 288;
pub const K_SYSCALL_FUEL_GAUGE_GET_BUFFER_PROP: u32 = 289;
pub const K_SYSCALL_FUEL_GAUGE_GET_PROP: u32 = 290;
pub const K_SYSCALL_FUEL_GAUGE_GET_PROPS: u32 = 291;
pub const K_SYSCALL_FUEL_GAUGE_SET_PROP: u32 = 292;
pub const K_SYSCALL_FUEL_GAUGE_SET_PROPS: u32 = 293;
pub const K_SYSCALL_GNSS_GET_ENABLED_SYSTEMS: u32 = 294;
pub const K_SYSCALL_GNSS_GET_FIX_RATE: u32 = 295;
pub const K_SYSCALL_GNSS_GET_NAVIGATION_MODE: u32 = 296;
pub const K_SYSCALL_GNSS_GET_PERIODIC_CONFIG: u32 = 297;
pub const K_SYSCALL_GNSS_GET_SUPPORTED_SYSTEMS: u32 = 298;
pub const K_SYSCALL_GNSS_SET_ENABLED_SYSTEMS: u32 = 299;
pub const K_SYSCALL_GNSS_SET_FIX_RATE: u32 = 300;
pub const K_SYSCALL_GNSS_SET_NAVIGATION_MODE: u32 = 301;
pub const K_SYSCALL_GNSS_SET_PERIODIC_CONFIG: u32 = 302;
pub const K_SYSCALL_HWINFO_CLEAR_RESET_CAUSE: u32 = 303;
pub const K_SYSCALL_HWINFO_GET_DEVICE_ID: u32 = 304;
pub const K_SYSCALL_HWINFO_GET_RESET_CAUSE: u32 = 305;
pub const K_SYSCALL_HWINFO_GET_SUPPORTED_RESET_CAUSE: u32 = 306;
pub const K_SYSCALL_HWSPINLOCK_GET_MAX_ID: u32 = 307;
pub const K_SYSCALL_HWSPINLOCK_LOCK: u32 = 308;
pub const K_SYSCALL_HWSPINLOCK_TRYLOCK: u32 = 309;
pub const K_SYSCALL_HWSPINLOCK_UNLOCK: u32 = 310;
pub const K_SYSCALL_I2C_CONFIGURE: u32 = 311;
pub const K_SYSCALL_I2C_GET_CONFIG: u32 = 312;
pub const K_SYSCALL_I2C_RECOVER_BUS: u32 = 313;
pub const K_SYSCALL_I2C_TARGET_DRIVER_REGISTER: u32 = 314;
pub const K_SYSCALL_I2C_TARGET_DRIVER_UNREGISTER: u32 = 315;
pub const K_SYSCALL_I2C_TRANSFER: u32 = 316;
pub const K_SYSCALL_I2S_BUF_READ: u32 = 317;
pub const K_SYSCALL_I2S_BUF_WRITE: u32 = 318;
pub const K_SYSCALL_I2S_CONFIGURE: u32 = 319;
pub const K_SYSCALL_I2S_TRIGGER: u32 = 320;
pub const K_SYSCALL_I3C_DO_CCC: u32 = 321;
pub const K_SYSCALL_I3C_TRANSFER: u32 = 322;
pub const K_SYSCALL_IPM_COMPLETE: u32 = 323;
pub const K_SYSCALL_IPM_MAX_DATA_SIZE_GET: u32 = 324;
pub const K_SYSCALL_IPM_MAX_ID_VAL_GET: u32 = 325;
pub const K_SYSCALL_IPM_SEND: u32 = 326;
pub const K_SYSCALL_IPM_SET_ENABLED: u32 = 327;
pub const K_SYSCALL_IVSHMEM_ENABLE_INTERRUPTS: u32 = 328;
pub const K_SYSCALL_IVSHMEM_GET_ID: u32 = 329;
pub const K_SYSCALL_IVSHMEM_GET_MAX_PEERS: u32 = 330;
pub const K_SYSCALL_IVSHMEM_GET_MEM: u32 = 331;
pub const K_SYSCALL_IVSHMEM_GET_OUTPUT_MEM_SECTION: u32 = 332;
pub const K_SYSCALL_IVSHMEM_GET_PROTOCOL: u32 = 333;
pub const K_SYSCALL_IVSHMEM_GET_RW_MEM_SECTION: u32 = 334;
pub const K_SYSCALL_IVSHMEM_GET_STATE: u32 = 335;
pub const K_SYSCALL_IVSHMEM_GET_VECTORS: u32 = 336;
pub const K_SYSCALL_IVSHMEM_INT_PEER: u32 = 337;
pub const K_SYSCALL_IVSHMEM_REGISTER_HANDLER: u32 = 338;
pub const K_SYSCALL_IVSHMEM_SET_STATE: u32 = 339;
pub const K_SYSCALL_KSCAN_CONFIG: u32 = 340;
pub const K_SYSCALL_KSCAN_DISABLE_CALLBACK: u32 = 341;
pub const K_SYSCALL_KSCAN_ENABLE_CALLBACK: u32 = 342;
pub const K_SYSCALL_K_MEM_PAGING_HISTOGRAM_BACKING_STORE_PAGE_IN_GET: u32 = 343;
pub const K_SYSCALL_K_MEM_PAGING_HISTOGRAM_BACKING_STORE_PAGE_OUT_GET: u32 = 344;
pub const K_SYSCALL_K_MEM_PAGING_HISTOGRAM_EVICTION_GET: u32 = 345;
pub const K_SYSCALL_K_MEM_PAGING_STATS_GET: u32 = 346;
pub const K_SYSCALL_K_MEM_PAGING_THREAD_STATS_GET: u32 = 347;
pub const K_SYSCALL_LED_BLINK: u32 = 348;
pub const K_SYSCALL_LED_GET_INFO: u32 = 349;
pub const K_SYSCALL_LED_OFF: u32 = 350;
pub const K_SYSCALL_LED_ON: u32 = 351;
pub const K_SYSCALL_LED_SET_BRIGHTNESS: u32 = 352;
pub const K_SYSCALL_LED_SET_CHANNEL: u32 = 353;
pub const K_SYSCALL_LED_SET_COLOR: u32 = 354;
pub const K_SYSCALL_LED_WRITE_CHANNELS: u32 = 355;
pub const K_SYSCALL_MAXIM_DS3231_GET_SYNCPOINT: u32 = 356;
pub const K_SYSCALL_MAXIM_DS3231_REQ_SYNCPOINT: u32 = 357;
pub const K_SYSCALL_MBOX_MAX_CHANNELS_GET: u32 = 358;
pub const K_SYSCALL_MBOX_MTU_GET: u32 = 359;
pub const K_SYSCALL_MBOX_SEND: u32 = 360;
pub const K_SYSCALL_MBOX_SET_ENABLED: u32 = 361;
pub const K_SYSCALL_MDIO_BUS_DISABLE: u32 = 362;
pub const K_SYSCALL_MDIO_BUS_ENABLE: u32 = 363;
pub const K_SYSCALL_MDIO_READ: u32 = 364;
pub const K_SYSCALL_MDIO_READ_C45: u32 = 365;
pub const K_SYSCALL_MDIO_WRITE: u32 = 366;
pub const K_SYSCALL_MDIO_WRITE_C45: u32 = 367;
pub const K_SYSCALL_NET_ADDR_NTOP: u32 = 368;
pub const K_SYSCALL_NET_ADDR_PTON: u32 = 369;
pub const K_SYSCALL_NET_ETH_GET_PTP_CLOCK_BY_INDEX: u32 = 370;
pub const K_SYSCALL_NET_IF_GET_BY_INDEX: u32 = 371;
pub const K_SYSCALL_NET_IF_IPV4_ADDR_ADD_BY_INDEX: u32 = 372;
pub const K_SYSCALL_NET_IF_IPV4_ADDR_LOOKUP_BY_INDEX: u32 = 373;
pub const K_SYSCALL_NET_IF_IPV4_ADDR_RM_BY_INDEX: u32 = 374;
pub const K_SYSCALL_NET_IF_IPV4_SET_GW_BY_INDEX: u32 = 375;
pub const K_SYSCALL_NET_IF_IPV4_SET_NETMASK_BY_INDEX: u32 = 376;
pub const K_SYSCALL_NET_IF_IPV6_ADDR_ADD_BY_INDEX: u32 = 377;
pub const K_SYSCALL_NET_IF_IPV6_ADDR_LOOKUP_BY_INDEX: u32 = 378;
pub const K_SYSCALL_NET_IF_IPV6_ADDR_RM_BY_INDEX: u32 = 379;
pub const K_SYSCALL_NRF_QSPI_NOR_XIP_ENABLE: u32 = 380;
pub const K_SYSCALL_PECI_CONFIG: u32 = 381;
pub const K_SYSCALL_PECI_DISABLE: u32 = 382;
pub const K_SYSCALL_PECI_ENABLE: u32 = 383;
pub const K_SYSCALL_PECI_TRANSFER: u32 = 384;
pub const K_SYSCALL_PHY_CONFIGURE_LINK: u32 = 385;
pub const K_SYSCALL_PHY_GET_LINK_STATE: u32 = 386;
pub const K_SYSCALL_PHY_LINK_CALLBACK_SET: u32 = 387;
pub const K_SYSCALL_PHY_READ: u32 = 388;
pub const K_SYSCALL_PHY_WRITE: u32 = 389;
pub const K_SYSCALL_PS2_CONFIG: u32 = 390;
pub const K_SYSCALL_PS2_DISABLE_CALLBACK: u32 = 391;
pub const K_SYSCALL_PS2_ENABLE_CALLBACK: u32 = 392;
pub const K_SYSCALL_PS2_READ: u32 = 393;
pub const K_SYSCALL_PS2_WRITE: u32 = 394;
pub const K_SYSCALL_PTP_CLOCK_GET: u32 = 395;
pub const K_SYSCALL_PWM_CAPTURE_CYCLES: u32 = 396;
pub const K_SYSCALL_PWM_DISABLE_CAPTURE: u32 = 397;
pub const K_SYSCALL_PWM_ENABLE_CAPTURE: u32 = 398;
pub const K_SYSCALL_PWM_GET_CYCLES_PER_SEC: u32 = 399;
pub const K_SYSCALL_PWM_SET_CYCLES: u32 = 400;
pub const K_SYSCALL_RESET_LINE_ASSERT: u32 = 401;
pub const K_SYSCALL_RESET_LINE_DEASSERT: u32 = 402;
pub const K_SYSCALL_RESET_LINE_TOGGLE: u32 = 403;
pub const K_SYSCALL_RESET_STATUS: u32 = 404;
pub const K_SYSCALL_RETAINED_MEM_CLEAR: u32 = 405;
pub const K_SYSCALL_RETAINED_MEM_READ: u32 = 406;
pub const K_SYSCALL_RETAINED_MEM_SIZE: u32 = 407;
pub const K_SYSCALL_RETAINED_MEM_WRITE: u32 = 408;
pub const K_SYSCALL_RTC_ALARM_GET_SUPPORTED_FIELDS: u32 = 409;
pub const K_SYSCALL_RTC_ALARM_GET_TIME: u32 = 410;
pub const K_SYSCALL_RTC_ALARM_IS_PENDING: u32 = 411;
pub const K_SYSCALL_RTC_ALARM_SET_CALLBACK: u32 = 412;
pub const K_SYSCALL_RTC_ALARM_SET_TIME: u32 = 413;
pub const K_SYSCALL_RTC_GET_CALIBRATION: u32 = 414;
pub const K_SYSCALL_RTC_GET_TIME: u32 = 415;
pub const K_SYSCALL_RTC_SET_CALIBRATION: u32 = 416;
pub const K_SYSCALL_RTC_SET_TIME: u32 = 417;
pub const K_SYSCALL_RTC_UPDATE_SET_CALLBACK: u32 = 418;
pub const K_SYSCALL_RTIO_CQE_COPY_OUT: u32 = 419;
pub const K_SYSCALL_RTIO_CQE_GET_MEMPOOL_BUFFER: u32 = 420;
pub const K_SYSCALL_RTIO_RELEASE_BUFFER: u32 = 421;
pub const K_SYSCALL_RTIO_SQE_CANCEL: u32 = 422;
pub const K_SYSCALL_RTIO_SQE_COPY_IN_GET_HANDLES: u32 = 423;
pub const K_SYSCALL_RTIO_SUBMIT: u32 = 424;
pub const K_SYSCALL_SDHC_CARD_BUSY: u32 = 425;
pub const K_SYSCALL_SDHC_CARD_PRESENT: u32 = 426;
pub const K_SYSCALL_SDHC_DISABLE_INTERRUPT: u32 = 427;
pub const K_SYSCALL_SDHC_ENABLE_INTERRUPT: u32 = 428;
pub const K_SYSCALL_SDHC_EXECUTE_TUNING: u32 = 429;
pub const K_SYSCALL_SDHC_GET_HOST_PROPS: u32 = 430;
pub const K_SYSCALL_SDHC_HW_RESET: u32 = 431;
pub const K_SYSCALL_SDHC_REQUEST: u32 = 432;
pub const K_SYSCALL_SDHC_SET_IO: u32 = 433;
pub const K_SYSCALL_SENSOR_ATTR_GET: u32 = 434;
pub const K_SYSCALL_SENSOR_ATTR_SET: u32 = 435;
pub const K_SYSCALL_SENSOR_CHANNEL_GET: u32 = 436;
pub const K_SYSCALL_SENSOR_GET_DECODER: u32 = 437;
pub const K_SYSCALL_SENSOR_RECONFIGURE_READ_IODEV: u32 = 438;
pub const K_SYSCALL_SENSOR_SAMPLE_FETCH: u32 = 439;
pub const K_SYSCALL_SENSOR_SAMPLE_FETCH_CHAN: u32 = 440;
pub const K_SYSCALL_SIP_SUPERVISORY_CALL: u32 = 441;
pub const K_SYSCALL_SIP_SVC_PLAT_ASYNC_RES_REQ: u32 = 442;
pub const K_SYSCALL_SIP_SVC_PLAT_ASYNC_RES_RES: u32 = 443;
pub const K_SYSCALL_SIP_SVC_PLAT_FORMAT_TRANS_ID: u32 = 444;
pub const K_SYSCALL_SIP_SVC_PLAT_FREE_ASYNC_MEMORY: u32 = 445;
pub const K_SYSCALL_SIP_SVC_PLAT_FUNC_ID_VALID: u32 = 446;
pub const K_SYSCALL_SIP_SVC_PLAT_GET_ERROR_CODE: u32 = 447;
pub const K_SYSCALL_SIP_SVC_PLAT_GET_TRANS_IDX: u32 = 448;
pub const K_SYSCALL_SIP_SVC_PLAT_UPDATE_TRANS_ID: u32 = 449;
pub const K_SYSCALL_SMBUS_BLOCK_PCALL: u32 = 450;
pub const K_SYSCALL_SMBUS_BLOCK_READ: u32 = 451;
pub const K_SYSCALL_SMBUS_BLOCK_WRITE: u32 = 452;
pub const K_SYSCALL_SMBUS_BYTE_DATA_READ: u32 = 453;
pub const K_SYSCALL_SMBUS_BYTE_DATA_WRITE: u32 = 454;
pub const K_SYSCALL_SMBUS_BYTE_READ: u32 = 455;
pub const K_SYSCALL_SMBUS_BYTE_WRITE: u32 = 456;
pub const K_SYSCALL_SMBUS_CONFIGURE: u32 = 457;
pub const K_SYSCALL_SMBUS_GET_CONFIG: u32 = 458;
pub const K_SYSCALL_SMBUS_HOST_NOTIFY_REMOVE_CB: u32 = 459;
pub const K_SYSCALL_SMBUS_PCALL: u32 = 460;
pub const K_SYSCALL_SMBUS_QUICK: u32 = 461;
pub const K_SYSCALL_SMBUS_SMBALERT_REMOVE_CB: u32 = 462;
pub const K_SYSCALL_SMBUS_WORD_DATA_READ: u32 = 463;
pub const K_SYSCALL_SMBUS_WORD_DATA_WRITE: u32 = 464;
pub const K_SYSCALL_SPI_RELEASE: u32 = 465;
pub const K_SYSCALL_SPI_TRANSCEIVE: u32 = 466;
pub const K_SYSCALL_SYSCON_GET_BASE: u32 = 467;
pub const K_SYSCALL_SYSCON_GET_SIZE: u32 = 468;
pub const K_SYSCALL_SYSCON_READ_REG: u32 = 469;
pub const K_SYSCALL_SYSCON_WRITE_REG: u32 = 470;
pub const K_SYSCALL_SYS_CACHE_DATA_FLUSH_AND_INVD_RANGE: u32 = 471;
pub const K_SYSCALL_SYS_CACHE_DATA_FLUSH_RANGE: u32 = 472;
pub const K_SYSCALL_SYS_CACHE_DATA_INVD_RANGE: u32 = 473;
pub const K_SYSCALL_SYS_CSRAND_GET: u32 = 474;
pub const K_SYSCALL_SYS_RAND32_GET: u32 = 475;
pub const K_SYSCALL_SYS_RAND_GET: u32 = 476;
pub const K_SYSCALL_TGPIO_PIN_CONFIG_EXT_TIMESTAMP: u32 = 477;
pub const K_SYSCALL_TGPIO_PIN_DISABLE: u32 = 478;
pub const K_SYSCALL_TGPIO_PIN_PERIODIC_OUTPUT: u32 = 479;
pub const K_SYSCALL_TGPIO_PIN_READ_TS_EC: u32 = 480;
pub const K_SYSCALL_TGPIO_PORT_GET_CYCLES_PER_SECOND: u32 = 481;
pub const K_SYSCALL_TGPIO_PORT_GET_TIME: u32 = 482;
pub const K_SYSCALL_UART_MUX_FIND: u32 = 483;
pub const K_SYSCALL_UPDATEHUB_AUTOHANDLER: u32 = 484;
pub const K_SYSCALL_UPDATEHUB_CONFIRM: u32 = 485;
pub const K_SYSCALL_UPDATEHUB_PROBE: u32 = 486;
pub const K_SYSCALL_UPDATEHUB_REBOOT: u32 = 487;
pub const K_SYSCALL_UPDATEHUB_UPDATE: u32 = 488;
pub const K_SYSCALL_USER_FAULT: u32 = 489;
pub const K_SYSCALL_W1_CHANGE_BUS_LOCK: u32 = 490;
pub const K_SYSCALL_W1_CONFIGURE: u32 = 491;
pub const K_SYSCALL_W1_GET_SLAVE_COUNT: u32 = 492;
pub const K_SYSCALL_W1_READ_BIT: u32 = 493;
pub const K_SYSCALL_W1_READ_BLOCK: u32 = 494;
pub const K_SYSCALL_W1_READ_BYTE: u32 = 495;
pub const K_SYSCALL_W1_RESET_BUS: u32 = 496;
pub const K_SYSCALL_W1_SEARCH_BUS: u32 = 497;
pub const K_SYSCALL_W1_WRITE_BIT: u32 = 498;
pub const K_SYSCALL_W1_WRITE_BLOCK: u32 = 499;
pub const K_SYSCALL_W1_WRITE_BYTE: u32 = 500;
pub const K_SYSCALL_WDT_DISABLE: u32 = 501;
pub const K_SYSCALL_WDT_FEED: u32 = 502;
pub const K_SYSCALL_WDT_SETUP: u32 = 503;
pub const K_SYSCALL_XTENSA_USER_FAULT: u32 = 504;
pub const K_SYSCALL_ZSOCK_ACCEPT: u32 = 505;
pub const K_SYSCALL_ZSOCK_BIND: u32 = 506;
pub const K_SYSCALL_ZSOCK_CLOSE: u32 = 507;
pub const K_SYSCALL_ZSOCK_CONNECT: u32 = 508;
pub const K_SYSCALL_ZSOCK_FCNTL: u32 = 509;
pub const K_SYSCALL_ZSOCK_GETHOSTNAME: u32 = 510;
pub const K_SYSCALL_ZSOCK_GETPEERNAME: u32 = 511;
pub const K_SYSCALL_ZSOCK_GETSOCKNAME: u32 = 512;
pub const K_SYSCALL_ZSOCK_GETSOCKOPT: u32 = 513;
pub const K_SYSCALL_ZSOCK_GET_CONTEXT_OBJECT: u32 = 514;
pub const K_SYSCALL_ZSOCK_INET_PTON: u32 = 515;
pub const K_SYSCALL_ZSOCK_IOCTL: u32 = 516;
pub const K_SYSCALL_ZSOCK_LISTEN: u32 = 517;
pub const K_SYSCALL_ZSOCK_POLL: u32 = 518;
pub const K_SYSCALL_ZSOCK_RECVFROM: u32 = 519;
pub const K_SYSCALL_ZSOCK_RECVMSG: u32 = 520;
pub const K_SYSCALL_ZSOCK_SELECT: u32 = 521;
pub const K_SYSCALL_ZSOCK_SENDMSG: u32 = 522;
pub const K_SYSCALL_ZSOCK_SENDTO: u32 = 523;
pub const K_SYSCALL_ZSOCK_SETSOCKOPT: u32 = 524;
pub const K_SYSCALL_ZSOCK_SHUTDOWN: u32 = 525;
pub const K_SYSCALL_ZSOCK_SOCKET: u32 = 526;
pub const K_SYSCALL_ZSOCK_SOCKETPAIR: u32 = 527;
pub const K_SYSCALL_Z_ERRNO: u32 = 528;
pub const K_SYSCALL_Z_ZSOCK_GETADDRINFO_INTERNAL: u32 = 529;
pub const _SVC_CALL_IRQ_OFFLOAD: u32 = 1;
pub const _SVC_CALL_RUNTIME_EXCEPT: u32 = 2;
pub const _SVC_CALL_SYSTEM_CALL: u32 = 3;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SPSR_DAIF_SHIFT: u32 = 6;
pub const SPSR_DAIF_MASK: u32 = 960;
pub const SPSR_MODE_EL0T: u32 = 0;
pub const SPSR_MODE_EL1T: u32 = 4;
pub const SPSR_MODE_EL1H: u32 = 5;
pub const SPSR_MODE_EL2T: u32 = 8;
pub const SPSR_MODE_EL2H: u32 = 9;
pub const SPSR_MODE_MASK: u32 = 15;
pub const CPACR_EL1_FPEN_NOTRAP: u32 = 3145728;
pub const MPIDR_AFFLVL_MASK: u32 = 255;
pub const MPIDR_AFF0_SHIFT: u32 = 0;
pub const MPIDR_AFF1_SHIFT: u32 = 8;
pub const MPIDR_AFF2_SHIFT: u32 = 16;
pub const MPIDR_AFF3_SHIFT: u32 = 32;
pub const MODE_EL_SHIFT: u32 = 2;
pub const MODE_EL_MASK: u32 = 3;
pub const MODE_EL3: u32 = 3;
pub const MODE_EL2: u32 = 2;
pub const MODE_EL1: u32 = 1;
pub const MODE_EL0: u32 = 0;
pub const ESR_EC_SHIFT: u32 = 26;
pub const ESR_ISS_SHIFT: u32 = 0;
pub const ESR_IL_SHIFT: u32 = 25;
pub const ID_AA64PFR0_EL0_SHIFT: u32 = 0;
pub const ID_AA64PFR0_EL1_SHIFT: u32 = 4;
pub const ID_AA64PFR0_EL2_SHIFT: u32 = 8;
pub const ID_AA64PFR0_EL3_SHIFT: u32 = 12;
pub const ID_AA64PFR0_ELX_MASK: u32 = 15;
pub const ID_AA64PFR0_SEL2_SHIFT: u32 = 36;
pub const ID_AA64PFR0_SEL2_MASK: u32 = 15;
pub const SGIR_TGT_MASK: u32 = 65535;
pub const SGIR_AFF1_SHIFT: u32 = 16;
pub const SGIR_AFF2_SHIFT: u32 = 32;
pub const SGIR_AFF3_SHIFT: u32 = 48;
pub const SGIR_AFF_MASK: u32 = 15;
pub const SGIR_INTID_SHIFT: u32 = 24;
pub const SGIR_INTID_MASK: u32 = 15;
pub const SGIR_IRM_SHIFT: u32 = 40;
pub const SGIR_IRM_MASK: u32 = 1;
pub const SGIR_IRM_TO_AFF: u32 = 0;
pub const L1_CACHE_SHIFT: u32 = 6;
pub const TPIDRROEL0_IN_EL0: u32 = 1;
pub const TPIDRROEL0_CURR_CPU: u64 = 281474976710648;
pub const TPIDRROEL0_EXC_DEPTH: i64 = -72057594037927936;
pub const TPIDRROEL0_EXC_UNIT: u64 = 72057594037927936;
pub const TPIDRROEL0_EXC_SHIFT: u32 = 56;
pub const DT_N_PATH: &[u8; 2] = b"/\0";
pub const DT_N_FULL_NAME: &[u8; 2] = b"/\0";
pub const DT_N_ORD: u32 = 0;
pub const DT_N_ORD_STR_SORTABLE: u32 = 0;
pub const DT_N_EXISTS: u32 = 1;
pub const DT_N_REG_NUM: u32 = 0;
pub const DT_N_RANGES_NUM: u32 = 0;
pub const DT_N_IRQ_NUM: u32 = 0;
pub const DT_N_COMPAT_MATCHES_raspberrypi_4_model_b: u32 = 1;
pub const DT_N_COMPAT_VENDOR_IDX_0_EXISTS: u32 = 1;
pub const DT_N_COMPAT_VENDOR_IDX_0: &[u8; 24] = b"Raspberry Pi Foundation\0";
pub const DT_N_COMPAT_MODEL_IDX_0_EXISTS: u32 = 1;
pub const DT_N_COMPAT_MODEL_IDX_0: &[u8; 10] = b"4-model-b\0";
pub const DT_N_COMPAT_MATCHES_brcm_bcm2838: u32 = 1;
pub const DT_N_COMPAT_VENDOR_IDX_1_EXISTS: u32 = 1;
pub const DT_N_COMPAT_VENDOR_IDX_1: &[u8; 21] = b"Broadcom Corporation\0";
pub const DT_N_COMPAT_MODEL_IDX_1_EXISTS: u32 = 1;
pub const DT_N_COMPAT_MODEL_IDX_1: &[u8; 8] = b"bcm2838\0";
pub const DT_N_STATUS_okay: u32 = 1;
pub const DT_N_PINCTRL_NUM: u32 = 0;
pub const DT_N_P_compatible_IDX_0: &[u8; 22] = b"raspberrypi,4-model-b\0";
pub const DT_N_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_P_compatible_IDX_1: &[u8; 13] = b"brcm,bcm2838\0";
pub const DT_N_P_compatible_IDX_1_EXISTS: u32 = 1;
pub const DT_N_P_compatible_LEN: u32 = 2;
pub const DT_N_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_aliases_PATH: &[u8; 9] = b"/aliases\0";
pub const DT_N_S_aliases_FULL_NAME: &[u8; 8] = b"aliases\0";
pub const DT_N_S_aliases_CHILD_IDX: u32 = 1;
pub const DT_N_S_aliases_ORD: u32 = 1;
pub const DT_N_S_aliases_ORD_STR_SORTABLE: u32 = 1;
pub const DT_N_S_aliases_EXISTS: u32 = 1;
pub const DT_N_S_aliases_REG_NUM: u32 = 0;
pub const DT_N_S_aliases_RANGES_NUM: u32 = 0;
pub const DT_N_S_aliases_IRQ_NUM: u32 = 0;
pub const DT_N_S_aliases_STATUS_okay: u32 = 1;
pub const DT_N_S_aliases_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_chosen_PATH: &[u8; 8] = b"/chosen\0";
pub const DT_N_S_chosen_FULL_NAME: &[u8; 7] = b"chosen\0";
pub const DT_N_S_chosen_CHILD_IDX: u32 = 0;
pub const DT_N_S_chosen_ORD: u32 = 2;
pub const DT_N_S_chosen_ORD_STR_SORTABLE: u32 = 2;
pub const DT_N_S_chosen_EXISTS: u32 = 1;
pub const DT_N_S_chosen_REG_NUM: u32 = 0;
pub const DT_N_S_chosen_RANGES_NUM: u32 = 0;
pub const DT_N_S_chosen_IRQ_NUM: u32 = 0;
pub const DT_N_S_chosen_STATUS_okay: u32 = 1;
pub const DT_N_S_chosen_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_PATH: &[u8; 5] = b"/soc\0";
pub const DT_N_S_soc_FULL_NAME: &[u8; 4] = b"soc\0";
pub const DT_N_S_soc_CHILD_IDX: u32 = 2;
pub const DT_N_S_soc_ORD: u32 = 3;
pub const DT_N_S_soc_ORD_STR_SORTABLE: u32 = 3;
pub const DT_N_S_soc_EXISTS: u32 = 1;
pub const DT_N_S_soc_REG_NUM: u32 = 0;
pub const DT_N_S_soc_RANGES_NUM: u32 = 0;
pub const DT_N_S_soc_IRQ_NUM: u32 = 0;
pub const DT_N_S_soc_COMPAT_MATCHES_simple_bus: u32 = 1;
pub const DT_N_S_soc_STATUS_okay: u32 = 1;
pub const DT_N_S_soc_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_P_compatible_IDX_0: &[u8; 11] = b"simple-bus\0";
pub const DT_N_S_soc_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_P_compatible_LEN: u32 = 1;
pub const DT_N_S_soc_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_soc_P_ranges_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_PATH: &[u8; 35] =
    b"/soc/interrupt-controller@ff841000\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_FULL_NAME: &[u8; 30] =
    b"interrupt-controller@ff841000\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_CHILD_IDX: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_ORD: u32 = 4;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_ORD_STR_SORTABLE: u32 = 4;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_REG_NUM: u32 = 2;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_REG_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_REG_IDX_0_VAL_ADDRESS: u32 = 4286844928;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_REG_IDX_0_VAL_SIZE: u32 = 4096;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_REG_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_REG_IDX_1_VAL_ADDRESS: u32 = 4286849024;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_REG_IDX_1_VAL_SIZE: u32 = 8192;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_RANGES_NUM: u32 = 0;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_IRQ_NUM: u32 = 0;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_MATCHES_arm_gic_v2: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_VENDOR_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_VENDOR_IDX_0: &[u8; 9] = b"ARM Ltd.\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_MODEL_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_MODEL_IDX_0: &[u8; 7] = b"gic-v2\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_MATCHES_arm_gic: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_VENDOR_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_VENDOR_IDX_1: &[u8; 9] = b"ARM Ltd.\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_MODEL_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_COMPAT_MODEL_IDX_1: &[u8; 4] = b"gic\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_STATUS_okay: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_0: u32 = 4286844928;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_1: u32 = 4096;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_2: u32 = 4286849024;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_2_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_3: u32 = 8192;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_IDX_3_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_reg_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_status: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_status_IDX_0: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_status_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_status_ENUM_IDX: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_status_ENUM_VAL_okay_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_status_LEN: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_status_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_compatible_IDX_0: &[u8; 11] =
    b"arm,gic-v2\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_compatible_IDX_1: &[u8; 8] = b"arm,gic\0";
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_compatible_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_compatible_LEN: u32 = 2;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_wakeup_source: u32 = 0;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_wakeup_source_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_zephyr_pm_device_runtime_auto: u32 = 0;
pub const DT_N_S_soc_S_interrupt_controller_ff841000_P_zephyr_pm_device_runtime_auto_EXISTS: u32 =
    1;
pub const DT_N_S_timer_PATH: &[u8; 7] = b"/timer\0";
pub const DT_N_S_timer_FULL_NAME: &[u8; 6] = b"timer\0";
pub const DT_N_S_timer_CHILD_IDX: u32 = 4;
pub const DT_N_S_timer_ORD: u32 = 5;
pub const DT_N_S_timer_ORD_STR_SORTABLE: u32 = 5;
pub const DT_N_S_timer_EXISTS: u32 = 1;
pub const DT_N_S_timer_REG_NUM: u32 = 0;
pub const DT_N_S_timer_RANGES_NUM: u32 = 0;
pub const DT_N_S_timer_IRQ_NUM: u32 = 4;
pub const DT_N_S_timer_IRQ_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_type: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_type_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_irq: u32 = 29;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_irq_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_flags: u32 = 2;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_priority: u32 = 160;
pub const DT_N_S_timer_IRQ_IDX_0_VAL_priority_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_type: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_type_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_irq: u32 = 30;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_irq_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_flags: u32 = 2;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_priority: u32 = 160;
pub const DT_N_S_timer_IRQ_IDX_1_VAL_priority_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_2_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_type: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_type_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_irq: u32 = 27;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_irq_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_flags: u32 = 2;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_priority: u32 = 160;
pub const DT_N_S_timer_IRQ_IDX_2_VAL_priority_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_3_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_type: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_type_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_irq: u32 = 26;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_irq_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_flags: u32 = 2;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_priority: u32 = 160;
pub const DT_N_S_timer_IRQ_IDX_3_VAL_priority_EXISTS: u32 = 1;
pub const DT_N_S_timer_COMPAT_MATCHES_arm_armv8_timer: u32 = 1;
pub const DT_N_S_timer_COMPAT_VENDOR_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_timer_COMPAT_VENDOR_IDX_0: &[u8; 9] = b"ARM Ltd.\0";
pub const DT_N_S_timer_COMPAT_MODEL_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_timer_COMPAT_MODEL_IDX_0: &[u8; 12] = b"armv8-timer\0";
pub const DT_N_S_timer_STATUS_okay: u32 = 1;
pub const DT_N_S_timer_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_timer_P_interrupts_IDX_0: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_1: u32 = 13;
pub const DT_N_S_timer_P_interrupts_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_2: u32 = 2;
pub const DT_N_S_timer_P_interrupts_IDX_2_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_3: u32 = 160;
pub const DT_N_S_timer_P_interrupts_IDX_3_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_4: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_4_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_5: u32 = 14;
pub const DT_N_S_timer_P_interrupts_IDX_5_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_6: u32 = 2;
pub const DT_N_S_timer_P_interrupts_IDX_6_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_7: u32 = 160;
pub const DT_N_S_timer_P_interrupts_IDX_7_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_8: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_8_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_9: u32 = 11;
pub const DT_N_S_timer_P_interrupts_IDX_9_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_10: u32 = 2;
pub const DT_N_S_timer_P_interrupts_IDX_10_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_11: u32 = 160;
pub const DT_N_S_timer_P_interrupts_IDX_11_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_12: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_12_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_13: u32 = 10;
pub const DT_N_S_timer_P_interrupts_IDX_13_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_14: u32 = 2;
pub const DT_N_S_timer_P_interrupts_IDX_14_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_IDX_15: u32 = 160;
pub const DT_N_S_timer_P_interrupts_IDX_15_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_interrupts_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_compatible_IDX_0: &[u8; 16] = b"arm,armv8-timer\0";
pub const DT_N_S_timer_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_compatible_LEN: u32 = 1;
pub const DT_N_S_timer_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_wakeup_source: u32 = 0;
pub const DT_N_S_timer_P_wakeup_source_EXISTS: u32 = 1;
pub const DT_N_S_timer_P_zephyr_pm_device_runtime_auto: u32 = 0;
pub const DT_N_S_timer_P_zephyr_pm_device_runtime_auto_EXISTS: u32 = 1;
pub const DT_N_S_cpus_PATH: &[u8; 6] = b"/cpus\0";
pub const DT_N_S_cpus_FULL_NAME: &[u8; 5] = b"cpus\0";
pub const DT_N_S_cpus_CHILD_IDX: u32 = 3;
pub const DT_N_S_cpus_ORD: u32 = 6;
pub const DT_N_S_cpus_ORD_STR_SORTABLE: u32 = 6;
pub const DT_N_S_cpus_EXISTS: u32 = 1;
pub const DT_N_S_cpus_REG_NUM: u32 = 0;
pub const DT_N_S_cpus_RANGES_NUM: u32 = 0;
pub const DT_N_S_cpus_IRQ_NUM: u32 = 0;
pub const DT_N_S_cpus_STATUS_okay: u32 = 1;
pub const DT_N_S_cpus_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_PATH: &[u8; 12] = b"/cpus/cpu@0\0";
pub const DT_N_S_cpus_S_cpu_0_FULL_NAME: &[u8; 6] = b"cpu@0\0";
pub const DT_N_S_cpus_S_cpu_0_CHILD_IDX: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_ORD: u32 = 7;
pub const DT_N_S_cpus_S_cpu_0_ORD_STR_SORTABLE: u32 = 7;
pub const DT_N_S_cpus_S_cpu_0_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_REG_NUM: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_REG_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_REG_IDX_0_VAL_ADDRESS: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_RANGES_NUM: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_IRQ_NUM: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_COMPAT_MATCHES_arm_cortex_a72: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_COMPAT_VENDOR_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_COMPAT_VENDOR_IDX_0: &[u8; 9] = b"ARM Ltd.\0";
pub const DT_N_S_cpus_S_cpu_0_COMPAT_MODEL_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_COMPAT_MODEL_IDX_0: &[u8; 11] = b"cortex-a72\0";
pub const DT_N_S_cpus_S_cpu_0_STATUS_okay: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_P_compatible_IDX_0: &[u8; 15] = b"arm,cortex-a72\0";
pub const DT_N_S_cpus_S_cpu_0_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_P_compatible_LEN: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_P_reg_IDX_0: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_P_reg_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_P_reg_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_P_wakeup_source: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_P_wakeup_source_EXISTS: u32 = 1;
pub const DT_N_S_cpus_S_cpu_0_P_zephyr_pm_device_runtime_auto: u32 = 0;
pub const DT_N_S_cpus_S_cpu_0_P_zephyr_pm_device_runtime_auto_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_PATH: &[u8; 19] = b"/soc/gpio@fe200000\0";
pub const DT_N_S_soc_S_gpio_fe200000_FULL_NAME: &[u8; 14] = b"gpio@fe200000\0";
pub const DT_N_S_soc_S_gpio_fe200000_CHILD_IDX: u32 = 2;
pub const DT_N_S_soc_S_gpio_fe200000_ORD: u32 = 8;
pub const DT_N_S_soc_S_gpio_fe200000_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_REG_NUM: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_REG_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_REG_IDX_0_VAL_ADDRESS: u32 = 4263510016;
pub const DT_N_S_soc_S_gpio_fe200000_REG_IDX_0_VAL_SIZE: u32 = 244;
pub const DT_N_S_soc_S_gpio_fe200000_RANGES_NUM: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_IRQ_NUM: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_COMPAT_MATCHES_simple_bus: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_STATUS_okay: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_P_compatible_IDX_0: &[u8; 11] = b"simple-bus\0";
pub const DT_N_S_soc_S_gpio_fe200000_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_P_compatible_LEN: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_P_reg_IDX_0: u32 = 4263510016;
pub const DT_N_S_soc_S_gpio_fe200000_P_reg_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_P_reg_IDX_1: u32 = 244;
pub const DT_N_S_soc_S_gpio_fe200000_P_reg_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_P_reg_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_PATH: &[u8; 26] = b"/soc/gpio@fe200000/gpio@0\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_FULL_NAME: &[u8; 7] = b"gpio@0\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_CHILD_IDX: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_ORD: u32 = 9;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_REG_NUM: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_REG_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_REG_IDX_0_VAL_ADDRESS: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_RANGES_NUM: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_NUM: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_type: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_type_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_irq: u32 = 145;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_irq_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_flags: u32 = 2;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_priority: u32 = 160;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_IRQ_IDX_0_VAL_priority_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_COMPAT_MATCHES_brcm_bcm2711_gpio: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_COMPAT_VENDOR_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_COMPAT_VENDOR_IDX_0: &[u8; 21] =
    b"Broadcom Corporation\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_COMPAT_MODEL_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_COMPAT_MODEL_IDX_0: &[u8; 13] = b"bcm2711-gpio\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_STATUS_okay: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_reg_IDX_0: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_reg_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_reg_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_0: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_1: u32 = 113;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_2: u32 = 2;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_2_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_3: u32 = 160;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_IDX_3_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_interrupts_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_gpio_controller: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_gpio_controller_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_ngpios: u32 = 28;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_ngpios_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_status: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_status_IDX_0: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_status_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_status_ENUM_IDX: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_status_ENUM_VAL_okay_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_status_LEN: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_status_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_compatible_IDX_0: &[u8; 18] =
    b"brcm,bcm2711-gpio\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_compatible_LEN: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_wakeup_source: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_wakeup_source_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_zephyr_pm_device_runtime_auto: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_0_P_zephyr_pm_device_runtime_auto_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_PATH: &[u8; 27] = b"/soc/gpio@fe200000/gpio@1c\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_FULL_NAME: &[u8; 8] = b"gpio@1c\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_CHILD_IDX: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_ORD: u32 = 10;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_ORD_STR_SORTABLE: u32 = 8;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_REG_NUM: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_REG_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_REG_IDX_0_VAL_ADDRESS: u32 = 28;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_RANGES_NUM: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_NUM: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_type: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_type_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_irq: u32 = 146;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_irq_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_flags: u32 = 2;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_priority: u32 = 160;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_IRQ_IDX_0_VAL_priority_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_COMPAT_MATCHES_brcm_bcm2711_gpio: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_COMPAT_VENDOR_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_COMPAT_VENDOR_IDX_0: &[u8; 21] =
    b"Broadcom Corporation\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_COMPAT_MODEL_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_COMPAT_MODEL_IDX_0: &[u8; 13] = b"bcm2711-gpio\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_STATUS_okay: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_reg_IDX_0: u32 = 28;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_reg_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_reg_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_0: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_1: u32 = 114;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_2: u32 = 2;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_2_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_3: u32 = 160;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_IDX_3_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_interrupts_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_gpio_controller: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_gpio_controller_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_ngpios: u32 = 18;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_ngpios_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_status: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_status_IDX_0: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_status_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_status_ENUM_IDX: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_status_ENUM_VAL_okay_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_status_LEN: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_status_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_compatible_IDX_0: &[u8; 18] =
    b"brcm,bcm2711-gpio\0";
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_compatible_LEN: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_wakeup_source: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_wakeup_source_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_zephyr_pm_device_runtime_auto: u32 = 0;
pub const DT_N_S_soc_S_gpio_fe200000_S_gpio_1c_P_zephyr_pm_device_runtime_auto_EXISTS: u32 = 1;
pub const DT_N_S_leds_PATH: &[u8; 6] = b"/leds\0";
pub const DT_N_S_leds_FULL_NAME: &[u8; 5] = b"leds\0";
pub const DT_N_S_leds_CHILD_IDX: u32 = 5;
pub const DT_N_S_leds_ORD: u32 = 11;
pub const DT_N_S_leds_ORD_STR_SORTABLE: u32 = 9;
pub const DT_N_S_leds_EXISTS: u32 = 1;
pub const DT_N_S_leds_REG_NUM: u32 = 0;
pub const DT_N_S_leds_RANGES_NUM: u32 = 0;
pub const DT_N_S_leds_IRQ_NUM: u32 = 0;
pub const DT_N_S_leds_COMPAT_MATCHES_gpio_leds: u32 = 1;
pub const DT_N_S_leds_STATUS_okay: u32 = 1;
pub const DT_N_S_leds_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_leds_P_compatible_IDX_0: &[u8; 10] = b"gpio-leds\0";
pub const DT_N_S_leds_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_leds_P_compatible_LEN: u32 = 1;
pub const DT_N_S_leds_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_1_PATH: &[u8; 12] = b"/leds/led-1\0";
pub const DT_N_S_leds_S_led_1_FULL_NAME: &[u8; 6] = b"led-1\0";
pub const DT_N_S_leds_S_led_1_CHILD_IDX: u32 = 1;
pub const DT_N_S_leds_S_led_1_ORD: u32 = 12;
pub const DT_N_S_leds_S_led_1_ORD_STR_SORTABLE: u32 = 10;
pub const DT_N_S_leds_S_led_1_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_1_REG_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_1_RANGES_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_1_IRQ_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_1_STATUS_okay: u32 = 1;
pub const DT_N_S_leds_S_led_1_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_1_P_gpios_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_1_P_gpios_IDX_0_VAL_pin: u32 = 23;
pub const DT_N_S_leds_S_led_1_P_gpios_IDX_0_VAL_pin_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_1_P_gpios_IDX_0_VAL_flags: u32 = 0;
pub const DT_N_S_leds_S_led_1_P_gpios_IDX_0_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_1_P_gpios_LEN: u32 = 1;
pub const DT_N_S_leds_S_led_1_P_gpios_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_1_P_label: &[u8; 5] = b"LED1\0";
pub const DT_N_S_leds_S_led_1_P_label_IDX_0: &[u8; 5] = b"LED1\0";
pub const DT_N_S_leds_S_led_1_P_label_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_1_P_label_LEN: u32 = 1;
pub const DT_N_S_leds_S_led_1_P_label_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_act_PATH: &[u8; 14] = b"/leds/led-act\0";
pub const DT_N_S_leds_S_led_act_FULL_NAME: &[u8; 8] = b"led-act\0";
pub const DT_N_S_leds_S_led_act_CHILD_IDX: u32 = 0;
pub const DT_N_S_leds_S_led_act_ORD: u32 = 13;
pub const DT_N_S_leds_S_led_act_ORD_STR_SORTABLE: u32 = 11;
pub const DT_N_S_leds_S_led_act_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_act_REG_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_act_RANGES_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_act_IRQ_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_act_STATUS_okay: u32 = 1;
pub const DT_N_S_leds_S_led_act_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_leds_S_led_act_P_gpios_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_act_P_gpios_IDX_0_VAL_pin: u32 = 14;
pub const DT_N_S_leds_S_led_act_P_gpios_IDX_0_VAL_pin_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_act_P_gpios_IDX_0_VAL_flags: u32 = 0;
pub const DT_N_S_leds_S_led_act_P_gpios_IDX_0_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_act_P_gpios_LEN: u32 = 1;
pub const DT_N_S_leds_S_led_act_P_gpios_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_act_P_label: &[u8; 4] = b"ACT\0";
pub const DT_N_S_leds_S_led_act_P_label_IDX_0: &[u8; 4] = b"ACT\0";
pub const DT_N_S_leds_S_led_act_P_label_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_leds_S_led_act_P_label_LEN: u32 = 1;
pub const DT_N_S_leds_S_led_act_P_label_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_PATH: &[u8; 19] = b"/soc/memory@200000\0";
pub const DT_N_S_soc_S_memory_200000_FULL_NAME: &[u8; 14] = b"memory@200000\0";
pub const DT_N_S_soc_S_memory_200000_CHILD_IDX: u32 = 0;
pub const DT_N_S_soc_S_memory_200000_ORD: u32 = 14;
pub const DT_N_S_soc_S_memory_200000_ORD_STR_SORTABLE: u32 = 12;
pub const DT_N_S_soc_S_memory_200000_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_REG_NUM: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_REG_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_REG_IDX_0_VAL_ADDRESS: u32 = 2097152;
pub const DT_N_S_soc_S_memory_200000_REG_IDX_0_VAL_SIZE: u32 = 524288;
pub const DT_N_S_soc_S_memory_200000_RANGES_NUM: u32 = 0;
pub const DT_N_S_soc_S_memory_200000_IRQ_NUM: u32 = 0;
pub const DT_N_S_soc_S_memory_200000_COMPAT_MATCHES_mmio_sram: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_STATUS_okay: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_S_memory_200000_P_reg_IDX_0: u32 = 2097152;
pub const DT_N_S_soc_S_memory_200000_P_reg_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_P_reg_IDX_1: u32 = 524288;
pub const DT_N_S_soc_S_memory_200000_P_reg_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_P_reg_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_P_compatible_IDX_0: &[u8; 10] = b"mmio-sram\0";
pub const DT_N_S_soc_S_memory_200000_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_P_compatible_LEN: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_P_wakeup_source: u32 = 0;
pub const DT_N_S_soc_S_memory_200000_P_wakeup_source_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_memory_200000_P_zephyr_pm_device_runtime_auto: u32 = 0;
pub const DT_N_S_soc_S_memory_200000_P_zephyr_pm_device_runtime_auto_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_PATH: &[u8; 19] = b"/soc/uart@fe215040\0";
pub const DT_N_S_soc_S_uart_fe215040_FULL_NAME: &[u8; 14] = b"uart@fe215040\0";
pub const DT_N_S_soc_S_uart_fe215040_CHILD_IDX: u32 = 3;
pub const DT_N_S_soc_S_uart_fe215040_ORD: u32 = 15;
pub const DT_N_S_soc_S_uart_fe215040_ORD_STR_SORTABLE: u32 = 13;
pub const DT_N_S_soc_S_uart_fe215040_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_REG_NUM: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_REG_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_REG_IDX_0_VAL_ADDRESS: u32 = 4263596096;
pub const DT_N_S_soc_S_uart_fe215040_REG_IDX_0_VAL_SIZE: u32 = 64;
pub const DT_N_S_soc_S_uart_fe215040_RANGES_NUM: u32 = 0;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_NUM: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_type: u32 = 0;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_type_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_irq: u32 = 125;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_irq_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_flags: u32 = 2;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_flags_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_priority: u32 = 160;
pub const DT_N_S_soc_S_uart_fe215040_IRQ_IDX_0_VAL_priority_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_COMPAT_MATCHES_brcm_bcm2711_aux_uart: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_COMPAT_VENDOR_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_COMPAT_VENDOR_IDX_0: &[u8; 21] = b"Broadcom Corporation\0";
pub const DT_N_S_soc_S_uart_fe215040_COMPAT_MODEL_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_COMPAT_MODEL_IDX_0: &[u8; 17] = b"bcm2711-aux-uart\0";
pub const DT_N_S_soc_S_uart_fe215040_STATUS_okay: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_PINCTRL_NUM: u32 = 0;
pub const DT_N_S_soc_S_uart_fe215040_P_reg_IDX_0: u32 = 4263596096;
pub const DT_N_S_soc_S_uart_fe215040_P_reg_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_reg_IDX_1: u32 = 64;
pub const DT_N_S_soc_S_uart_fe215040_P_reg_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_reg_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_0: u32 = 0;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_1: u32 = 93;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_1_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_2: u32 = 2;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_2_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_3: u32 = 160;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_IDX_3_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_interrupts_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_clock_frequency: u32 = 500000000;
pub const DT_N_S_soc_S_uart_fe215040_P_clock_frequency_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_current_speed: u32 = 115200;
pub const DT_N_S_soc_S_uart_fe215040_P_current_speed_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_hw_flow_control: u32 = 0;
pub const DT_N_S_soc_S_uart_fe215040_P_hw_flow_control_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_status: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_uart_fe215040_P_status_IDX_0: &[u8; 5] = b"okay\0";
pub const DT_N_S_soc_S_uart_fe215040_P_status_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_status_ENUM_IDX: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_status_ENUM_VAL_okay_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_status_LEN: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_status_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_compatible_IDX_0: &[u8; 22] = b"brcm,bcm2711-aux-uart\0";
pub const DT_N_S_soc_S_uart_fe215040_P_compatible_IDX_0_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_compatible_LEN: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_compatible_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_wakeup_source: u32 = 0;
pub const DT_N_S_soc_S_uart_fe215040_P_wakeup_source_EXISTS: u32 = 1;
pub const DT_N_S_soc_S_uart_fe215040_P_zephyr_pm_device_runtime_auto: u32 = 0;
pub const DT_N_S_soc_S_uart_fe215040_P_zephyr_pm_device_runtime_auto_EXISTS: u32 = 1;
pub const DT_CHOSEN_zephyr_console_EXISTS: u32 = 1;
pub const DT_CHOSEN_zephyr_shell_uart_EXISTS: u32 = 1;
pub const DT_CHOSEN_zephyr_sram_EXISTS: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_raspberrypi_4_model_b: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_brcm_bcm2838: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_simple_bus: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_mmio_sram: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_arm_gic_v2: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_arm_gic: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_brcm_bcm2711_gpio: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_brcm_bcm2711_aux_uart: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_arm_cortex_a72: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_arm_armv8_timer: u32 = 1;
pub const DT_COMPAT_HAS_OKAY_gpio_leds: u32 = 1;
pub const DT_N_INST_raspberrypi_4_model_b_NUM_OKAY: u32 = 1;
pub const DT_N_INST_brcm_bcm2838_NUM_OKAY: u32 = 1;
pub const DT_N_INST_simple_bus_NUM_OKAY: u32 = 2;
pub const DT_N_INST_mmio_sram_NUM_OKAY: u32 = 1;
pub const DT_N_INST_arm_gic_v2_NUM_OKAY: u32 = 1;
pub const DT_N_INST_arm_gic_NUM_OKAY: u32 = 1;
pub const DT_N_INST_brcm_bcm2711_gpio_NUM_OKAY: u32 = 2;
pub const DT_N_INST_brcm_bcm2711_aux_uart_NUM_OKAY: u32 = 1;
pub const DT_N_INST_arm_cortex_a72_NUM_OKAY: u32 = 1;
pub const DT_N_INST_arm_armv8_timer_NUM_OKAY: u32 = 1;
pub const DT_N_INST_gpio_leds_NUM_OKAY: u32 = 1;
pub const Z_INIT_EARLY_EARLY: u32 = 1;
pub const Z_INIT_PRE_KERNEL_1_PRE_KERNEL_1: u32 = 1;
pub const Z_INIT_PRE_KERNEL_2_PRE_KERNEL_2: u32 = 1;
pub const Z_INIT_POST_KERNEL_POST_KERNEL: u32 = 1;
pub const Z_INIT_APPLICATION_APPLICATION: u32 = 1;
pub const Z_INIT_SMP_SMP: u32 = 1;
pub const Z_INIT_ORD_EARLY: u32 = 0;
pub const Z_INIT_ORD_PRE_KERNEL_1: u32 = 1;
pub const Z_INIT_ORD_PRE_KERNEL_2: u32 = 2;
pub const Z_INIT_ORD_POST_KERNEL: u32 = 3;
pub const Z_INIT_ORD_APPLICATION: u32 = 4;
pub const Z_INIT_ORD_SMP: u32 = 5;
pub const Z_MEM_VM_OFFSET: u32 = 0;
pub const K_MEM_CACHE_NONE: u32 = 2;
pub const K_MEM_CACHE_WT: u32 = 1;
pub const K_MEM_CACHE_WB: u32 = 0;
pub const Z_DEVICE_DEPS_SEP: i32 = -32768;
pub const Z_DEVICE_DEPS_ENDS: u32 = 32767;
pub const DEVICE_HANDLE_NULL: u32 = 0;
pub const Z_DEVICE_MAX_NAME_LEN: u32 = 48;
pub const GIC_INT_VIRT_MAINT: u32 = 25;
pub const GIC_INT_HYP_TIMER: u32 = 26;
pub const GIC_INT_VIRT_TIMER: u32 = 27;
pub const GIC_INT_LEGACY_FIQ: u32 = 28;
pub const GIC_INT_PHYS_TIMER: u32 = 29;
pub const GIC_INT_NS_PHYS_TIMER: u32 = 30;
pub const GIC_INT_LEGACY_IRQ: u32 = 31;
pub const GIC_SPI: u32 = 0;
pub const GIC_PPI: u32 = 1;
pub const IRQ_DEFAULT_PRIORITY: u32 = 160;
pub const ARCH_STACK_PTR_ALIGN: u32 = 16;
pub const Z_ARM64_STACK_BASE_ALIGN: u32 = 16;
pub const Z_ARM64_STACK_SIZE_ALIGN: u32 = 16;
pub const Z_ARM64_STACK_GUARD_SIZE: u32 = 0;
pub const Z_ARM64_K_STACK_BASE_ALIGN: u32 = 16;
pub const ARCH_KERNEL_STACK_RESERVED: u32 = 0;
pub const ARCH_KERNEL_STACK_OBJ_ALIGN: u32 = 16;
pub const NSEC_PER_USEC: u32 = 1000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const MSEC_PER_SEC: u32 = 1000;
pub const SEC_PER_MIN: u32 = 60;
pub const MIN_PER_HOUR: u32 = 60;
pub const HOUR_PER_DAY: u32 = 24;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const _TICK_ALIGN: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const Z_KERNEL_STACK_OBJ_ALIGN: u32 = 16;
pub const K_FP_IDX: u32 = 1;
pub const K_DSP_IDX: u32 = 6;
pub const K_AGU_IDX: u32 = 7;
pub const K_POLL_TYPE_IGNORE: u32 = 0;
pub const K_POLL_STATE_NOT_READY: u32 = 0;
pub const GPIO_DT_FLAGS_MASK: u32 = 63;
pub const GPIO_ACTIVE_LOW: u32 = 1;
pub const GPIO_ACTIVE_HIGH: u32 = 0;
pub const GPIO_SINGLE_ENDED: u32 = 2;
pub const GPIO_PUSH_PULL: u32 = 0;
pub const GPIO_LINE_OPEN_DRAIN: u32 = 4;
pub const GPIO_LINE_OPEN_SOURCE: u32 = 0;
pub const GPIO_OPEN_DRAIN: u32 = 6;
pub const GPIO_OPEN_SOURCE: u32 = 2;
pub const GPIO_PULL_UP: u32 = 16;
pub const GPIO_PULL_DOWN: u32 = 32;
pub const GPIO_INPUT: u32 = 65536;
pub const GPIO_OUTPUT: u32 = 131072;
pub const GPIO_DISCONNECTED: u32 = 0;
pub const GPIO_OUTPUT_INIT_LOW: u32 = 262144;
pub const GPIO_OUTPUT_INIT_HIGH: u32 = 524288;
pub const GPIO_OUTPUT_INIT_LOGICAL: u32 = 1048576;
pub const GPIO_OUTPUT_LOW: u32 = 393216;
pub const GPIO_OUTPUT_HIGH: u32 = 655360;
pub const GPIO_OUTPUT_INACTIVE: u32 = 1441792;
pub const GPIO_OUTPUT_ACTIVE: u32 = 1703936;
pub const GPIO_INT_DISABLE: u32 = 2097152;
pub const GPIO_INT_ENABLE: u32 = 4194304;
pub const GPIO_INT_LEVELS_LOGICAL: u32 = 8388608;
pub const GPIO_INT_EDGE: u32 = 16777216;
pub const GPIO_INT_LOW_0: u32 = 33554432;
pub const GPIO_INT_HIGH_1: u32 = 67108864;
pub const GPIO_INT_MASK: u32 = 132120576;
pub const GPIO_INT_EDGE_RISING: u32 = 88080384;
pub const GPIO_INT_EDGE_FALLING: u32 = 54525952;
pub const GPIO_INT_EDGE_BOTH: u32 = 121634816;
pub const GPIO_INT_LEVEL_LOW: u32 = 37748736;
pub const GPIO_INT_LEVEL_HIGH: u32 = 71303168;
pub const GPIO_INT_EDGE_TO_INACTIVE: u32 = 62914560;
pub const GPIO_INT_EDGE_TO_ACTIVE: u32 = 96468992;
pub const GPIO_INT_LEVEL_INACTIVE: u32 = 46137344;
pub const GPIO_INT_LEVEL_ACTIVE: u32 = 79691776;
pub const GPIO_DIR_MASK: u32 = 196608;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __suseconds64_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: cty::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: cty::c_uint,
    pub __wchb: [cty::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos64_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: cty::c_int,
    pub _IO_read_ptr: *mut cty::c_char,
    pub _IO_read_end: *mut cty::c_char,
    pub _IO_read_base: *mut cty::c_char,
    pub _IO_write_base: *mut cty::c_char,
    pub _IO_write_ptr: *mut cty::c_char,
    pub _IO_write_end: *mut cty::c_char,
    pub _IO_buf_base: *mut cty::c_char,
    pub _IO_buf_end: *mut cty::c_char,
    pub _IO_save_base: *mut cty::c_char,
    pub _IO_backup_base: *mut cty::c_char,
    pub _IO_save_end: *mut cty::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: cty::c_int,
    pub _flags2: cty::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: cty::c_ushort,
    pub _vtable_offset: cty::c_schar,
    pub _shortbuf: [cty::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut cty::c_void,
    pub __pad5: usize,
    pub _mode: cty::c_int,
    pub _unused2: [cty::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_FILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(__old: *const cty::c_char, __new: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: cty::c_int,
        __old: *const cty::c_char,
        __newfd: cty::c_int,
        __new: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const cty::c_char, __pfx: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const cty::c_char,
        __modes: *const cty::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: cty::c_int, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut cty::c_void, __len: usize, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut cty::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut cty::c_char,
        __modes: cty::c_int,
        __n: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut cty::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn printf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_ulong,
        __format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_ulong,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: cty::c_int,
        __fmt: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn dprintf(__fd: cty::c_int, __fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putw(__w: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut cty::c_char, __n: cty::c_int, __stream: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut usize,
        __delimiter: cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut usize,
        __delimiter: cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const cty::c_char, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn puts(__s: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn ungetc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut cty::c_void,
        __size: cty::c_ulong,
        __n: cty::c_ulong,
        __stream: *mut FILE,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const cty::c_void,
        __size: cty::c_ulong,
        __n: cty::c_ulong,
        __s: *mut FILE,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut cty::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const cty::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: cty::c_long, __whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(__s: *const cty::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(__command: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: cty::c_int) -> cty::c_int;
}
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union z_max_align_t {
    pub thelonglong: cty::c_longlong,
    pub thelongdouble: u128,
    pub theuintmax_t: uintmax_t,
    pub thesize_t: usize,
    pub theuintptr_t: usize,
    pub thepvoid: *mut cty::c_void,
    pub thepfunc: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_z_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<z_max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(z_max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<z_max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(z_max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thelonglong) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_max_align_t),
            "::",
            stringify!(thelonglong)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thelongdouble) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_max_align_t),
            "::",
            stringify!(thelongdouble)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).theuintmax_t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_max_align_t),
            "::",
            stringify!(theuintmax_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thesize_t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_max_align_t),
            "::",
            stringify!(thesize_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).theuintptr_t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_max_align_t),
            "::",
            stringify!(theuintptr_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thepvoid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_max_align_t),
            "::",
            stringify!(thepvoid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thepfunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_max_align_t),
            "::",
            stringify!(thepfunc)
        )
    );
}
pub type atomic_t = cty::c_long;
pub type atomic_val_t = atomic_t;
pub type atomic_ptr_t = *mut cty::c_void;
pub type atomic_ptr_val_t = atomic_ptr_t;
extern "C" {
    #[doc = " @brief Atomic compare-and-set.\n\n This routine performs an atomic compare-and-set on @a target. If the current\n value of @a target equals @a old_value, @a target is set to @a new_value.\n If the current value of @a target does not equal @a old_value, @a target\n is left unchanged.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param old_value Original value to compare against.\n @param new_value New value to store.\n @return true if @a new_value is written, false otherwise."]
    #[link_name = "atomic_cas__extern"]
    pub fn atomic_cas(
        target: *mut atomic_t,
        old_value: atomic_val_t,
        new_value: atomic_val_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Atomic compare-and-set with pointer values\n\n This routine performs an atomic compare-and-set on @a target. If the current\n value of @a target equals @a old_value, @a target is set to @a new_value.\n If the current value of @a target does not equal @a old_value, @a target\n is left unchanged.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param old_value Original value to compare against.\n @param new_value New value to store.\n @return true if @a new_value is written, false otherwise."]
    #[link_name = "atomic_ptr_cas__extern"]
    pub fn atomic_ptr_cas(
        target: *mut atomic_ptr_t,
        old_value: atomic_ptr_val_t,
        new_value: atomic_ptr_val_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Atomic addition.\n\n This routine performs an atomic addition on @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param value Value to add.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_add__extern"]
    pub fn atomic_add(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic subtraction.\n\n This routine performs an atomic subtraction on @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param value Value to subtract.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_sub__extern"]
    pub fn atomic_sub(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic increment.\n\n This routine performs an atomic increment by 1 on @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_inc__extern"]
    pub fn atomic_inc(target: *mut atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic decrement.\n\n This routine performs an atomic decrement by 1 on @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_dec__extern"]
    pub fn atomic_dec(target: *mut atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic get.\n\n This routine performs an atomic read on @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n\n @return Value of @a target."]
    #[link_name = "atomic_get__extern"]
    pub fn atomic_get(target: *const atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic get a pointer value\n\n This routine performs an atomic read on @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of pointer variable.\n\n @return Value of @a target."]
    #[link_name = "atomic_ptr_get__extern"]
    pub fn atomic_ptr_get(target: *const atomic_ptr_t) -> atomic_ptr_val_t;
}
extern "C" {
    #[doc = " @brief Atomic get-and-set.\n\n This routine atomically sets @a target to @a value and returns\n the previous value of @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param value Value to write to @a target.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_set__extern"]
    pub fn atomic_set(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic get-and-set for pointer values\n\n This routine atomically sets @a target to @a value and returns\n the previous value of @a target.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param value Value to write to @a target.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_ptr_set__extern"]
    pub fn atomic_ptr_set(target: *mut atomic_ptr_t, value: atomic_ptr_val_t) -> atomic_ptr_val_t;
}
extern "C" {
    #[doc = " @brief Atomic clear.\n\n This routine atomically sets @a target to zero and returns its previous\n value. (Hence, it is equivalent to atomic_set(target, 0).)\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_clear__extern"]
    pub fn atomic_clear(target: *mut atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic clear of a pointer value\n\n This routine atomically sets @a target to zero and returns its previous\n value. (Hence, it is equivalent to atomic_set(target, 0).)\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_ptr_clear__extern"]
    pub fn atomic_ptr_clear(target: *mut atomic_ptr_t) -> atomic_ptr_val_t;
}
extern "C" {
    #[doc = " @brief Atomic bitwise inclusive OR.\n\n This routine atomically sets @a target to the bitwise inclusive OR of\n @a target and @a value.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param value Value to OR.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_or__extern"]
    pub fn atomic_or(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic bitwise exclusive OR (XOR).\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n This routine atomically sets @a target to the bitwise exclusive OR (XOR) of\n @a target and @a value.\n\n @param target Address of atomic variable.\n @param value Value to XOR\n\n @return Previous value of @a target."]
    #[link_name = "atomic_xor__extern"]
    pub fn atomic_xor(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic bitwise AND.\n\n This routine atomically sets @a target to the bitwise AND of @a target\n and @a value.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param value Value to AND.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_and__extern"]
    pub fn atomic_and(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomic bitwise NAND.\n\n This routine atomically sets @a target to the bitwise NAND of @a target\n and @a value. (This operation is equivalent to target = ~(target & value).)\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable.\n @param value Value to NAND.\n\n @return Previous value of @a target."]
    #[link_name = "atomic_nand__extern"]
    pub fn atomic_nand(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Atomically test a bit.\n\n This routine tests whether bit number @a bit of @a target is set or not.\n The target may be a single atomic variable or an array of them.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable or array.\n @param bit Bit number (starting from 0).\n\n @return true if the bit was set, false if it wasn't."]
    #[link_name = "atomic_test_bit__extern"]
    pub fn atomic_test_bit(target: *const atomic_t, bit: cty::c_int) -> bool;
}
extern "C" {
    #[doc = " @brief Atomically test and clear a bit.\n\n Atomically clear bit number @a bit of @a target and return its old value.\n The target may be a single atomic variable or an array of them.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable or array.\n @param bit Bit number (starting from 0).\n\n @return false if the bit was already cleared, true if it wasn't."]
    #[link_name = "atomic_test_and_clear_bit__extern"]
    pub fn atomic_test_and_clear_bit(target: *mut atomic_t, bit: cty::c_int) -> bool;
}
extern "C" {
    #[doc = " @brief Atomically set a bit.\n\n Atomically set bit number @a bit of @a target and return its old value.\n The target may be a single atomic variable or an array of them.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable or array.\n @param bit Bit number (starting from 0).\n\n @return true if the bit was already set, false if it wasn't."]
    #[link_name = "atomic_test_and_set_bit__extern"]
    pub fn atomic_test_and_set_bit(target: *mut atomic_t, bit: cty::c_int) -> bool;
}
extern "C" {
    #[doc = " @brief Atomically clear a bit.\n\n Atomically clear bit number @a bit of @a target.\n The target may be a single atomic variable or an array of them.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable or array.\n @param bit Bit number (starting from 0)."]
    #[link_name = "atomic_clear_bit__extern"]
    pub fn atomic_clear_bit(target: *mut atomic_t, bit: cty::c_int);
}
extern "C" {
    #[doc = " @brief Atomically set a bit.\n\n Atomically set bit number @a bit of @a target.\n The target may be a single atomic variable or an array of them.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable or array.\n @param bit Bit number (starting from 0)."]
    #[link_name = "atomic_set_bit__extern"]
    pub fn atomic_set_bit(target: *mut atomic_t, bit: cty::c_int);
}
extern "C" {
    #[doc = " @brief Atomically set a bit to a given value.\n\n Atomically set bit number @a bit of @a target to value @a val.\n The target may be a single atomic variable or an array of them.\n\n @note As for all atomic APIs, includes a\n full/sequentially-consistent memory barrier (where applicable).\n\n @param target Address of atomic variable or array.\n @param bit Bit number (starting from 0).\n @param val true for 1, false for 0."]
    #[link_name = "atomic_set_bit_to__extern"]
    pub fn atomic_set_bit_to(target: *mut atomic_t, bit: cty::c_int, val: bool);
}
extern "C" {
    pub fn assert_print(fmt: *const cty::c_char, ...);
}
extern "C" {
    #[doc = " @brief Is @p x a power of two?\n @param x value to check\n @return true if @p x is a power of two, false otherwise"]
    #[link_name = "is_power_of_two__extern"]
    pub fn is_power_of_two(x: cty::c_uint) -> bool;
}
extern "C" {
    #[doc = " @brief Arithmetic shift right\n @param value value to shift\n @param shift number of bits to shift\n @return @p value shifted right by @p shift; opened bit positions are\n         filled with the sign bit"]
    #[link_name = "arithmetic_shift_right__extern"]
    pub fn arithmetic_shift_right(value: i64, shift: u8) -> i64;
}
extern "C" {
    #[doc = " @brief byte by byte memcpy.\n\n Copy `size` bytes of `src` into `dest`. This is guaranteed to be done byte by byte.\n\n @param dst Pointer to the destination memory.\n @param src Pointer to the source of the data.\n @param size The number of bytes to copy."]
    #[link_name = "bytecpy__extern"]
    pub fn bytecpy(dst: *mut cty::c_void, src: *const cty::c_void, size: usize);
}
extern "C" {
    #[doc = " @brief byte by byte swap.\n\n Swap @a size bytes between memory regions @a a and @a b. This is\n guaranteed to be done byte by byte.\n\n @param a Pointer to the the first memory region.\n @param b Pointer to the the second memory region.\n @param size The number of bytes to swap."]
    #[link_name = "byteswp__extern"]
    pub fn byteswp(a: *mut cty::c_void, b: *mut cty::c_void, size: usize);
}
extern "C" {
    #[doc = " @brief      Convert a single character into a hexadecimal nibble.\n\n @param c     The character to convert\n @param x     The address of storage for the converted number.\n\n  @return Zero on success or (negative) error code otherwise."]
    pub fn char2hex(c: cty::c_char, x: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Convert a single hexadecimal nibble into a character.\n\n @param c     The number to convert\n @param x     The address of storage for the converted character.\n\n  @return Zero on success or (negative) error code otherwise."]
    pub fn hex2char(x: u8, c: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Convert a binary array into string representation.\n\n @param buf     The binary array to convert\n @param buflen  The length of the binary array to convert\n @param hex     Address of where to store the string representation.\n @param hexlen  Size of the storage area for string representation.\n\n @return     The length of the converted string, or 0 if an error occurred."]
    pub fn bin2hex(buf: *const u8, buflen: usize, hex: *mut cty::c_char, hexlen: usize) -> usize;
}
extern "C" {
    #[doc = " @brief      Convert a hexadecimal string into a binary array.\n\n @param hex     The hexadecimal string to convert\n @param hexlen  The length of the hexadecimal string to convert.\n @param buf     Address of where to store the binary data\n @param buflen  Size of the storage area for binary data\n\n @return     The length of the binary array, or 0 if an error occurred."]
    pub fn hex2bin(hex: *const cty::c_char, hexlen: usize, buf: *mut u8, buflen: usize) -> usize;
}
extern "C" {
    #[doc = " @brief Convert a binary coded decimal (BCD 8421) value to binary.\n\n @param bcd BCD 8421 value to convert.\n\n @return Binary representation of input value."]
    #[link_name = "bcd2bin__extern"]
    pub fn bcd2bin(bcd: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Convert a binary value to binary coded decimal (BCD 8421).\n\n @param bin Binary value to convert.\n\n @return BCD 8421 representation of input value."]
    #[link_name = "bin2bcd__extern"]
    pub fn bin2bcd(bin: u8) -> u8;
}
extern "C" {
    #[doc = " @brief      Convert a uint8_t into a decimal string representation.\n\n Convert a uint8_t value into its ASCII decimal string representation.\n The string is terminated if there is enough space in buf.\n\n @param buf     Address of where to store the string representation.\n @param buflen  Size of the storage area for string representation.\n @param value   The value to convert to decimal string\n\n @return     The length of the converted string (excluding terminator if\n             any), or 0 if an error occurred."]
    pub fn u8_to_dec(buf: *mut cty::c_char, buflen: u8, value: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Properly truncate a NULL-terminated UTF-8 string\n\n Take a NULL-terminated UTF-8 string and ensure that if the string has been\n truncated (by setting the NULL terminator) earlier by other means, that\n the string ends with a properly formatted UTF-8 character (1-4 bytes).\n\n @htmlonly\n Example:\n      char test_str[] = \"\";\n      char trunc_utf8[8];\n\n      printf(\"Original : %s\\n\", test_str); // \n      strncpy(trunc_utf8, test_str, sizeof(trunc_utf8));\n      trunc_utf8[sizeof(trunc_utf8) - 1] = '\\0';\n      printf(\"Bad      : %s\\n\", trunc_utf8); // \n      utf8_trunc(trunc_utf8);\n      printf(\"Truncated: %s\\n\", trunc_utf8); // \n @endhtmlonly\n\n @param utf8_str NULL-terminated string\n\n @return Pointer to the @p utf8_str"]
    pub fn utf8_trunc(utf8_str: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " @brief Copies a UTF-8 encoded string from @p src to @p dst\n\n The resulting @p dst will always be NULL terminated if @p n is larger than 0,\n and the @p dst string will always be properly UTF-8 truncated.\n\n @param dst The destination of the UTF-8 string.\n @param src The source string\n @param n   The size of the @p dst buffer. Maximum number of characters copied\n            is @p n - 1. If 0 nothing will be done, and the @p dst will not be\n            NULL terminated.\n\n @return Pointer to the @p dst"]
    pub fn utf8_lcpy(dst: *mut cty::c_char, src: *const cty::c_char, n: usize) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _dnode {
    pub __bindgen_anon_1: _dnode__bindgen_ty_1,
    pub __bindgen_anon_2: _dnode__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _dnode__bindgen_ty_1 {
    pub head: *mut _dnode,
    pub next: *mut _dnode,
}
#[test]
fn bindgen_test_layout__dnode__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_dnode__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_dnode__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_dnode__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_dnode__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_dnode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _dnode__bindgen_ty_2 {
    pub tail: *mut _dnode,
    pub prev: *mut _dnode,
}
#[test]
fn bindgen_test_layout__dnode__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_dnode__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_dnode__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_dnode__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_dnode__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_dnode__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_2),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout__dnode() {
    assert_eq!(
        ::core::mem::size_of::<_dnode>(),
        16usize,
        concat!("Size of: ", stringify!(_dnode))
    );
    assert_eq!(
        ::core::mem::align_of::<_dnode>(),
        8usize,
        concat!("Alignment of ", stringify!(_dnode))
    );
}
#[doc = " @brief Doubly-linked list structure."]
pub type sys_dlist_t = _dnode;
#[doc = " @brief Doubly-linked list node structure."]
pub type sys_dnode_t = _dnode;
extern "C" {
    #[doc = " @brief initialize list to its empty state\n\n @param list the doubly-linked list"]
    #[link_name = "sys_dlist_init__extern"]
    pub fn sys_dlist_init(list: *mut sys_dlist_t);
}
extern "C" {
    #[doc = " @brief initialize node to its state when not in a list\n\n @param node the node"]
    #[link_name = "sys_dnode_init__extern"]
    pub fn sys_dnode_init(node: *mut sys_dnode_t);
}
extern "C" {
    #[doc = " @brief check if a node is a member of any list\n\n @param node the node\n\n @return true if node is linked into a list, false if it is not"]
    #[link_name = "sys_dnode_is_linked__extern"]
    pub fn sys_dnode_is_linked(node: *const sys_dnode_t) -> bool;
}
extern "C" {
    #[doc = " @brief check if a node is the list's head\n\n @param list the doubly-linked list to operate on\n @param node the node to check\n\n @return true if node is the head, false otherwise"]
    #[link_name = "sys_dlist_is_head__extern"]
    pub fn sys_dlist_is_head(list: *mut sys_dlist_t, node: *mut sys_dnode_t) -> bool;
}
extern "C" {
    #[doc = " @brief check if a node is the list's tail\n\n @param list the doubly-linked list to operate on\n @param node the node to check\n\n @return true if node is the tail, false otherwise"]
    #[link_name = "sys_dlist_is_tail__extern"]
    pub fn sys_dlist_is_tail(list: *mut sys_dlist_t, node: *mut sys_dnode_t) -> bool;
}
extern "C" {
    #[doc = " @brief check if the list is empty\n\n @param list the doubly-linked list to operate on\n\n @return true if empty, false otherwise"]
    #[link_name = "sys_dlist_is_empty__extern"]
    pub fn sys_dlist_is_empty(list: *mut sys_dlist_t) -> bool;
}
extern "C" {
    #[doc = " @brief check if more than one node present\n\n This and other sys_dlist_*() functions are not thread safe.\n\n @param list the doubly-linked list to operate on\n\n @return true if multiple nodes, false otherwise"]
    #[link_name = "sys_dlist_has_multiple_nodes__extern"]
    pub fn sys_dlist_has_multiple_nodes(list: *mut sys_dlist_t) -> bool;
}
extern "C" {
    #[doc = " @brief get a reference to the head item in the list\n\n @param list the doubly-linked list to operate on\n\n @return a pointer to the head element, NULL if list is empty"]
    #[link_name = "sys_dlist_peek_head__extern"]
    pub fn sys_dlist_peek_head(list: *mut sys_dlist_t) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief get a reference to the head item in the list\n\n The list must be known to be non-empty.\n\n @param list the doubly-linked list to operate on\n\n @return a pointer to the head element"]
    #[link_name = "sys_dlist_peek_head_not_empty__extern"]
    pub fn sys_dlist_peek_head_not_empty(list: *mut sys_dlist_t) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief get a reference to the next item in the list, node is not NULL\n\n Faster than sys_dlist_peek_next() if node is known not to be NULL.\n\n @param list the doubly-linked list to operate on\n @param node the node from which to get the next element in the list\n\n @return a pointer to the next element from a node, NULL if node is the tail"]
    #[link_name = "sys_dlist_peek_next_no_check__extern"]
    pub fn sys_dlist_peek_next_no_check(
        list: *mut sys_dlist_t,
        node: *mut sys_dnode_t,
    ) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief get a reference to the next item in the list\n\n @param list the doubly-linked list to operate on\n @param node the node from which to get the next element in the list\n\n @return a pointer to the next element from a node, NULL if node is the tail\n or NULL (when node comes from reading the head of an empty list)."]
    #[link_name = "sys_dlist_peek_next__extern"]
    pub fn sys_dlist_peek_next(list: *mut sys_dlist_t, node: *mut sys_dnode_t) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief get a reference to the previous item in the list, node is not NULL\n\n Faster than sys_dlist_peek_prev() if node is known not to be NULL.\n\n @param list the doubly-linked list to operate on\n @param node the node from which to get the previous element in the list\n\n @return a pointer to the previous element from a node, NULL if node is the\n\t   tail"]
    #[link_name = "sys_dlist_peek_prev_no_check__extern"]
    pub fn sys_dlist_peek_prev_no_check(
        list: *mut sys_dlist_t,
        node: *mut sys_dnode_t,
    ) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief get a reference to the previous item in the list\n\n @param list the doubly-linked list to operate on\n @param node the node from which to get the previous element in the list\n\n @return a pointer to the previous element from a node, NULL if node is the\n \t   tail or NULL (when node comes from reading the head of an empty\n \t   list)."]
    #[link_name = "sys_dlist_peek_prev__extern"]
    pub fn sys_dlist_peek_prev(list: *mut sys_dlist_t, node: *mut sys_dnode_t) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief get a reference to the tail item in the list\n\n @param list the doubly-linked list to operate on\n\n @return a pointer to the tail element, NULL if list is empty"]
    #[link_name = "sys_dlist_peek_tail__extern"]
    pub fn sys_dlist_peek_tail(list: *mut sys_dlist_t) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief add node to tail of list\n\n This and other sys_dlist_*() functions are not thread safe.\n\n @param list the doubly-linked list to operate on\n @param node the element to append"]
    #[link_name = "sys_dlist_append__extern"]
    pub fn sys_dlist_append(list: *mut sys_dlist_t, node: *mut sys_dnode_t);
}
extern "C" {
    #[doc = " @brief add node to head of list\n\n This and other sys_dlist_*() functions are not thread safe.\n\n @param list the doubly-linked list to operate on\n @param node the element to append"]
    #[link_name = "sys_dlist_prepend__extern"]
    pub fn sys_dlist_prepend(list: *mut sys_dlist_t, node: *mut sys_dnode_t);
}
extern "C" {
    #[doc = " @brief Insert a node into a list\n\n Insert a node before a specified node in a dlist.\n\n @param successor the position before which \"node\" will be inserted\n @param node the element to insert"]
    #[link_name = "sys_dlist_insert__extern"]
    pub fn sys_dlist_insert(successor: *mut sys_dnode_t, node: *mut sys_dnode_t);
}
extern "C" {
    #[doc = " @brief insert node at position\n\n Insert a node in a location depending on a external condition. The cond()\n function checks if the node is to be inserted _before_ the current node\n against which it is checked.\n This and other sys_dlist_*() functions are not thread safe.\n\n @param list the doubly-linked list to operate on\n @param node the element to insert\n @param cond a function that determines if the current node is the correct\n             insert point\n @param data parameter to cond()"]
    #[link_name = "sys_dlist_insert_at__extern"]
    pub fn sys_dlist_insert_at(
        list: *mut sys_dlist_t,
        node: *mut sys_dnode_t,
        cond: ::core::option::Option<
            unsafe extern "C" fn(node: *mut sys_dnode_t, data: *mut cty::c_void) -> cty::c_int,
        >,
        data: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief remove a specific node from a list\n\n The list is implicit from the node. The node must be part of a list.\n This and other sys_dlist_*() functions are not thread safe.\n\n @param node the node to remove"]
    #[link_name = "sys_dlist_remove__extern"]
    pub fn sys_dlist_remove(node: *mut sys_dnode_t);
}
extern "C" {
    #[doc = " @brief get the first node in a list\n\n This and other sys_dlist_*() functions are not thread safe.\n\n @param list the doubly-linked list to operate on\n\n @return the first node in the list, NULL if list is empty"]
    #[link_name = "sys_dlist_get__extern"]
    pub fn sys_dlist_get(list: *mut sys_dlist_t) -> *mut sys_dnode_t;
}
extern "C" {
    #[doc = " @brief Compute the size of the given list in O(n) time\n\n @param list A pointer on the list\n\n @return an integer equal to the size of the list, or 0 if empty"]
    #[link_name = "sys_dlist_len__extern"]
    pub fn sys_dlist_len(list: *mut sys_dlist_t) -> usize;
}
#[doc = " @brief Balanced red/black tree node structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbnode {
    #[doc = " @cond INTERNAL_HIDDEN"]
    pub children: [*mut rbnode; 2usize],
}
#[test]
fn bindgen_test_layout_rbnode() {
    const UNINIT: ::core::mem::MaybeUninit<rbnode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rbnode>(),
        16usize,
        concat!("Size of: ", stringify!(rbnode))
    );
    assert_eq!(
        ::core::mem::align_of::<rbnode>(),
        8usize,
        concat!("Alignment of ", stringify!(rbnode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rbnode),
            "::",
            stringify!(children)
        )
    );
}
#[doc = " @typedef rb_lessthan_t\n @brief Red/black tree comparison predicate\n\n Compares the two nodes and returns true if node A is strictly less\n than B according to the tree's sorting criteria, false otherwise.\n\n Note that during insert, the new node being inserted will always be\n \"A\", where \"B\" is the existing node within the tree against which\n it is being compared.  This trait can be used (with care!) to\n implement \"most/least recently added\" semantics between nodes which\n would otherwise compare as equal."]
pub type rb_lessthan_t =
    ::core::option::Option<unsafe extern "C" fn(a: *mut rbnode, b: *mut rbnode) -> bool>;
#[doc = " @brief Balanced red/black tree structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbtree {
    #[doc = " Root node of the tree"]
    pub root: *mut rbnode,
    #[doc = " Comparison function for nodes in the tree"]
    pub lessthan_fn: rb_lessthan_t,
    #[doc = " @cond INTERNAL_HIDDEN"]
    pub max_depth: cty::c_int,
}
#[test]
fn bindgen_test_layout_rbtree() {
    const UNINIT: ::core::mem::MaybeUninit<rbtree> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rbtree>(),
        24usize,
        concat!("Size of: ", stringify!(rbtree))
    );
    assert_eq!(
        ::core::mem::align_of::<rbtree>(),
        8usize,
        concat!("Alignment of ", stringify!(rbtree))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lessthan_fn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree),
            "::",
            stringify!(lessthan_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree),
            "::",
            stringify!(max_depth)
        )
    );
}
#[doc = " @brief Prototype for node visitor callback.\n @param node Node being visited\n @param cookie User-specified data"]
pub type rb_visit_t =
    ::core::option::Option<unsafe extern "C" fn(node: *mut rbnode, cookie: *mut cty::c_void)>;
extern "C" {
    pub fn z_rb_child(node: *mut rbnode, side: u8) -> *mut rbnode;
}
extern "C" {
    pub fn z_rb_is_black(node: *mut rbnode) -> cty::c_int;
}
extern "C" {
    pub fn z_rb_walk(node: *mut rbnode, visit_fn: rb_visit_t, cookie: *mut cty::c_void);
}
extern "C" {
    pub fn z_rb_get_minmax(tree: *mut rbtree, side: u8) -> *mut rbnode;
}
extern "C" {
    #[doc = " @brief Insert node into tree"]
    pub fn rb_insert(tree: *mut rbtree, node: *mut rbnode);
}
extern "C" {
    #[doc = " @brief Remove node from tree"]
    pub fn rb_remove(tree: *mut rbtree, node: *mut rbnode);
}
extern "C" {
    #[doc = " @brief Returns the lowest-sorted member of the tree"]
    #[link_name = "rb_get_min__extern"]
    pub fn rb_get_min(tree: *mut rbtree) -> *mut rbnode;
}
extern "C" {
    #[doc = " @brief Returns the highest-sorted member of the tree"]
    #[link_name = "rb_get_max__extern"]
    pub fn rb_get_max(tree: *mut rbtree) -> *mut rbnode;
}
extern "C" {
    #[doc = " @brief Returns true if the given node is part of the tree\n\n Note that this does not internally dereference the node pointer\n (though the tree's lessthan callback might!), it just tests it for\n equality with items in the tree.  So it's feasible to use this to\n implement a \"set\" construct by simply testing the pointer value\n itself."]
    pub fn rb_contains(tree: *mut rbtree, node: *mut rbnode) -> bool;
}
extern "C" {
    #[doc = " @brief Walk/enumerate a rbtree\n\n Very simple recursive enumeration.  Low code size, but requiring a\n separate function can be clumsy for the user and there is no way to\n break out of the loop early.  See RB_FOR_EACH for an iterative\n implementation."]
    #[link_name = "rb_walk__extern"]
    pub fn rb_walk(tree: *mut rbtree, visit_fn: rb_visit_t, cookie: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rb_foreach {
    pub stack: *mut *mut rbnode,
    pub is_left: *mut u8,
    pub top: i32,
}
#[test]
fn bindgen_test_layout__rb_foreach() {
    const UNINIT: ::core::mem::MaybeUninit<_rb_foreach> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rb_foreach>(),
        24usize,
        concat!("Size of: ", stringify!(_rb_foreach))
    );
    assert_eq!(
        ::core::mem::align_of::<_rb_foreach>(),
        8usize,
        concat!("Alignment of ", stringify!(_rb_foreach))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rb_foreach),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_rb_foreach),
            "::",
            stringify!(is_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_rb_foreach),
            "::",
            stringify!(top)
        )
    );
}
extern "C" {
    pub fn z_rb_foreach_next(tree: *mut rbtree, f: *mut _rb_foreach) -> *mut rbnode;
}
extern "C" {
    pub fn z_priq_dumb_best(pq: *mut sys_dlist_t) -> *mut k_thread;
}
extern "C" {
    pub fn z_priq_dumb_remove(pq: *mut sys_dlist_t, thread: *mut k_thread);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _priq_rb {
    pub tree: rbtree,
    pub next_order_key: cty::c_int,
}
#[test]
fn bindgen_test_layout__priq_rb() {
    const UNINIT: ::core::mem::MaybeUninit<_priq_rb> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_priq_rb>(),
        32usize,
        concat!("Size of: ", stringify!(_priq_rb))
    );
    assert_eq!(
        ::core::mem::align_of::<_priq_rb>(),
        8usize,
        concat!("Alignment of ", stringify!(_priq_rb))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tree) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_rb),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_order_key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_rb),
            "::",
            stringify!(next_order_key)
        )
    );
}
extern "C" {
    pub fn z_priq_rb_add(pq: *mut _priq_rb, thread: *mut k_thread);
}
extern "C" {
    pub fn z_priq_rb_remove(pq: *mut _priq_rb, thread: *mut k_thread);
}
extern "C" {
    pub fn z_priq_rb_best(pq: *mut _priq_rb) -> *mut k_thread;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _priq_mq {
    pub queues: [sys_dlist_t; 32usize],
    pub bitmask: cty::c_uint,
}
#[test]
fn bindgen_test_layout__priq_mq() {
    const UNINIT: ::core::mem::MaybeUninit<_priq_mq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_priq_mq>(),
        520usize,
        concat!("Size of: ", stringify!(_priq_mq))
    );
    assert_eq!(
        ::core::mem::align_of::<_priq_mq>(),
        8usize,
        concat!("Alignment of ", stringify!(_priq_mq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queues) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_mq),
            "::",
            stringify!(queues)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmask) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_mq),
            "::",
            stringify!(bitmask)
        )
    );
}
extern "C" {
    pub fn z_priq_mq_best(pq: *mut _priq_mq) -> *mut k_thread;
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _snode {
    pub next: *mut _snode,
}
#[test]
fn bindgen_test_layout__snode() {
    const UNINIT: ::core::mem::MaybeUninit<_snode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_snode>(),
        8usize,
        concat!("Size of: ", stringify!(_snode))
    );
    assert_eq!(
        ::core::mem::align_of::<_snode>(),
        8usize,
        concat!("Alignment of ", stringify!(_snode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_snode),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Single-linked list node structure."]
pub type sys_snode_t = _snode;
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _slist {
    pub head: *mut sys_snode_t,
    pub tail: *mut sys_snode_t,
}
#[test]
fn bindgen_test_layout__slist() {
    const UNINIT: ::core::mem::MaybeUninit<_slist> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_slist>(),
        16usize,
        concat!("Size of: ", stringify!(_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_slist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_slist),
            "::",
            stringify!(tail)
        )
    );
}
#[doc = " Single-linked list structure."]
pub type sys_slist_t = _slist;
extern "C" {
    #[doc = " @brief Initialize a list\n\n @param list A pointer on the list to initialize"]
    #[link_name = "sys_slist_init__extern"]
    pub fn sys_slist_init(list: *mut sys_slist_t);
}
extern "C" {
    #[link_name = "z_snode_next_peek__extern"]
    pub fn z_snode_next_peek(node: *mut sys_snode_t) -> *mut sys_snode_t;
}
extern "C" {
    #[link_name = "z_snode_next_set__extern"]
    pub fn z_snode_next_set(parent: *mut sys_snode_t, child: *mut sys_snode_t);
}
extern "C" {
    #[link_name = "z_slist_head_set__extern"]
    pub fn z_slist_head_set(list: *mut sys_slist_t, node: *mut sys_snode_t);
}
extern "C" {
    #[link_name = "z_slist_tail_set__extern"]
    pub fn z_slist_tail_set(list: *mut sys_slist_t, node: *mut sys_snode_t);
}
extern "C" {
    #[doc = " @brief Peek the first node from the list\n\n @param list A point on the list to peek the first node from\n\n @return A pointer on the first node of the list (or NULL if none)"]
    #[link_name = "sys_slist_peek_head__extern"]
    pub fn sys_slist_peek_head(list: *mut sys_slist_t) -> *mut sys_snode_t;
}
extern "C" {
    #[doc = " @brief Peek the last node from the list\n\n @param list A point on the list to peek the last node from\n\n @return A pointer on the last node of the list (or NULL if none)"]
    #[link_name = "sys_slist_peek_tail__extern"]
    pub fn sys_slist_peek_tail(list: *mut sys_slist_t) -> *mut sys_snode_t;
}
extern "C" {
    #[doc = " @brief Test if the given list is empty\n\n @param list A pointer on the list to test\n\n @return a boolean, true if it's empty, false otherwise"]
    #[link_name = "sys_slist_is_empty__extern"]
    pub fn sys_slist_is_empty(list: *mut sys_slist_t) -> bool;
}
extern "C" {
    #[doc = " @brief Peek the next node from current node, node is not NULL\n\n Faster then sys_slist_peek_next() if node is known not to be NULL.\n\n @param node A pointer on the node where to peek the next node\n\n @return a pointer on the next node (or NULL if none)"]
    #[link_name = "sys_slist_peek_next_no_check__extern"]
    pub fn sys_slist_peek_next_no_check(node: *mut sys_snode_t) -> *mut sys_snode_t;
}
extern "C" {
    #[doc = " @brief Peek the next node from current node\n\n @param node A pointer on the node where to peek the next node\n\n @return a pointer on the next node (or NULL if none)"]
    #[link_name = "sys_slist_peek_next__extern"]
    pub fn sys_slist_peek_next(node: *mut sys_snode_t) -> *mut sys_snode_t;
}
extern "C" {
    #[doc = " @brief Prepend a node to the given list\n\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param node A pointer on the node to prepend"]
    #[link_name = "sys_slist_prepend__extern"]
    pub fn sys_slist_prepend(list: *mut sys_slist_t, node: *mut sys_snode_t);
}
extern "C" {
    #[doc = " @brief Append a node to the given list\n\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param node A pointer on the node to append"]
    #[link_name = "sys_slist_append__extern"]
    pub fn sys_slist_append(list: *mut sys_slist_t, node: *mut sys_snode_t);
}
extern "C" {
    #[doc = " @brief Append a list to the given list\n\n Append a singly-linked, NULL-terminated list consisting of nodes containing\n the pointer to the next node as the first element of a node, to @a list.\n This and other sys_slist_*() functions are not thread safe.\n\n FIXME: Why are the element parameters void *?\n\n @param list A pointer on the list to affect\n @param head A pointer to the first element of the list to append\n @param tail A pointer to the last element of the list to append"]
    #[link_name = "sys_slist_append_list__extern"]
    pub fn sys_slist_append_list(
        list: *mut sys_slist_t,
        head: *mut cty::c_void,
        tail: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief merge two slists, appending the second one to the first\n\n When the operation is completed, the appending list is empty.\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param list_to_append A pointer to the list to append."]
    #[link_name = "sys_slist_merge_slist__extern"]
    pub fn sys_slist_merge_slist(list: *mut sys_slist_t, list_to_append: *mut sys_slist_t);
}
extern "C" {
    #[doc = " @brief Insert a node to the given list\n\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param prev A pointer on the previous node\n @param node A pointer on the node to insert"]
    #[link_name = "sys_slist_insert__extern"]
    pub fn sys_slist_insert(list: *mut sys_slist_t, prev: *mut sys_snode_t, node: *mut sys_snode_t);
}
extern "C" {
    #[doc = " @brief Fetch and remove the first node of the given list\n\n List must be known to be non-empty.\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n\n @return A pointer to the first node of the list"]
    #[link_name = "sys_slist_get_not_empty__extern"]
    pub fn sys_slist_get_not_empty(list: *mut sys_slist_t) -> *mut sys_snode_t;
}
extern "C" {
    #[doc = " @brief Fetch and remove the first node of the given list\n\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n\n @return A pointer to the first node of the list (or NULL if empty)"]
    #[link_name = "sys_slist_get__extern"]
    pub fn sys_slist_get(list: *mut sys_slist_t) -> *mut sys_snode_t;
}
extern "C" {
    #[doc = " @brief Remove a node\n\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param prev_node A pointer on the previous node\n        (can be NULL, which means the node is the list's head)\n @param node A pointer on the node to remove"]
    #[link_name = "sys_slist_remove__extern"]
    pub fn sys_slist_remove(
        list: *mut sys_slist_t,
        prev_node: *mut sys_snode_t,
        node: *mut sys_snode_t,
    );
}
extern "C" {
    #[doc = " @brief Find and remove a node from a list\n\n This and other sys_slist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param node A pointer on the node to remove from the list\n\n @return true if node was removed"]
    #[link_name = "sys_slist_find_and_remove__extern"]
    pub fn sys_slist_find_and_remove(list: *mut sys_slist_t, node: *mut sys_snode_t) -> bool;
}
extern "C" {
    #[doc = " @brief Compute the size of the given list in O(n) time\n\n @param list A pointer on the list\n\n @return an integer equal to the size of the list, or 0 if empty"]
    #[link_name = "sys_slist_len__extern"]
    pub fn sys_slist_len(list: *mut sys_slist_t) -> usize;
}
pub type unative_t = u64;
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sfnode {
    pub next_and_flags: unative_t,
}
#[test]
fn bindgen_test_layout__sfnode() {
    const UNINIT: ::core::mem::MaybeUninit<_sfnode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_sfnode>(),
        8usize,
        concat!("Size of: ", stringify!(_sfnode))
    );
    assert_eq!(
        ::core::mem::align_of::<_sfnode>(),
        8usize,
        concat!("Alignment of ", stringify!(_sfnode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_and_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sfnode),
            "::",
            stringify!(next_and_flags)
        )
    );
}
#[doc = " Flagged single-linked list node structure."]
pub type sys_sfnode_t = _sfnode;
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sflist {
    pub head: *mut sys_sfnode_t,
    pub tail: *mut sys_sfnode_t,
}
#[test]
fn bindgen_test_layout__sflist() {
    const UNINIT: ::core::mem::MaybeUninit<_sflist> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_sflist>(),
        16usize,
        concat!("Size of: ", stringify!(_sflist))
    );
    assert_eq!(
        ::core::mem::align_of::<_sflist>(),
        8usize,
        concat!("Alignment of ", stringify!(_sflist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sflist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_sflist),
            "::",
            stringify!(tail)
        )
    );
}
#[doc = " Flagged single-linked list structure."]
pub type sys_sflist_t = _sflist;
extern "C" {
    #[doc = " @brief Initialize a list\n\n @param list A pointer on the list to initialize"]
    #[link_name = "sys_sflist_init__extern"]
    pub fn sys_sflist_init(list: *mut sys_sflist_t);
}
extern "C" {
    #[link_name = "z_sfnode_next_peek__extern"]
    pub fn z_sfnode_next_peek(node: *mut sys_sfnode_t) -> *mut sys_sfnode_t;
}
extern "C" {
    #[doc = " @brief Fetch flags value for a particular sfnode\n\n @param node A pointer to the node to fetch flags from\n @return The value of flags, which will be between 0 and 3"]
    #[link_name = "sys_sfnode_flags_get__extern"]
    pub fn sys_sfnode_flags_get(node: *mut sys_sfnode_t) -> u8;
}
extern "C" {
    #[link_name = "z_sfnode_next_set__extern"]
    pub fn z_sfnode_next_set(parent: *mut sys_sfnode_t, child: *mut sys_sfnode_t);
}
extern "C" {
    #[link_name = "z_sflist_head_set__extern"]
    pub fn z_sflist_head_set(list: *mut sys_sflist_t, node: *mut sys_sfnode_t);
}
extern "C" {
    #[link_name = "z_sflist_tail_set__extern"]
    pub fn z_sflist_tail_set(list: *mut sys_sflist_t, node: *mut sys_sfnode_t);
}
extern "C" {
    #[doc = " @brief Peek the first node from the list\n\n @param list A point on the list to peek the first node from\n\n @return A pointer on the first node of the list (or NULL if none)"]
    #[link_name = "sys_sflist_peek_head__extern"]
    pub fn sys_sflist_peek_head(list: *mut sys_sflist_t) -> *mut sys_sfnode_t;
}
extern "C" {
    #[doc = " @brief Peek the last node from the list\n\n @param list A point on the list to peek the last node from\n\n @return A pointer on the last node of the list (or NULL if none)"]
    #[link_name = "sys_sflist_peek_tail__extern"]
    pub fn sys_sflist_peek_tail(list: *mut sys_sflist_t) -> *mut sys_sfnode_t;
}
extern "C" {
    #[doc = " @brief Initialize an sflist node\n\n Set an initial flags value for this slist node, which can be a value between\n 0 and 3. These flags will persist even if the node is moved around\n within a list, removed, or transplanted to a different slist.\n\n This is ever so slightly faster than sys_sfnode_flags_set() and should\n only be used on a node that hasn't been added to any list.\n\n @param node A pointer to the node to set the flags on\n @param flags A value between 0 and 3 to set the flags value"]
    #[link_name = "sys_sfnode_init__extern"]
    pub fn sys_sfnode_init(node: *mut sys_sfnode_t, flags: u8);
}
extern "C" {
    #[doc = " @brief Set flags value for an sflist node\n\n Set a flags value for this slist node, which can be a value between\n 0 and 3. These flags will persist even if the node is moved around\n within a list, removed, or transplanted to a different slist.\n\n @param node A pointer to the node to set the flags on\n @param flags A value between 0 and 3 to set the flags value"]
    #[link_name = "sys_sfnode_flags_set__extern"]
    pub fn sys_sfnode_flags_set(node: *mut sys_sfnode_t, flags: u8);
}
extern "C" {
    #[doc = " @brief Test if the given list is empty\n\n @param list A pointer on the list to test\n\n @return a boolean, true if it's empty, false otherwise"]
    #[link_name = "sys_sflist_is_empty__extern"]
    pub fn sys_sflist_is_empty(list: *mut sys_sflist_t) -> bool;
}
extern "C" {
    #[doc = " @brief Peek the next node from current node, node is not NULL\n\n Faster then sys_sflist_peek_next() if node is known not to be NULL.\n\n @param node A pointer on the node where to peek the next node\n\n @return a pointer on the next node (or NULL if none)"]
    #[link_name = "sys_sflist_peek_next_no_check__extern"]
    pub fn sys_sflist_peek_next_no_check(node: *mut sys_sfnode_t) -> *mut sys_sfnode_t;
}
extern "C" {
    #[doc = " @brief Peek the next node from current node\n\n @param node A pointer on the node where to peek the next node\n\n @return a pointer on the next node (or NULL if none)"]
    #[link_name = "sys_sflist_peek_next__extern"]
    pub fn sys_sflist_peek_next(node: *mut sys_sfnode_t) -> *mut sys_sfnode_t;
}
extern "C" {
    #[doc = " @brief Prepend a node to the given list\n\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param node A pointer on the node to prepend"]
    #[link_name = "sys_sflist_prepend__extern"]
    pub fn sys_sflist_prepend(list: *mut sys_sflist_t, node: *mut sys_sfnode_t);
}
extern "C" {
    #[doc = " @brief Append a node to the given list\n\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param node A pointer on the node to append"]
    #[link_name = "sys_sflist_append__extern"]
    pub fn sys_sflist_append(list: *mut sys_sflist_t, node: *mut sys_sfnode_t);
}
extern "C" {
    #[doc = " @brief Append a list to the given list\n\n Append a singly-linked, NULL-terminated list consisting of nodes containing\n the pointer to the next node as the first element of a node, to @a list.\n This and other sys_sflist_*() functions are not thread safe.\n\n FIXME: Why are the element parameters void *?\n\n @param list A pointer on the list to affect\n @param head A pointer to the first element of the list to append\n @param tail A pointer to the last element of the list to append"]
    #[link_name = "sys_sflist_append_list__extern"]
    pub fn sys_sflist_append_list(
        list: *mut sys_sflist_t,
        head: *mut cty::c_void,
        tail: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief merge two sflists, appending the second one to the first\n\n When the operation is completed, the appending list is empty.\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param list_to_append A pointer to the list to append."]
    #[link_name = "sys_sflist_merge_sflist__extern"]
    pub fn sys_sflist_merge_sflist(list: *mut sys_sflist_t, list_to_append: *mut sys_sflist_t);
}
extern "C" {
    #[doc = " @brief Insert a node to the given list\n\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param prev A pointer on the previous node\n @param node A pointer on the node to insert"]
    #[link_name = "sys_sflist_insert__extern"]
    pub fn sys_sflist_insert(
        list: *mut sys_sflist_t,
        prev: *mut sys_sfnode_t,
        node: *mut sys_sfnode_t,
    );
}
extern "C" {
    #[doc = " @brief Fetch and remove the first node of the given list\n\n List must be known to be non-empty.\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n\n @return A pointer to the first node of the list"]
    #[link_name = "sys_sflist_get_not_empty__extern"]
    pub fn sys_sflist_get_not_empty(list: *mut sys_sflist_t) -> *mut sys_sfnode_t;
}
extern "C" {
    #[doc = " @brief Fetch and remove the first node of the given list\n\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n\n @return A pointer to the first node of the list (or NULL if empty)"]
    #[link_name = "sys_sflist_get__extern"]
    pub fn sys_sflist_get(list: *mut sys_sflist_t) -> *mut sys_sfnode_t;
}
extern "C" {
    #[doc = " @brief Remove a node\n\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param prev_node A pointer on the previous node\n        (can be NULL, which means the node is the list's head)\n @param node A pointer on the node to remove"]
    #[link_name = "sys_sflist_remove__extern"]
    pub fn sys_sflist_remove(
        list: *mut sys_sflist_t,
        prev_node: *mut sys_sfnode_t,
        node: *mut sys_sfnode_t,
    );
}
extern "C" {
    #[doc = " @brief Find and remove a node from a list\n\n This and other sys_sflist_*() functions are not thread safe.\n\n @param list A pointer on the list to affect\n @param node A pointer on the node to remove from the list\n\n @return true if node was removed"]
    #[link_name = "sys_sflist_find_and_remove__extern"]
    pub fn sys_sflist_find_and_remove(list: *mut sys_sflist_t, node: *mut sys_sfnode_t) -> bool;
}
extern "C" {
    #[doc = " @brief Compute the size of the given list in O(n) time\n\n @param list A pointer on the list\n\n @return an integer equal to the size of the list, or 0 if empty"]
    #[link_name = "sys_sflist_len__extern"]
    pub fn sys_sflist_len(list: *mut sys_sflist_t) -> usize;
}
extern "C" {
    #[doc = " Tools may use this list as an entry point to identify all registered\n object types and the object cores linked to them."]
    pub static mut z_obj_type_list: sys_slist_t;
}
#[doc = " Object core statistics descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_obj_core_stats_desc {
    #[doc = "< Internal representation stats buffer size"]
    pub raw_size: usize,
    #[doc = "< Stats buffer size used for reporting"]
    pub query_size: usize,
    #[doc = " Function pointer to retrieve internal representation of stats"]
    pub raw: ::core::option::Option<
        unsafe extern "C" fn(obj_core: *mut k_obj_core, stats: *mut cty::c_void) -> cty::c_int,
    >,
    #[doc = " Function pointer to retrieve reported statistics"]
    pub query: ::core::option::Option<
        unsafe extern "C" fn(obj_core: *mut k_obj_core, stats: *mut cty::c_void) -> cty::c_int,
    >,
    #[doc = " Function pointer to reset object's statistics"]
    pub reset:
        ::core::option::Option<unsafe extern "C" fn(obj_core: *mut k_obj_core) -> cty::c_int>,
    #[doc = " Function pointer to disable object's statistics gathering"]
    pub disable:
        ::core::option::Option<unsafe extern "C" fn(obj_core: *mut k_obj_core) -> cty::c_int>,
    #[doc = " Function pointer to enable object's statistics gathering"]
    pub enable:
        ::core::option::Option<unsafe extern "C" fn(obj_core: *mut k_obj_core) -> cty::c_int>,
}
#[test]
fn bindgen_test_layout_k_obj_core_stats_desc() {
    const UNINIT: ::core::mem::MaybeUninit<k_obj_core_stats_desc> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_obj_core_stats_desc>(),
        56usize,
        concat!("Size of: ", stringify!(k_obj_core_stats_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<k_obj_core_stats_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(k_obj_core_stats_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core_stats_desc),
            "::",
            stringify!(raw_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).query_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core_stats_desc),
            "::",
            stringify!(query_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core_stats_desc),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).query) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core_stats_desc),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core_stats_desc),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core_stats_desc),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core_stats_desc),
            "::",
            stringify!(enable)
        )
    );
}
#[doc = " Object type structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_obj_type {
    #[doc = "< Node within list of object types"]
    pub node: sys_snode_t,
    #[doc = "< List of objects of this object type"]
    pub list: sys_slist_t,
    #[doc = "< Unique type ID"]
    pub id: u32,
    #[doc = "< Offset to obj_core field"]
    pub obj_core_offset: usize,
}
#[test]
fn bindgen_test_layout_k_obj_type() {
    const UNINIT: ::core::mem::MaybeUninit<k_obj_type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_obj_type>(),
        40usize,
        concat!("Size of: ", stringify!(k_obj_type))
    );
    assert_eq!(
        ::core::mem::align_of::<k_obj_type>(),
        8usize,
        concat!("Alignment of ", stringify!(k_obj_type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_type),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_type),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_type),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obj_core_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_type),
            "::",
            stringify!(obj_core_offset)
        )
    );
}
#[doc = " Object core structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_obj_core {
    #[doc = "< Object node within object type's list"]
    pub node: sys_snode_t,
    #[doc = "< Object type to which object belongs"]
    pub type_: *mut k_obj_type,
}
#[test]
fn bindgen_test_layout_k_obj_core() {
    const UNINIT: ::core::mem::MaybeUninit<k_obj_core> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_obj_core>(),
        16usize,
        concat!("Size of: ", stringify!(k_obj_core))
    );
    assert_eq!(
        ::core::mem::align_of::<k_obj_core>(),
        8usize,
        concat!("Alignment of ", stringify!(k_obj_core))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_obj_core),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a specific object type\n\n Initializes a specific object type and links it into the object core\n framework.\n\n @param type Pointer to the object type to initialize\n @param id A means to identify the object type\n @param off Offset of object core within the structure\n\n @retval Pointer to initialized object type"]
    pub fn z_obj_type_init(type_: *mut k_obj_type, id: u32, off: usize) -> *mut k_obj_type;
}
extern "C" {
    #[doc = " @brief Find a specific object type by ID\n\n Given an object type ID, this function searches for the object type that\n is associated with the specified type ID @a type_id.\n\n @param type_id  Type ID associated with object type\n\n @retval NULL if object type not found\n @retval Pointer to object type if found"]
    pub fn k_obj_type_find(type_id: u32) -> *mut k_obj_type;
}
extern "C" {
    #[doc = " @brief Walk the object type's list of object cores\n\n This function takes a global spinlock and walks the object type's list\n of object cores and invokes the callback function on each element while\n holding that lock. Although this will ensure that the list is not modified,\n one can expect a significant penalty in terms of performance and latency.\n\n The callback function shall either return non-zero to stop further walking,\n or it shall return 0 to continue walking.\n\n @param type  Pointer to the object type\n @param func  Callback to invoke on each object core of the object type\n @param data  Custom data passed to the callback\n\n @retval non-zero if walk is terminated by the callback; otherwise 0"]
    pub fn k_obj_type_walk_locked(
        type_: *mut k_obj_type,
        func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut k_obj_core, arg2: *mut cty::c_void) -> cty::c_int,
        >,
        data: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Walk the object type's list of object cores\n\n This function is similar to k_obj_type_walk_locked() except that it walks\n the list without obtaining the global spinlock. No synchronization is\n provided here. Mutation of the list of objects while this function is in\n progress must be prevented at the application layer, otherwise\n undefined/unreliable behavior, corruption and/or crashes may result.\n\n The callback function shall either return non-zero to stop further walking,\n or it shall return 0 to continue walking.\n\n @param type  Pointer to the object type\n @param func  Callback to invoke on each object core of the object type\n @param data  Custom data passed to the callback\n\n @retval non-zero if walk is terminated by the callback; otherwise 0"]
    pub fn k_obj_type_walk_unlocked(
        type_: *mut k_obj_type,
        func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut k_obj_core, arg2: *mut cty::c_void) -> cty::c_int,
        >,
        data: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Initialize the core of the kernel object\n\n Initializing the kernel object core associates it with the specified\n kernel object type.\n\n @param obj_core Pointer to the kernel object to initialize\n @param type Pointer to the kernel object type"]
    pub fn k_obj_core_init(obj_core: *mut k_obj_core, type_: *mut k_obj_type);
}
extern "C" {
    #[doc = " @brief Link the kernel object to the kernel object type list\n\n A kernel object can be optionally linked into the kernel object type's\n list of objects. A kernel object must have been initialized before it\n can be linked. Linked kernel objects can be traversed and have information\n extracted from them by system tools.\n\n @param obj_core Pointer to the kernel object"]
    pub fn k_obj_core_link(obj_core: *mut k_obj_core);
}
extern "C" {
    #[doc = " @brief Automatically link the kernel object after initializing it\n\n A useful wrapper to both initialize the core of the kernel object and\n automatically link it into the kernel object type's list of objects.\n\n @param obj_core Pointer to the kernel object to initialize\n @param type Pointer to the kernel object type"]
    pub fn k_obj_core_init_and_link(obj_core: *mut k_obj_core, type_: *mut k_obj_type);
}
extern "C" {
    #[doc = " @brief Unlink the kernel object from the kernel object type list\n\n Kernel objects can be unlinked from their respective kernel object type\n lists. If on a list, it must be done at the end of the kernel object's life\n cycle.\n\n @param obj_core Pointer to the kernel object"]
    pub fn k_obj_core_unlink(obj_core: *mut k_obj_core);
}
extern "C" {
    #[doc = " @brief Register kernel object for gathering statistics\n\n Before a kernel object can gather statistics, it must be registered to do\n so. Registering will also automatically enable the kernel object to gather\n its statistics.\n\n @param obj_core Pointer to kernel object core\n @param stats Pointer to raw kernel statistics\n @param stats_len Size of raw kernel statistics buffer\n\n @retval 0 on success\n @retval -errno on failure"]
    pub fn k_obj_core_stats_register(
        obj_core: *mut k_obj_core,
        stats: *mut cty::c_void,
        stats_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Deregister kernel object from gathering statistics\n\n Deregistering a kernel object core from gathering statistics prevents it\n from gathering any more statistics. It is expected to be invoked at the end\n of a kernel object's life cycle.\n\n @param obj_core Pointer to kernel object core\n\n @retval 0 on success\n @retval -errno on failure"]
    pub fn k_obj_core_stats_deregister(obj_core: *mut k_obj_core) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the raw statistics associated with the kernel object\n\n This function copies the raw statistics associated with the kernel object\n core specified by @a obj_core into the buffer @a stats. Note that the size\n of the buffer (@a stats_len) must match the size specified by the kernel\n object type's statistics descriptor.\n\n @param obj_core Pointer to kernel object core\n @param stats Pointer to memory buffer into which to copy raw stats\n @param stats_len Length of the memory buffer\n\n @retval 0 on success\n @retval -errno on failure"]
    pub fn k_obj_core_stats_raw(
        obj_core: *mut k_obj_core,
        stats: *mut cty::c_void,
        stats_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the statistics associated with the kernel object\n\n This function copies the statistics associated with the kernel object core\n specified by @a obj_core into the buffer @a stats. Unlike the raw statistics\n this may report calculated values such as averages.  Note that the size of\n the buffer (@a stats_len) must match the size specified by the kernel object\n type's statistics descriptor.\n\n @param obj_core Pointer to kernel object core\n @param stats Pointer to memory buffer into which to copy the queried stats\n @param stats_len Length of the memory buffer\n\n @retval 0 on success\n @retval -errno on failure"]
    pub fn k_obj_core_stats_query(
        obj_core: *mut k_obj_core,
        stats: *mut cty::c_void,
        stats_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Reset the stats associated with the kernel object\n\n This function resets the statistics associated with the kernel object core\n specified by @a obj_core.\n\n @param obj_core Pointer to kernel object core\n\n @retval 0 on success\n @retval -errno on failure"]
    pub fn k_obj_core_stats_reset(obj_core: *mut k_obj_core) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Stop gathering the stats associated with the kernel object\n\n This function temporarily stops the gathering of statistics associated with\n the kernel object core specified by @a obj_core. The gathering of statistics\n can be resumed by invoking :c:func :`k_obj_core_stats_enable`.\n\n @param obj_core Pointer to kernel object core\n\n @retval 0 on success\n @retval -errno on failure"]
    pub fn k_obj_core_stats_disable(obj_core: *mut k_obj_core) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Reset the stats associated with the kernel object\n\n This function resumes the gathering of statistics associated with the kernel\n object core specified by @a obj_core.\n\n @param obj_core Pointer to kernel object core\n\n @retval 0 on success\n @retval -errno on failure"]
    pub fn k_obj_core_stats_enable(obj_core: *mut k_obj_core) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_memory_stats {
    pub free_bytes: usize,
    pub allocated_bytes: usize,
    pub max_allocated_bytes: usize,
}
#[test]
fn bindgen_test_layout_sys_memory_stats() {
    const UNINIT: ::core::mem::MaybeUninit<sys_memory_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sys_memory_stats>(),
        24usize,
        concat!("Size of: ", stringify!(sys_memory_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<sys_memory_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(sys_memory_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_memory_stats),
            "::",
            stringify!(free_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocated_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_memory_stats),
            "::",
            stringify!(allocated_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_allocated_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_memory_stats),
            "::",
            stringify!(max_allocated_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_heap {
    pub heap: *mut z_heap,
    pub init_mem: *mut cty::c_void,
    pub init_bytes: usize,
}
#[test]
fn bindgen_test_layout_sys_heap() {
    const UNINIT: ::core::mem::MaybeUninit<sys_heap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sys_heap>(),
        24usize,
        concat!("Size of: ", stringify!(sys_heap))
    );
    assert_eq!(
        ::core::mem::align_of::<sys_heap>(),
        8usize,
        concat!("Alignment of ", stringify!(sys_heap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_heap),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_mem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_heap),
            "::",
            stringify!(init_mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_heap),
            "::",
            stringify!(init_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_heap_stress_result {
    pub total_allocs: u32,
    pub successful_allocs: u32,
    pub total_frees: u32,
    pub accumulated_in_use_bytes: u64,
}
#[test]
fn bindgen_test_layout_z_heap_stress_result() {
    const UNINIT: ::core::mem::MaybeUninit<z_heap_stress_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_heap_stress_result>(),
        24usize,
        concat!("Size of: ", stringify!(z_heap_stress_result))
    );
    assert_eq!(
        ::core::mem::align_of::<z_heap_stress_result>(),
        8usize,
        concat!("Alignment of ", stringify!(z_heap_stress_result))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_allocs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_heap_stress_result),
            "::",
            stringify!(total_allocs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).successful_allocs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(z_heap_stress_result),
            "::",
            stringify!(successful_allocs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_frees) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(z_heap_stress_result),
            "::",
            stringify!(total_frees)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accumulated_in_use_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(z_heap_stress_result),
            "::",
            stringify!(accumulated_in_use_bytes)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize sys_heap\n\n Initializes a sys_heap struct to manage the specified memory.\n\n @param heap Heap to initialize\n @param mem Untyped pointer to unused memory\n @param bytes Size of region pointed to by @a mem"]
    pub fn sys_heap_init(heap: *mut sys_heap, mem: *mut cty::c_void, bytes: usize);
}
extern "C" {
    #[doc = " @brief Allocate memory from a sys_heap\n\n Returns a pointer to a block of unused memory in the heap.  This\n memory will not otherwise be used until it is freed with\n sys_heap_free().  If no memory can be allocated, NULL will be\n returned.  The allocated memory is guaranteed to have a starting\n address which is a multiple of sizeof(void *).  If a bigger alignment\n is necessary then sys_heap_aligned_alloc() should be used instead.\n\n @note The sys_heap implementation is not internally synchronized.\n No two sys_heap functions should operate on the same heap at the\n same time.  All locking must be provided by the user.\n\n @param heap Heap from which to allocate\n @param bytes Number of bytes requested\n @return Pointer to memory the caller can now use"]
    pub fn sys_heap_alloc(heap: *mut sys_heap, bytes: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Allocate aligned memory from a sys_heap\n\n Behaves in all ways like sys_heap_alloc(), except that the returned\n memory (if available) will have a starting address in memory which\n is a multiple of the specified power-of-two alignment value in\n bytes.  With align=0 this behaves exactly like sys_heap_alloc().\n The resulting memory can be returned to the heap using sys_heap_free().\n\n @param heap Heap from which to allocate\n @param align Alignment in bytes, must be a power of two\n @param bytes Number of bytes requested\n @return Pointer to memory the caller can now use"]
    pub fn sys_heap_aligned_alloc(
        heap: *mut sys_heap,
        align: usize,
        bytes: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Free memory into a sys_heap\n\n De-allocates a pointer to memory previously returned from\n sys_heap_alloc such that it can be used for other purposes.  The\n caller must not use the memory region after entry to this function.\n\n @note The sys_heap implementation is not internally synchronized.\n No two sys_heap functions should operate on the same heap at the\n same time.  All locking must be provided by the user.\n\n @param heap Heap to which to return the memory\n @param mem A pointer previously returned from sys_heap_alloc()"]
    pub fn sys_heap_free(heap: *mut sys_heap, mem: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Expand the size of an existing allocation\n\n Returns a pointer to a new memory region with the same contents,\n but a different allocated size.  If the new allocation can be\n expanded in place, the pointer returned will be identical.\n Otherwise the data will be copies to a new block and the old one\n will be freed as per sys_heap_free().  If the specified size is\n smaller than the original, the block will be truncated in place and\n the remaining memory returned to the heap.  If the allocation of a\n new block fails, then NULL will be returned and the old block will\n not be freed or modified.\n\n @note The return of a NULL on failure is a different behavior than\n POSIX realloc(), which specifies that the original pointer will be\n returned (i.e. it is not possible to safely detect realloc()\n failure in POSIX, but it is here).\n\n @param heap Heap from which to allocate\n @param ptr Original pointer returned from a previous allocation\n @param align Alignment in bytes, must be a power of two\n @param bytes Number of bytes requested for the new block\n @return Pointer to memory the caller can now use, or NULL"]
    pub fn sys_heap_aligned_realloc(
        heap: *mut sys_heap,
        ptr: *mut cty::c_void,
        align: usize,
        bytes: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Return allocated memory size\n\n Returns the size, in bytes, of a block returned from a successful\n sys_heap_alloc() or sys_heap_alloc_aligned() call.  The value\n returned is the size of the heap-managed memory, which may be\n larger than the number of bytes requested due to allocation\n granularity.  The heap code is guaranteed to make no access to this\n region of memory until a subsequent sys_heap_free() on the same\n pointer.\n\n @param heap Heap containing the block\n @param mem Pointer to memory allocated from this heap\n @return Size in bytes of the memory region"]
    pub fn sys_heap_usable_size(heap: *mut sys_heap, mem: *mut cty::c_void) -> usize;
}
extern "C" {
    #[doc = " @brief Validate heap integrity\n\n Validates the internal integrity of a sys_heap.  Intended for unit\n test and validation code, though potentially useful as a user API\n for applications with complicated runtime reliability requirements.\n Note: this cannot catch every possible error, but if it returns\n true then the heap is in a consistent state and can correctly\n handle any sys_heap_alloc() request and free any live pointer\n returned from a previous allocation.\n\n @param heap Heap to validate\n @return true, if the heap is valid, otherwise false"]
    pub fn sys_heap_validate(heap: *mut sys_heap) -> bool;
}
extern "C" {
    #[doc = " @brief sys_heap stress test rig\n\n Test rig for heap allocation validation.  This will loop for @a\n op_count cycles, in each iteration making a random choice to\n allocate or free a pointer of randomized (power law) size based on\n heuristics designed to keep the heap in a state where it is near @a\n target_percent full.  Allocation and free operations are provided\n by the caller as callbacks (i.e. this can in theory test any heap).\n Results, including counts of frees and successful/unsuccessful\n allocations, are returned via the @a result struct.\n\n @param alloc_fn Callback to perform an allocation.  Passes back the @a\n              arg parameter as a context handle.\n @param free_fn Callback to perform a free of a pointer returned from\n             @a alloc.  Passes back the @a arg parameter as a\n             context handle.\n @param arg Context handle to pass back to the callbacks\n @param total_bytes Size of the byte array the heap was initialized in\n @param op_count How many iterations to test\n @param scratch_mem A pointer to scratch memory to be used by the\n                    test.  Should be about 1/2 the size of the heap\n                    for tests that need to stress fragmentation.\n @param scratch_bytes Size of the memory pointed to by @a scratch_mem\n @param target_percent Percentage fill value (1-100) to which the\n                       random allocation choices will seek.  High\n                       values will result in significant allocation\n                       failures and a very fragmented heap.\n @param result Struct into which to store test results."]
    pub fn sys_heap_stress(
        alloc_fn: ::core::option::Option<
            unsafe extern "C" fn(arg: *mut cty::c_void, bytes: usize) -> *mut cty::c_void,
        >,
        free_fn: ::core::option::Option<
            unsafe extern "C" fn(arg: *mut cty::c_void, p: *mut cty::c_void),
        >,
        arg: *mut cty::c_void,
        total_bytes: usize,
        op_count: u32,
        scratch_mem: *mut cty::c_void,
        scratch_bytes: usize,
        target_percent: cty::c_int,
        result: *mut z_heap_stress_result,
    );
}
extern "C" {
    #[doc = " @brief Print heap internal structure information to the console\n\n Print information on the heap structure such as its size, chunk buckets,\n chunk list and some statistics for debugging purpose.\n\n @param heap Heap to print information about\n @param dump_chunks True to print the entire heap chunk list"]
    pub fn sys_heap_print_info(heap: *mut sys_heap, dump_chunks: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cpu_arch {
    is_empty: bool
}
#[test]
fn bindgen_test_layout__cpu_arch() {
    assert_eq!(
        ::core::mem::size_of::<_cpu_arch>(),
        0usize,
        concat!("Size of: ", stringify!(_cpu_arch))
    );
    assert_eq!(
        ::core::mem::align_of::<_cpu_arch>(),
        1usize,
        concat!("Alignment of ", stringify!(_cpu_arch))
    );
}
pub type _cpu_arch_t = _cpu_arch;
#[doc = " Structure used to track internal statistics about both thread\n and CPU usage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_cycle_stats {
    #[doc = "< total usage in cycles"]
    pub total: u64,
    #[doc = "< true if gathering usage stats"]
    pub track_usage: bool,
}
#[test]
fn bindgen_test_layout_k_cycle_stats() {
    const UNINIT: ::core::mem::MaybeUninit<k_cycle_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_cycle_stats>(),
        16usize,
        concat!("Size of: ", stringify!(k_cycle_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<k_cycle_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(k_cycle_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_cycle_stats),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).track_usage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_cycle_stats),
            "::",
            stringify!(track_usage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ready_q {
    pub cache: *mut k_thread,
}
#[test]
fn bindgen_test_layout__ready_q() {
    const UNINIT: ::core::mem::MaybeUninit<_ready_q> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ready_q>(),
        8usize,
        concat!("Size of: ", stringify!(_ready_q))
    );
    assert_eq!(
        ::core::mem::align_of::<_ready_q>(),
        8usize,
        concat!("Alignment of ", stringify!(_ready_q))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ready_q),
            "::",
            stringify!(cache)
        )
    );
}
pub type _ready_q_t = _ready_q;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cpu {
    pub nested: u32,
    pub irq_stack: *mut cty::c_char,
    pub current: *mut k_thread,
    pub idle_thread: *mut k_thread,
    pub id: u8,
    pub arch: _cpu_arch,
}
#[test]
fn bindgen_test_layout__cpu() {
    const UNINIT: ::core::mem::MaybeUninit<_cpu> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cpu>(),
        40usize,
        concat!("Size of: ", stringify!(_cpu))
    );
    assert_eq!(
        ::core::mem::align_of::<_cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(_cpu))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nested) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cpu),
            "::",
            stringify!(nested)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).irq_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cpu),
            "::",
            stringify!(irq_stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cpu),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idle_thread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cpu),
            "::",
            stringify!(idle_thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_cpu), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arch) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_cpu),
            "::",
            stringify!(arch)
        )
    );
}
pub type _cpu_t = _cpu;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_kernel {
    pub cpus: [_cpu; 1usize],
    pub ready_q: _ready_q,
}
#[test]
fn bindgen_test_layout_z_kernel() {
    const UNINIT: ::core::mem::MaybeUninit<z_kernel> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_kernel>(),
        48usize,
        concat!("Size of: ", stringify!(z_kernel))
    );
    assert_eq!(
        ::core::mem::align_of::<z_kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(z_kernel))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_kernel),
            "::",
            stringify!(cpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ready_q) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(z_kernel),
            "::",
            stringify!(ready_q)
        )
    );
}
pub type _kernel_t = z_kernel;
extern "C" {
    pub static mut _kernel: z_kernel;
}
extern "C" {
    pub static mut _cpus_active: atomic_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wait_q_t {
    pub waitq: sys_dlist_t,
}
#[test]
fn bindgen_test_layout__wait_q_t() {
    const UNINIT: ::core::mem::MaybeUninit<_wait_q_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_wait_q_t>(),
        16usize,
        concat!("Size of: ", stringify!(_wait_q_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_wait_q_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wait_q_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waitq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wait_q_t),
            "::",
            stringify!(waitq)
        )
    );
}
pub type _timeout_func_t = ::core::option::Option<unsafe extern "C" fn(t: *mut _timeout)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _timeout {
    pub node: sys_dnode_t,
    pub fn_: _timeout_func_t,
    pub dticks: i32,
}
#[test]
fn bindgen_test_layout__timeout() {
    const UNINIT: ::core::mem::MaybeUninit<_timeout> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_timeout>(),
        32usize,
        concat!("Size of: ", stringify!(_timeout))
    );
    assert_eq!(
        ::core::mem::align_of::<_timeout>(),
        8usize,
        concat!("Alignment of ", stringify!(_timeout))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_timeout),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_timeout),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dticks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_timeout),
            "::",
            stringify!(dticks)
        )
    );
}
pub type k_thread_timeslice_fn_t =
    ::core::option::Option<unsafe extern "C" fn(thread: *mut k_thread, data: *mut cty::c_void)>;
extern "C" {
    #[doc = " @brief Return the kernel version of the present build\n\n The kernel version is a four-byte value, whose format is described in the\n file \"kernel_version.h\".\n\n @return kernel version"]
    pub fn sys_kernel_version_get() -> u32;
}
#[doc = " @typedef _k_syscall_handler_t\n @brief System call handler function type\n\n These are kernel-side skeleton functions for system calls. They are\n necessary to sanitize the arguments passed into the system call:\n\n - Any kernel object or device pointers are validated with _SYSCALL_IS_OBJ()\n - Any memory buffers passed in are checked to ensure that the calling thread\n   actually has access to them\n - Many kernel calls do no sanity checking of parameters other than\n   assertions. The handler must check all of these conditions using\n   _SYSCALL_ASSERT()\n - If the system call has more than 6 arguments, then arg6 will be a pointer\n   to some struct containing arguments 6+. The struct itself needs to be\n   validated like any other buffer passed in from userspace, and its members\n   individually validated (if necessary) and then passed to the real\n   implementation like normal arguments\n\n Even if the system call implementation has no return value, these always\n return something, even 0, to prevent register leakage to userspace.\n\n Once everything has been validated, the real implementation will be executed.\n\n @param arg1 system call argument 1\n @param arg2 system call argument 2\n @param arg3 system call argument 3\n @param arg4 system call argument 4\n @param arg5 system call argument 5\n @param arg6 system call argument 6\n @param ssf System call stack frame pointer. Used to generate kernel oops\n            via _arch_syscall_oops_at(). Contents are arch-specific.\n @return system call return value, or 0 if the system call implementation\n         return void\n"]
pub type _k_syscall_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        ssf: *mut cty::c_void,
    ) -> usize,
>;
extern "C" {
    #[link_name = "z_syscall_trap__extern"]
    pub fn z_syscall_trap() -> bool;
}
extern "C" {
    #[doc = " Indicate whether the CPU is currently in user mode\n\n @return true if the CPU is currently running with user permissions"]
    #[link_name = "k_is_user_context__extern"]
    pub fn k_is_user_context() -> bool;
}
pub type __gwchar_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    #[link_name = "vprintk__extern"]
    pub fn vprintk(fmt: *const cty::c_char, ap: *mut __va_list_tag);
}
extern "C" {
    pub fn snprintk(
        str_: *mut cty::c_char,
        size: usize,
        fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintk(
        str_: *mut cty::c_char,
        size: usize,
        fmt: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
pub type irq_offload_routine_t =
    ::core::option::Option<unsafe extern "C" fn(parameter: *const cty::c_void)>;
extern "C" {
    #[doc = " @brief Run a function in interrupt context\n\n This function synchronously runs the provided function in interrupt\n context, passing in the supplied device. Useful for test code\n which needs to show that kernel objects work correctly in interrupt\n context.\n\n Additionally, when CONFIG_IRQ_OFFLOAD_NESTED is set by the\n architecture, this routine works to synchronously invoke a nested\n interrupt when called from an ISR context (i.e. when k_is_in_isr()\n is true).  Note that not all platforms will have hardware support\n for this capability, and even on those some interrupts may be\n running at unpreemptible priorities.\n\n @param routine The function to run\n @param parameter Argument to pass to the function when it is run as an\n interrupt"]
    pub fn irq_offload(routine: irq_offload_routine_t, parameter: *const cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mem_domain {
    _unused: [u8; 0],
}
pub type k_thread_stack_t = z_thread_stack_element;
pub type k_thread_entry_t = ::core::option::Option<
    unsafe extern "C" fn(p1: *mut cty::c_void, p2: *mut cty::c_void, p3: *mut cty::c_void),
>;
extern "C" {
    #[doc = " Obtain the current cycle count, in units specified by\n CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC.  While this is historically\n specified as part of the architecture API, in practice virtually\n all platforms forward it to the sys_clock_cycle_get_32() API\n provided by the timer driver.\n\n @see k_cycle_get_32()\n\n @return The current cycle time.  This should count up monotonically\n through the full 32 bit space, wrapping at 0xffffffff.  Hardware\n with fewer bits of precision in the timer is expected to synthesize\n a 32 bit count."]
    #[link_name = "arch_k_cycle_get_32__extern"]
    pub fn arch_k_cycle_get_32() -> u32;
}
extern "C" {
    #[doc = " As for arch_k_cycle_get_32(), but with a 64 bit return value.  Not\n all timer hardware has a 64 bit timer, this needs to be implemented\n only if CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER is set.\n\n @see arch_k_cycle_get_32()\n\n @return The current cycle time.  This should count up monotonically\n through the full 64 bit space, wrapping at 2^64-1.  Hardware with\n fewer bits of precision in the timer is generally not expected to\n implement this API."]
    #[link_name = "arch_k_cycle_get_64__extern"]
    pub fn arch_k_cycle_get_64() -> u64;
}
extern "C" {
    #[doc = " @brief Power save idle routine\n\n This function will be called by the kernel idle loop or possibly within\n an implementation of z_pm_save_idle in the kernel when the\n '_pm_save_flag' variable is non-zero.\n\n Architectures that do not implement power management instructions may\n immediately return, otherwise a power-saving instruction should be\n issued to wait for an interrupt.\n\n @note The function is expected to return after the interrupt that has\n caused the CPU to exit power-saving mode has been serviced, although\n this is not a firm requirement.\n\n @see k_cpu_idle()"]
    pub fn arch_cpu_idle();
}
extern "C" {
    #[doc = " @brief Atomically re-enable interrupts and enter low power mode\n\n The requirements for arch_cpu_atomic_idle() are as follows:\n\n -# Enabling interrupts and entering a low-power mode needs to be\n    atomic, i.e. there should be no period of time where interrupts are\n    enabled before the processor enters a low-power mode.  See the comments\n    in k_lifo_get(), for example, of the race condition that\n    occurs if this requirement is not met.\n\n -# After waking up from the low-power mode, the interrupt lockout state\n    must be restored as indicated in the 'key' input parameter.\n\n @see k_cpu_atomic_idle()\n\n @param key Lockout key returned by previous invocation of arch_irq_lock()"]
    pub fn arch_cpu_atomic_idle(key: cty::c_uint);
}
#[doc = " Per-cpu entry function\n\n @param data context parameter, implementation specific"]
pub type arch_cpustart_t =
    ::core::option::Option<unsafe extern "C" fn(data: *mut cty::c_void) -> !>;
extern "C" {
    #[doc = " @brief Start a numbered CPU on a MP-capable system\n\n This starts and initializes a specific CPU.  The main thread on startup is\n running on CPU zero, other processors are numbered sequentially.  On return\n from this function, the CPU is known to have begun operating and will enter\n the provided function.  Its interrupts will be initialized but disabled such\n that irq_unlock() with the provided key will work to enable them.\n\n Normally, in SMP mode this function will be called by the kernel\n initialization and should not be used as a user API.  But it is defined here\n for special-purpose apps which want Zephyr running on one core and to use\n others for design-specific processing.\n\n @param cpu_num Integer number of the CPU\n @param stack Stack memory for the CPU\n @param sz Stack buffer size, in bytes\n @param fn Function to begin running on the CPU.\n @param arg Untyped argument to be passed to \"fn\""]
    pub fn arch_start_cpu(
        cpu_num: cty::c_int,
        stack: *mut k_thread_stack_t,
        sz: cty::c_int,
        fn_: arch_cpustart_t,
        arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief Return CPU power status\n\n @param cpu_num Integer number of the CPU"]
    pub fn arch_cpu_active(cpu_num: cty::c_int) -> bool;
}
extern "C" {
    #[doc = " Lock interrupts on the current CPU\n\n @see irq_lock()"]
    #[link_name = "arch_irq_lock__extern"]
    pub fn arch_irq_lock() -> cty::c_uint;
}
extern "C" {
    #[doc = " Unlock interrupts on the current CPU\n\n @see irq_unlock()"]
    #[link_name = "arch_irq_unlock__extern"]
    pub fn arch_irq_unlock(key: cty::c_uint);
}
extern "C" {
    #[doc = " Test if calling arch_irq_unlock() with this key would unlock irqs\n\n @param key value returned by arch_irq_lock()\n @return true if interrupts were unlocked prior to the arch_irq_lock()\n call that produced the key argument."]
    #[link_name = "arch_irq_unlocked__extern"]
    pub fn arch_irq_unlocked(key: cty::c_uint) -> bool;
}
extern "C" {
    #[doc = " Disable the specified interrupt line\n\n @note: The behavior of interrupts that arrive after this call\n returns and before the corresponding call to arch_irq_enable() is\n undefined.  The hardware is not required to latch and deliver such\n an interrupt, though on some architectures that may work.  Other\n architectures will simply lose such an interrupt and never deliver\n it.  Many drivers and subsystems are not tolerant of such dropped\n interrupts and it is the job of the application layer to ensure\n that behavior remains correct.\n\n @see irq_disable()"]
    pub fn arch_irq_disable(irq: cty::c_uint);
}
extern "C" {
    #[doc = " Enable the specified interrupt line\n\n @see irq_enable()"]
    pub fn arch_irq_enable(irq: cty::c_uint);
}
extern "C" {
    #[doc = " Test if an interrupt line is enabled\n\n @see irq_is_enabled()"]
    pub fn arch_irq_is_enabled(irq: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Arch-specific hook to install a dynamic interrupt.\n\n @param irq IRQ line number\n @param priority Interrupt priority\n @param routine Interrupt service routine\n @param parameter ISR parameter\n @param flags Arch-specific IRQ configuration flag\n\n @return The vector assigned to this interrupt"]
    pub fn arch_irq_connect_dynamic(
        irq: cty::c_uint,
        priority: cty::c_uint,
        routine: ::core::option::Option<unsafe extern "C" fn(parameter: *const cty::c_void)>,
        parameter: *const cty::c_void,
        flags: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Arch-specific hook to dynamically uninstall a shared interrupt.\n If the interrupt is not being shared, then the associated\n _sw_isr_table entry will be replaced by (NULL, z_irq_spurious)\n (default entry).\n\n @param irq IRQ line number\n @param priority Interrupt priority\n @param routine Interrupt service routine\n @param parameter ISR parameter\n @param flags Arch-specific IRQ configuration flag\n\n @return 0 in case of success, negative value otherwise"]
    pub fn arch_irq_disconnect_dynamic(
        irq: cty::c_uint,
        priority: cty::c_uint,
        routine: ::core::option::Option<unsafe extern "C" fn(parameter: *const cty::c_void)>,
        parameter: *const cty::c_void,
        flags: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Arch-specific hook for allocating IRQs\n\n Note: disable/enable IRQ relevantly inside the implementation of such\n function to avoid concurrency issues. Also, an allocated IRQ is assumed\n to be used thus a following @see arch_irq_is_used() should return true.\n\n @return The newly allocated IRQ or UINT_MAX on error."]
    pub fn arch_irq_allocate() -> cty::c_uint;
}
extern "C" {
    #[doc = " @brief Arch-specific hook for declaring an IRQ being used\n\n Note: disable/enable IRQ relevantly inside the implementation of such\n function to avoid concurrency issues.\n\n @param irq the IRQ to declare being used"]
    pub fn arch_irq_set_used(irq: cty::c_uint);
}
extern "C" {
    #[doc = " @brief Arch-specific hook for checking if an IRQ is being used already\n\n @param irq the IRQ to check\n\n @return true if being, false otherwise"]
    pub fn arch_irq_is_used(irq: cty::c_uint) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the number of CPUs\n\n For most systems this will be the same as CONFIG_MP_MAX_NUM_CPUS,\n however some systems may determine this at runtime instead.\n\n @return the number of CPUs"]
    #[link_name = "arch_num_cpus__extern"]
    pub fn arch_num_cpus() -> cty::c_uint;
}
extern "C" {
    #[link_name = "arch_mem_coherent__extern"]
    pub fn arch_mem_coherent(ptr: *mut cty::c_void) -> bool;
}
extern "C" {
    #[link_name = "arch_cohere_stacks__extern"]
    pub fn arch_cohere_stacks(
        old_thread: *mut k_thread,
        old_switch_handle: *mut cty::c_void,
        new_thread: *mut k_thread,
    );
}
extern "C" {
    #[doc = " @brief Perform architecture specific processing within spin loops\n\n This is invoked from busy loops with IRQs disabled such as the contended\n spinlock loop. The default implementation is a weak function that calls\n arch_nop(). Architectures may implement this function to perform extra\n checks or power management tricks if needed."]
    pub fn arch_spin_relax();
}
extern "C" {
    #[link_name = "read_ccsidr_el1__extern"]
    pub fn read_ccsidr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_ccsidr_el1__extern"]
    pub fn write_ccsidr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_ccsidr_el1__extern"]
    pub fn zero_ccsidr_el1();
}
extern "C" {
    #[link_name = "read_clidr_el1__extern"]
    pub fn read_clidr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_clidr_el1__extern"]
    pub fn write_clidr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_clidr_el1__extern"]
    pub fn zero_clidr_el1();
}
extern "C" {
    #[link_name = "read_cntfrq_el0__extern"]
    pub fn read_cntfrq_el0() -> u64;
}
extern "C" {
    #[link_name = "write_cntfrq_el0__extern"]
    pub fn write_cntfrq_el0(val: u64);
}
extern "C" {
    #[link_name = "zero_cntfrq_el0__extern"]
    pub fn zero_cntfrq_el0();
}
extern "C" {
    #[link_name = "read_cnthctl_el2__extern"]
    pub fn read_cnthctl_el2() -> u64;
}
extern "C" {
    #[link_name = "write_cnthctl_el2__extern"]
    pub fn write_cnthctl_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_cnthctl_el2__extern"]
    pub fn zero_cnthctl_el2();
}
extern "C" {
    #[link_name = "read_cnthp_ctl_el2__extern"]
    pub fn read_cnthp_ctl_el2() -> u64;
}
extern "C" {
    #[link_name = "write_cnthp_ctl_el2__extern"]
    pub fn write_cnthp_ctl_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_cnthp_ctl_el2__extern"]
    pub fn zero_cnthp_ctl_el2();
}
extern "C" {
    #[link_name = "read_cnthps_ctl_el2__extern"]
    pub fn read_cnthps_ctl_el2() -> u64;
}
extern "C" {
    #[link_name = "write_cnthps_ctl_el2__extern"]
    pub fn write_cnthps_ctl_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_cnthps_ctl_el2__extern"]
    pub fn zero_cnthps_ctl_el2();
}
extern "C" {
    #[link_name = "read_cntv_ctl_el0__extern"]
    pub fn read_cntv_ctl_el0() -> u64;
}
extern "C" {
    #[link_name = "write_cntv_ctl_el0__extern"]
    pub fn write_cntv_ctl_el0(val: u64);
}
extern "C" {
    #[link_name = "zero_cntv_ctl_el0__extern"]
    pub fn zero_cntv_ctl_el0();
}
extern "C" {
    #[link_name = "read_cntv_cval_el0__extern"]
    pub fn read_cntv_cval_el0() -> u64;
}
extern "C" {
    #[link_name = "write_cntv_cval_el0__extern"]
    pub fn write_cntv_cval_el0(val: u64);
}
extern "C" {
    #[link_name = "zero_cntv_cval_el0__extern"]
    pub fn zero_cntv_cval_el0();
}
extern "C" {
    #[link_name = "read_cntvct_el0__extern"]
    pub fn read_cntvct_el0() -> u64;
}
extern "C" {
    #[link_name = "write_cntvct_el0__extern"]
    pub fn write_cntvct_el0(val: u64);
}
extern "C" {
    #[link_name = "zero_cntvct_el0__extern"]
    pub fn zero_cntvct_el0();
}
extern "C" {
    #[link_name = "read_cntvoff_el2__extern"]
    pub fn read_cntvoff_el2() -> u64;
}
extern "C" {
    #[link_name = "write_cntvoff_el2__extern"]
    pub fn write_cntvoff_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_cntvoff_el2__extern"]
    pub fn zero_cntvoff_el2();
}
extern "C" {
    #[link_name = "read_currentel__extern"]
    pub fn read_currentel() -> u64;
}
extern "C" {
    #[link_name = "write_currentel__extern"]
    pub fn write_currentel(val: u64);
}
extern "C" {
    #[link_name = "zero_currentel__extern"]
    pub fn zero_currentel();
}
extern "C" {
    #[link_name = "read_csselr_el1__extern"]
    pub fn read_csselr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_csselr_el1__extern"]
    pub fn write_csselr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_csselr_el1__extern"]
    pub fn zero_csselr_el1();
}
extern "C" {
    #[link_name = "read_daif__extern"]
    pub fn read_daif() -> u64;
}
extern "C" {
    #[link_name = "write_daif__extern"]
    pub fn write_daif(val: u64);
}
extern "C" {
    #[link_name = "zero_daif__extern"]
    pub fn zero_daif();
}
extern "C" {
    #[link_name = "read_hcr_el2__extern"]
    pub fn read_hcr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_hcr_el2__extern"]
    pub fn write_hcr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_hcr_el2__extern"]
    pub fn zero_hcr_el2();
}
extern "C" {
    #[link_name = "read_id_aa64pfr0_el1__extern"]
    pub fn read_id_aa64pfr0_el1() -> u64;
}
extern "C" {
    #[link_name = "write_id_aa64pfr0_el1__extern"]
    pub fn write_id_aa64pfr0_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_id_aa64pfr0_el1__extern"]
    pub fn zero_id_aa64pfr0_el1();
}
extern "C" {
    #[link_name = "read_id_aa64mmfr0_el1__extern"]
    pub fn read_id_aa64mmfr0_el1() -> u64;
}
extern "C" {
    #[link_name = "write_id_aa64mmfr0_el1__extern"]
    pub fn write_id_aa64mmfr0_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_id_aa64mmfr0_el1__extern"]
    pub fn zero_id_aa64mmfr0_el1();
}
extern "C" {
    #[link_name = "read_mpidr_el1__extern"]
    pub fn read_mpidr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_mpidr_el1__extern"]
    pub fn write_mpidr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_mpidr_el1__extern"]
    pub fn zero_mpidr_el1();
}
extern "C" {
    #[link_name = "read_par_el1__extern"]
    pub fn read_par_el1() -> u64;
}
extern "C" {
    #[link_name = "write_par_el1__extern"]
    pub fn write_par_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_par_el1__extern"]
    pub fn zero_par_el1();
}
extern "C" {
    #[link_name = "read_scr_el3__extern"]
    pub fn read_scr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_scr_el3__extern"]
    pub fn write_scr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_scr_el3__extern"]
    pub fn zero_scr_el3();
}
extern "C" {
    #[link_name = "read_tpidrro_el0__extern"]
    pub fn read_tpidrro_el0() -> u64;
}
extern "C" {
    #[link_name = "write_tpidrro_el0__extern"]
    pub fn write_tpidrro_el0(val: u64);
}
extern "C" {
    #[link_name = "zero_tpidrro_el0__extern"]
    pub fn zero_tpidrro_el0();
}
extern "C" {
    #[link_name = "read_vmpidr_el2__extern"]
    pub fn read_vmpidr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_vmpidr_el2__extern"]
    pub fn write_vmpidr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_vmpidr_el2__extern"]
    pub fn zero_vmpidr_el2();
}
extern "C" {
    #[link_name = "read_sp_el0__extern"]
    pub fn read_sp_el0() -> u64;
}
extern "C" {
    #[link_name = "write_sp_el0__extern"]
    pub fn write_sp_el0(val: u64);
}
extern "C" {
    #[link_name = "zero_sp_el0__extern"]
    pub fn zero_sp_el0();
}
extern "C" {
    #[link_name = "read_actlr_el1__extern"]
    pub fn read_actlr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_actlr_el1__extern"]
    pub fn write_actlr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_actlr_el1__extern"]
    pub fn zero_actlr_el1();
}
extern "C" {
    #[link_name = "read_actlr_el2__extern"]
    pub fn read_actlr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_actlr_el2__extern"]
    pub fn write_actlr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_actlr_el2__extern"]
    pub fn zero_actlr_el2();
}
extern "C" {
    #[link_name = "read_actlr_el3__extern"]
    pub fn read_actlr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_actlr_el3__extern"]
    pub fn write_actlr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_actlr_el3__extern"]
    pub fn zero_actlr_el3();
}
extern "C" {
    #[link_name = "read_cpacr_el1__extern"]
    pub fn read_cpacr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_cpacr_el1__extern"]
    pub fn write_cpacr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_cpacr_el1__extern"]
    pub fn zero_cpacr_el1();
}
extern "C" {
    #[link_name = "read_cpacr_el2__extern"]
    pub fn read_cpacr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_cpacr_el2__extern"]
    pub fn write_cpacr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_cpacr_el2__extern"]
    pub fn zero_cpacr_el2();
}
extern "C" {
    #[link_name = "read_cpacr_el3__extern"]
    pub fn read_cpacr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_cpacr_el3__extern"]
    pub fn write_cpacr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_cpacr_el3__extern"]
    pub fn zero_cpacr_el3();
}
extern "C" {
    #[link_name = "read_cptr_el1__extern"]
    pub fn read_cptr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_cptr_el1__extern"]
    pub fn write_cptr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_cptr_el1__extern"]
    pub fn zero_cptr_el1();
}
extern "C" {
    #[link_name = "read_cptr_el2__extern"]
    pub fn read_cptr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_cptr_el2__extern"]
    pub fn write_cptr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_cptr_el2__extern"]
    pub fn zero_cptr_el2();
}
extern "C" {
    #[link_name = "read_cptr_el3__extern"]
    pub fn read_cptr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_cptr_el3__extern"]
    pub fn write_cptr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_cptr_el3__extern"]
    pub fn zero_cptr_el3();
}
extern "C" {
    #[link_name = "read_elr_el1__extern"]
    pub fn read_elr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_elr_el1__extern"]
    pub fn write_elr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_elr_el1__extern"]
    pub fn zero_elr_el1();
}
extern "C" {
    #[link_name = "read_elr_el2__extern"]
    pub fn read_elr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_elr_el2__extern"]
    pub fn write_elr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_elr_el2__extern"]
    pub fn zero_elr_el2();
}
extern "C" {
    #[link_name = "read_elr_el3__extern"]
    pub fn read_elr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_elr_el3__extern"]
    pub fn write_elr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_elr_el3__extern"]
    pub fn zero_elr_el3();
}
extern "C" {
    #[link_name = "read_esr_el1__extern"]
    pub fn read_esr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_esr_el1__extern"]
    pub fn write_esr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_esr_el1__extern"]
    pub fn zero_esr_el1();
}
extern "C" {
    #[link_name = "read_esr_el2__extern"]
    pub fn read_esr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_esr_el2__extern"]
    pub fn write_esr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_esr_el2__extern"]
    pub fn zero_esr_el2();
}
extern "C" {
    #[link_name = "read_esr_el3__extern"]
    pub fn read_esr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_esr_el3__extern"]
    pub fn write_esr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_esr_el3__extern"]
    pub fn zero_esr_el3();
}
extern "C" {
    #[link_name = "read_far_el1__extern"]
    pub fn read_far_el1() -> u64;
}
extern "C" {
    #[link_name = "write_far_el1__extern"]
    pub fn write_far_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_far_el1__extern"]
    pub fn zero_far_el1();
}
extern "C" {
    #[link_name = "read_far_el2__extern"]
    pub fn read_far_el2() -> u64;
}
extern "C" {
    #[link_name = "write_far_el2__extern"]
    pub fn write_far_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_far_el2__extern"]
    pub fn zero_far_el2();
}
extern "C" {
    #[link_name = "read_far_el3__extern"]
    pub fn read_far_el3() -> u64;
}
extern "C" {
    #[link_name = "write_far_el3__extern"]
    pub fn write_far_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_far_el3__extern"]
    pub fn zero_far_el3();
}
extern "C" {
    #[link_name = "read_mair_el1__extern"]
    pub fn read_mair_el1() -> u64;
}
extern "C" {
    #[link_name = "write_mair_el1__extern"]
    pub fn write_mair_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_mair_el1__extern"]
    pub fn zero_mair_el1();
}
extern "C" {
    #[link_name = "read_mair_el2__extern"]
    pub fn read_mair_el2() -> u64;
}
extern "C" {
    #[link_name = "write_mair_el2__extern"]
    pub fn write_mair_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_mair_el2__extern"]
    pub fn zero_mair_el2();
}
extern "C" {
    #[link_name = "read_mair_el3__extern"]
    pub fn read_mair_el3() -> u64;
}
extern "C" {
    #[link_name = "write_mair_el3__extern"]
    pub fn write_mair_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_mair_el3__extern"]
    pub fn zero_mair_el3();
}
extern "C" {
    #[link_name = "read_sctlr_el1__extern"]
    pub fn read_sctlr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_sctlr_el1__extern"]
    pub fn write_sctlr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_sctlr_el1__extern"]
    pub fn zero_sctlr_el1();
}
extern "C" {
    #[link_name = "read_sctlr_el2__extern"]
    pub fn read_sctlr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_sctlr_el2__extern"]
    pub fn write_sctlr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_sctlr_el2__extern"]
    pub fn zero_sctlr_el2();
}
extern "C" {
    #[link_name = "read_sctlr_el3__extern"]
    pub fn read_sctlr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_sctlr_el3__extern"]
    pub fn write_sctlr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_sctlr_el3__extern"]
    pub fn zero_sctlr_el3();
}
extern "C" {
    #[link_name = "read_spsr_el1__extern"]
    pub fn read_spsr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_spsr_el1__extern"]
    pub fn write_spsr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_spsr_el1__extern"]
    pub fn zero_spsr_el1();
}
extern "C" {
    #[link_name = "read_spsr_el2__extern"]
    pub fn read_spsr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_spsr_el2__extern"]
    pub fn write_spsr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_spsr_el2__extern"]
    pub fn zero_spsr_el2();
}
extern "C" {
    #[link_name = "read_spsr_el3__extern"]
    pub fn read_spsr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_spsr_el3__extern"]
    pub fn write_spsr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_spsr_el3__extern"]
    pub fn zero_spsr_el3();
}
extern "C" {
    #[link_name = "read_tcr_el1__extern"]
    pub fn read_tcr_el1() -> u64;
}
extern "C" {
    #[link_name = "write_tcr_el1__extern"]
    pub fn write_tcr_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_tcr_el1__extern"]
    pub fn zero_tcr_el1();
}
extern "C" {
    #[link_name = "read_tcr_el2__extern"]
    pub fn read_tcr_el2() -> u64;
}
extern "C" {
    #[link_name = "write_tcr_el2__extern"]
    pub fn write_tcr_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_tcr_el2__extern"]
    pub fn zero_tcr_el2();
}
extern "C" {
    #[link_name = "read_tcr_el3__extern"]
    pub fn read_tcr_el3() -> u64;
}
extern "C" {
    #[link_name = "write_tcr_el3__extern"]
    pub fn write_tcr_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_tcr_el3__extern"]
    pub fn zero_tcr_el3();
}
extern "C" {
    #[link_name = "read_ttbr0_el1__extern"]
    pub fn read_ttbr0_el1() -> u64;
}
extern "C" {
    #[link_name = "write_ttbr0_el1__extern"]
    pub fn write_ttbr0_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_ttbr0_el1__extern"]
    pub fn zero_ttbr0_el1();
}
extern "C" {
    #[link_name = "read_ttbr0_el2__extern"]
    pub fn read_ttbr0_el2() -> u64;
}
extern "C" {
    #[link_name = "write_ttbr0_el2__extern"]
    pub fn write_ttbr0_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_ttbr0_el2__extern"]
    pub fn zero_ttbr0_el2();
}
extern "C" {
    #[link_name = "read_ttbr0_el3__extern"]
    pub fn read_ttbr0_el3() -> u64;
}
extern "C" {
    #[link_name = "write_ttbr0_el3__extern"]
    pub fn write_ttbr0_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_ttbr0_el3__extern"]
    pub fn zero_ttbr0_el3();
}
extern "C" {
    #[link_name = "read_vbar_el1__extern"]
    pub fn read_vbar_el1() -> u64;
}
extern "C" {
    #[link_name = "write_vbar_el1__extern"]
    pub fn write_vbar_el1(val: u64);
}
extern "C" {
    #[link_name = "zero_vbar_el1__extern"]
    pub fn zero_vbar_el1();
}
extern "C" {
    #[link_name = "read_vbar_el2__extern"]
    pub fn read_vbar_el2() -> u64;
}
extern "C" {
    #[link_name = "write_vbar_el2__extern"]
    pub fn write_vbar_el2(val: u64);
}
extern "C" {
    #[link_name = "zero_vbar_el2__extern"]
    pub fn zero_vbar_el2();
}
extern "C" {
    #[link_name = "read_vbar_el3__extern"]
    pub fn read_vbar_el3() -> u64;
}
extern "C" {
    #[link_name = "write_vbar_el3__extern"]
    pub fn write_vbar_el3(val: u64);
}
extern "C" {
    #[link_name = "zero_vbar_el3__extern"]
    pub fn zero_vbar_el3();
}
extern "C" {
    #[link_name = "enable_debug_exceptions__extern"]
    pub fn enable_debug_exceptions();
}
extern "C" {
    #[link_name = "disable_debug_exceptions__extern"]
    pub fn disable_debug_exceptions();
}
extern "C" {
    #[link_name = "enable_serror_exceptions__extern"]
    pub fn enable_serror_exceptions();
}
extern "C" {
    #[link_name = "disable_serror_exceptions__extern"]
    pub fn disable_serror_exceptions();
}
extern "C" {
    #[link_name = "enable_irq__extern"]
    pub fn enable_irq();
}
extern "C" {
    #[link_name = "disable_irq__extern"]
    pub fn disable_irq();
}
extern "C" {
    #[link_name = "enable_fiq__extern"]
    pub fn enable_fiq();
}
extern "C" {
    #[link_name = "disable_fiq__extern"]
    pub fn disable_fiq();
}
extern "C" {
    #[link_name = "is_el_implemented__extern"]
    pub fn is_el_implemented(el: cty::c_uint) -> bool;
}
extern "C" {
    #[link_name = "is_el_highest_implemented__extern"]
    pub fn is_el_highest_implemented() -> bool;
}
extern "C" {
    #[link_name = "is_el2_sec_supported__extern"]
    pub fn is_el2_sec_supported() -> bool;
}
extern "C" {
    #[link_name = "is_in_secure_state__extern"]
    pub fn is_in_secure_state() -> bool;
}
extern "C" {
    #[link_name = "arch_curr_cpu__extern"]
    pub fn arch_curr_cpu() -> *mut _cpu_t;
}
extern "C" {
    #[link_name = "arch_exception_depth__extern"]
    pub fn arch_exception_depth() -> cty::c_int;
}
extern "C" {
    #[link_name = "arch_proc_id__extern"]
    pub fn arch_proc_id() -> u32;
}
extern "C" {
    pub fn z_arm64_thread_mem_domains_init(thread: *mut k_thread);
}
extern "C" {
    pub fn z_arm64_swap_mem_domains(thread: *mut k_thread);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _callee_saved {
    pub x19: u64,
    pub x20: u64,
    pub x21: u64,
    pub x22: u64,
    pub x23: u64,
    pub x24: u64,
    pub x25: u64,
    pub x26: u64,
    pub x27: u64,
    pub x28: u64,
    pub x29: u64,
    pub sp_el0: u64,
    pub sp_elx: u64,
    pub lr: u64,
}
#[test]
fn bindgen_test_layout__callee_saved() {
    const UNINIT: ::core::mem::MaybeUninit<_callee_saved> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_callee_saved>(),
        112usize,
        concat!("Size of: ", stringify!(_callee_saved))
    );
    assert_eq!(
        ::core::mem::align_of::<_callee_saved>(),
        8usize,
        concat!("Alignment of ", stringify!(_callee_saved))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x19) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x19)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x20) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x20)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x21) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x21)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x22) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x22)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x23) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x23)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x24) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x24)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x25) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x25)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x26) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x26)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x27) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x27)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x28) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x28)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x29) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(x29)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp_el0) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(sp_el0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp_elx) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(sp_elx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lr) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(lr)
        )
    );
}
pub type _callee_saved_t = _callee_saved;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct z_arm64_fp_context {
    pub q0: i128,
    pub q1: i128,
    pub q2: i128,
    pub q3: i128,
    pub q4: i128,
    pub q5: i128,
    pub q6: i128,
    pub q7: i128,
    pub q8: i128,
    pub q9: i128,
    pub q10: i128,
    pub q11: i128,
    pub q12: i128,
    pub q13: i128,
    pub q14: i128,
    pub q15: i128,
    pub q16: i128,
    pub q17: i128,
    pub q18: i128,
    pub q19: i128,
    pub q20: i128,
    pub q21: i128,
    pub q22: i128,
    pub q23: i128,
    pub q24: i128,
    pub q25: i128,
    pub q26: i128,
    pub q27: i128,
    pub q28: i128,
    pub q29: i128,
    pub q30: i128,
    pub q31: i128,
    pub fpsr: u32,
    pub fpcr: u32,
}
#[test]
fn bindgen_test_layout_z_arm64_fp_context() {
    const UNINIT: ::core::mem::MaybeUninit<z_arm64_fp_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_arm64_fp_context>(),
        528usize,
        concat!("Size of: ", stringify!(z_arm64_fp_context))
    );
    assert_eq!(
        ::core::mem::align_of::<z_arm64_fp_context>(),
        16usize,
        concat!("Alignment of ", stringify!(z_arm64_fp_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q3) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q4) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q5) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q6) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q7) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q8) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q9) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q10) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q11) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q12) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q13) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q13)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q14) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q14)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q15) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q16) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q17) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q17)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q18) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q18)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q19) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q19)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q20) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q20)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q21) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q21)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q22) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q22)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q23) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q23)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q24) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q24)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q25) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q25)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q26) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q26)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q27) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q27)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q28) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q28)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q29) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q29)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q30) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q30)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q31) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(q31)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_fp_context),
            "::",
            stringify!(fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _thread_arch {
    pub exception_depth: u8,
}
#[test]
fn bindgen_test_layout__thread_arch() {
    const UNINIT: ::core::mem::MaybeUninit<_thread_arch> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_thread_arch>(),
        1usize,
        concat!("Size of: ", stringify!(_thread_arch))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_arch>(),
        1usize,
        concat!("Alignment of ", stringify!(_thread_arch))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exception_depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_arch),
            "::",
            stringify!(exception_depth)
        )
    );
}
pub type _thread_arch_t = _thread_arch;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __esf {
    pub x0: u64,
    pub x1: u64,
    pub x2: u64,
    pub x3: u64,
    pub x4: u64,
    pub x5: u64,
    pub x6: u64,
    pub x7: u64,
    pub x8: u64,
    pub x9: u64,
    pub x10: u64,
    pub x11: u64,
    pub x12: u64,
    pub x13: u64,
    pub x14: u64,
    pub x15: u64,
    pub x16: u64,
    pub x17: u64,
    pub x18: u64,
    pub lr: u64,
    pub spsr: u64,
    pub elr: u64,
}
#[test]
fn bindgen_test_layout___esf() {
    const UNINIT: ::core::mem::MaybeUninit<__esf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__esf>(),
        176usize,
        concat!("Size of: ", stringify!(__esf))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf>(),
        16usize,
        concat!("Alignment of ", stringify!(__esf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x0) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x0))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x2) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x3) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x4) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x5) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x5))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x6) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x6))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x7) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x7))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x8) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x8))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x9) as usize - ptr as usize },
        72usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(x9))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x10) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x11) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x12) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x13) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x13)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x14) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x14)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x15) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x16) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x17) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x17)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x18) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(x18)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lr) as usize - ptr as usize },
        152usize,
        concat!("Offset of field: ", stringify!(__esf), "::", stringify!(lr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spsr) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(spsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).elr) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(elr)
        )
    );
}
pub type z_arch_esf_t = __esf;
extern "C" {
    #[doc = " Configure a dynamic interrupt.\n\n Use this instead of IRQ_CONNECT() if arguments cannot be known at build time.\n\n @param irq IRQ line number\n @param priority Interrupt priority\n @param routine Interrupt service routine\n @param parameter ISR parameter\n @param flags Arch-specific IRQ configuration flags\n\n @return The vector assigned to this interrupt"]
    #[link_name = "irq_connect_dynamic__extern"]
    pub fn irq_connect_dynamic(
        irq: cty::c_uint,
        priority: cty::c_uint,
        routine: ::core::option::Option<unsafe extern "C" fn(parameter: *const cty::c_void)>,
        parameter: *const cty::c_void,
        flags: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Disconnect a dynamic interrupt.\n\n Use this in conjunction with shared interrupts to remove a routine/parameter\n pair from the list of clients using the same interrupt line. If the interrupt\n is not being shared then the associated _sw_isr_table entry will be replaced\n by (NULL, z_irq_spurious) (default entry).\n\n @param irq IRQ line number\n @param priority Interrupt priority\n @param routine Interrupt service routine\n @param parameter ISR parameter\n @param flags Arch-specific IRQ configuration flags\n\n @return 0 in case of success, negative value otherwise"]
    #[link_name = "irq_disconnect_dynamic__extern"]
    pub fn irq_disconnect_dynamic(
        irq: cty::c_uint,
        priority: cty::c_uint,
        routine: ::core::option::Option<unsafe extern "C" fn(parameter: *const cty::c_void)>,
        parameter: *const cty::c_void,
        flags: u32,
    ) -> cty::c_int;
}
#[doc = " @brief Initialization function for init entries.\n\n Init entries support both the system initialization and the device\n APIs. Each API has its own init function signature; hence, we have a\n union to cover both."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union init_function {
    #[doc = " System initialization function.\n\n @retval 0 On success\n @retval -errno If init fails."]
    pub sys: ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>,
    #[doc = " Device initialization function.\n\n @param dev Device instance.\n\n @retval 0 On success\n @retval -errno If device initialization fails."]
    pub dev: ::core::option::Option<unsafe extern "C" fn(dev: *const device) -> cty::c_int>,
}
#[test]
fn bindgen_test_layout_init_function() {
    const UNINIT: ::core::mem::MaybeUninit<init_function> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<init_function>(),
        8usize,
        concat!("Size of: ", stringify!(init_function))
    );
    assert_eq!(
        ::core::mem::align_of::<init_function>(),
        8usize,
        concat!("Alignment of ", stringify!(init_function))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_function),
            "::",
            stringify!(sys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_function),
            "::",
            stringify!(dev)
        )
    );
}
#[doc = " @brief Structure to store initialization entry information.\n\n @internal\n Init entries need to be defined following these rules:\n\n - Their name must be set using Z_INIT_ENTRY_NAME().\n - They must be placed in a special init section, given by\n   Z_INIT_ENTRY_SECTION().\n - They must be aligned, e.g. using Z_DECL_ALIGN().\n\n See SYS_INIT_NAMED() for an example.\n @endinternal"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct init_entry {
    #[doc = " Initialization function."]
    pub init_fn: init_function,
    pub __bindgen_anon_1: init_entry__bindgen_ty_1,
}
#[doc = " If the init entry belongs to a device, this fields stores a\n reference to it, otherwise it is set to NULL."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union init_entry__bindgen_ty_1 {
    pub dev: *const device,
}
#[test]
fn bindgen_test_layout_init_entry__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<init_entry__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<init_entry__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(init_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<init_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(init_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_entry__bindgen_ty_1),
            "::",
            stringify!(dev)
        )
    );
}
#[test]
fn bindgen_test_layout_init_entry() {
    const UNINIT: ::core::mem::MaybeUninit<init_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<init_entry>(),
        16usize,
        concat!("Size of: ", stringify!(init_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<init_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(init_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_fn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(init_entry),
            "::",
            stringify!(init_fn)
        )
    );
}
extern "C" {
    #[doc = " @brief Check if a physical address is within range of physical memory.\n\n This checks if the physical address (@p virt) is within\n permissible range, e.g. between\n :kconfig:option:`CONFIG_SRAM_BASE_ADDRESS` and\n (:kconfig:option:`CONFIG_SRAM_BASE_ADDRESS` +\n  :kconfig:option:`CONFIG_SRAM_SIZE`).\n\n @note Only used if\n :kconfig:option:`CONFIG_KERNEL_VM_USE_CUSTOM_MEM_RANGE_CHECK`\n is enabled.\n\n @param phys Physical address to be checked.\n\n @return True if physical address is within range, false if not."]
    pub fn sys_mm_is_phys_addr_in_range(phys: usize) -> bool;
}
extern "C" {
    #[doc = " @brief Check if a virtual address is within range of virtual memory.\n\n This checks if the virtual address (@p virt) is within\n permissible range, e.g. between\n :kconfig:option:`CONFIG_KERNEL_VM_BASE` and\n (:kconfig:option:`CONFIG_KERNEL_VM_BASE` +\n  :kconfig:option:`CONFIG_KERNEL_VM_SIZE`).\n\n @note Only used if\n :kconfig:option:`CONFIG_KERNEL_VM_USE_CUSTOM_MEM_RANGE_CHECK`\n is enabled.\n\n @param virt Virtual address to be checked.\n\n @return True if virtual address is within range, false if not."]
    pub fn sys_mm_is_virt_addr_in_range(virt: *mut cty::c_void) -> bool;
}
extern "C" {
    #[link_name = "z_mem_phys_addr__extern"]
    pub fn z_mem_phys_addr(virt: *mut cty::c_void) -> usize;
}
extern "C" {
    #[link_name = "z_mem_virt_addr__extern"]
    pub fn z_mem_virt_addr(phys: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Map a physical memory region into the kernel's virtual address space\n\n This function is intended for mapping memory-mapped I/O regions into\n the virtual address space. Given a physical address and a size, return a\n linear address representing the base of where the physical region is mapped\n in the virtual address space for the Zephyr kernel.\n\n This function alters the active page tables in the area reserved\n for the kernel. This function will choose the virtual address\n and return it to the caller.\n\n Portable code should never assume that phys_addr and linear_addr will\n be equal.\n\n Caching and access properties are controlled by the 'flags' parameter.\n Unused bits in 'flags' are reserved for future expansion.\n A caching mode must be selected. By default, the region is read-only\n with user access and code execution forbidden. This policy is changed\n by passing K_MEM_CACHE_* and K_MEM_PERM_* macros into the 'flags' parameter.\n\n If there is insufficient virtual address space for the mapping this will\n generate a kernel panic.\n\n This API is only available if CONFIG_MMU is enabled.\n\n It is highly discouraged to use this function to map system RAM page\n frames. It may conflict with anonymous memory mappings and demand paging\n and produce undefined behavior.  Do not use this for RAM unless you know\n exactly what you are doing. If you need a chunk of memory, use k_mem_map().\n If you need a contiguous buffer of physical memory, statically declare it\n and pin it at build time, it will be mapped when the system boots.\n\n This API is part of infrastructure still under development and may\n change.\n\n @param[out] virt Output virtual address storage location\n @param[in]  phys Physical address base of the memory region\n @param[in]  size Size of the memory region\n @param[in]  flags Caching mode and access flags, see K_MAP_* macros"]
    pub fn z_phys_map(virt_ptr: *mut *mut u8, phys: usize, size: usize, flags: u32);
}
extern "C" {
    #[doc = " Unmap a virtual memory region from kernel's virtual address space.\n\n This function is intended to be used by drivers and early boot routines\n where temporary memory mappings need to be made. This allows these\n memory mappings to be discarded once they are no longer needed.\n\n This function alters the active page tables in the area reserved\n for the kernel.\n\n This will align the input parameters to page boundaries so that\n this can be used with the virtual address as returned by\n z_phys_map().\n\n This API is only available if CONFIG_MMU is enabled.\n\n It is highly discouraged to use this function to unmap memory mappings.\n It may conflict with anonymous memory mappings and demand paging and\n produce undefined behavior. Do not use this unless you know exactly\n what you are doing.\n\n This API is part of infrastructure still under development and may\n change.\n\n @param virt Starting address of the virtual address region to be unmapped.\n @param size Size of the virtual address region"]
    pub fn z_phys_unmap(virt: *mut u8, size: usize);
}
extern "C" {
    #[doc = " Return the amount of free memory available\n\n The returned value will reflect how many free RAM page frames are available.\n If demand paging is enabled, it may still be possible to allocate more.\n\n The information reported by this function may go stale immediately if\n concurrent memory mappings or page-ins take place.\n\n @return Free physical RAM, in bytes"]
    pub fn k_mem_free_get() -> usize;
}
extern "C" {
    #[doc = " Map anonymous memory into Zephyr's address space\n\n This function effectively increases the data space available to Zephyr.\n The kernel will choose a base virtual address and return it to the caller.\n The memory will have access permissions for all contexts set per the\n provided flags argument.\n\n If user thread access control needs to be managed in any way, do not enable\n K_MEM_PERM_USER flags here; instead manage the region's permissions\n with memory domain APIs after the mapping has been established. Setting\n K_MEM_PERM_USER here will allow all user threads to access this memory\n which is usually undesirable.\n\n Unless K_MEM_MAP_UNINIT is used, the returned memory will be zeroed.\n\n The mapped region is not guaranteed to be physically contiguous in memory.\n Physically contiguous buffers should be allocated statically and pinned\n at build time.\n\n Pages mapped in this way have write-back cache settings.\n\n The returned virtual memory pointer will be page-aligned. The size\n parameter, and any base address for re-mapping purposes must be page-\n aligned.\n\n Note that the allocation includes two guard pages immediately before\n and after the requested region. The total size of the allocation will be\n the requested size plus the size of these two guard pages.\n\n Many K_MEM_MAP_* flags have been implemented to alter the behavior of this\n function, with details in the documentation for these flags.\n\n @param size Size of the memory mapping. This must be page-aligned.\n @param flags K_MEM_PERM_*, K_MEM_MAP_* control flags.\n @return The mapped memory location, or NULL if insufficient virtual address\n         space, insufficient physical memory to establish the mapping,\n         or insufficient memory for paging structures."]
    pub fn k_mem_map(size: usize, flags: u32) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Un-map mapped memory\n\n This removes a memory mapping for the provided page-aligned region.\n Associated page frames will be free and the kernel may re-use the associated\n virtual address region. Any paged out data pages may be discarded.\n\n Calling this function on a region which was not mapped to begin with is\n undefined behavior.\n\n @param addr Page-aligned memory region base virtual address\n @param size Page-aligned memory region size"]
    pub fn k_mem_unmap(addr: *mut cty::c_void, size: usize);
}
extern "C" {
    #[doc = " Given an arbitrary region, provide a aligned region that covers it\n\n The returned region will have both its base address and size aligned\n to the provided alignment value.\n\n @param[out] aligned_addr Aligned address\n @param[out] aligned_size Aligned region size\n @param[in]  addr Region base address\n @param[in]  size Region size\n @param[in]  align What to align the address and size to\n @retval offset between aligned_addr and addr"]
    pub fn k_mem_region_align(
        aligned_addr: *mut usize,
        aligned_size: *mut usize,
        addr: usize,
        size: usize,
        align: usize,
    ) -> usize;
}
pub type io_port_t = u32;
pub type mm_reg_t = usize;
pub type mem_addr_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_device_mmio_rom {
    #[doc = " MMIO linear address"]
    pub addr: mm_reg_t,
}
#[test]
fn bindgen_test_layout_z_device_mmio_rom() {
    const UNINIT: ::core::mem::MaybeUninit<z_device_mmio_rom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_device_mmio_rom>(),
        8usize,
        concat!("Size of: ", stringify!(z_device_mmio_rom))
    );
    assert_eq!(
        ::core::mem::align_of::<z_device_mmio_rom>(),
        8usize,
        concat!("Alignment of ", stringify!(z_device_mmio_rom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_device_mmio_rom),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " @brief Type used to represent a \"handle\" for a device.\n\n Every @ref device has an associated handle. You can get a pointer to a\n @ref device from its handle and vice versa, but the handle uses less space\n than a pointer. The device.h API mainly uses handles to store lists of\n multiple devices in a compact way.\n\n The extreme values and zero have special significance. Negative values\n identify functionality that does not correspond to a Zephyr device, such as\n the system clock or a SYS_INIT() function.\n\n @see device_handle_get()\n @see device_from_handle()"]
pub type device_handle_t = i16;
#[doc = " @brief Runtime device dynamic structure (in RAM) per driver instance\n\n Fields in this are expected to be default-initialized to zero. The\n kernel driver infrastructure and driver access functions are\n responsible for ensuring that any non-zero initialization is done\n before they are accessed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_state {
    #[doc = " Device initialization return code (positive errno value).\n\n Device initialization functions return a negative errno code if they\n fail. In Zephyr, errno values do not exceed 255, so we can store the\n positive result value in a uint8_t type."]
    pub init_res: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_device_state() {
    const UNINIT: ::core::mem::MaybeUninit<device_state> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<device_state>(),
        2usize,
        concat!("Size of: ", stringify!(device_state))
    );
    assert_eq!(
        ::core::mem::align_of::<device_state>(),
        1usize,
        concat!("Alignment of ", stringify!(device_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_res) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_state),
            "::",
            stringify!(init_res)
        )
    );
}
impl device_state {
    #[inline]
    pub fn initialized(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(initialized: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u8 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_device {
    _unused: [u8; 0],
}
#[doc = " @defgroup sys_init System Initialization\n @ingroup os_services\n\n Zephyr offers an infrastructure to call initialization code before `main`.\n Such initialization calls can be registered using SYS_INIT() or\n SYS_INIT_NAMED() macros. By using a combination of initialization levels and\n priorities init sequence can be adjusted as needed. The available\n initialization levels are described, in order, below:\n\n - `EARLY`: Used very early in the boot process, right after entering the C\n   domain (``z_cstart()``). This can be used in architectures and SoCs that\n   extend or implement architecture code and use drivers or system services\n   that have to be initialized before the Kernel calls any architecture\n   specific initialization code.\n - `PRE_KERNEL_1`: Executed in Kernel's initialization context, which uses\n   the interrupt stack. At this point Kernel services are not yet available.\n - `PRE_KERNEL_2`: Same as `PRE_KERNEL_1`.\n - `POST_KERNEL`: Executed after Kernel is alive. From this point on, Kernel\n   primitives can be used.\n - `APPLICATION`: Executed just before application code (`main`).\n - `SMP`: Only available if @kconfig{CONFIG_SMP} is enabled, specific for\n   SMP.\n\n Initialization priority can take a value in the range of 0 to 99.\n\n @note The same infrastructure is used by devices.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    #[doc = " Name of the device instance"]
    pub name: *const cty::c_char,
    #[doc = " Address of device instance config information"]
    pub config: *const cty::c_void,
    #[doc = " Address of the API structure exposed by the device instance"]
    pub api: *const cty::c_void,
    #[doc = " Address of the common device state"]
    pub state: *mut device_state,
    #[doc = " Address of the device instance private data"]
    pub data: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_device() {
    const UNINIT: ::core::mem::MaybeUninit<device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<device>(),
        40usize,
        concat!("Size of: ", stringify!(device))
    );
    assert_eq!(
        ::core::mem::align_of::<device>(),
        8usize,
        concat!("Alignment of ", stringify!(device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(api)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " @brief Get the handle for a given device\n\n @param dev the device for which a handle is desired.\n\n @return the handle for the device, or DEVICE_HANDLE_NULL if the device does\n not have an associated handle."]
    #[link_name = "device_handle_get__extern"]
    pub fn device_handle_get(dev: *const device) -> device_handle_t;
}
extern "C" {
    #[doc = " @brief Get the device corresponding to a handle.\n\n @param dev_handle the device handle\n\n @return the device that has that handle, or a null pointer if @p dev_handle\n does not identify a device."]
    #[link_name = "device_from_handle__extern"]
    pub fn device_from_handle(dev_handle: device_handle_t) -> *const device;
}
extern "C" {
    #[doc = " @brief Get a @ref device reference from its @ref device.name field.\n\n This function iterates through the devices on the system. If a device with\n the given @p name field is found, and that device initialized successfully at\n boot time, this function returns a pointer to the device.\n\n If no device has the given @p name, this function returns `NULL`.\n\n This function also returns NULL when a device is found, but it failed to\n initialize successfully at boot time. (To troubleshoot this case, set a\n breakpoint on your device driver's initialization function.)\n\n @param name device name to search for. A null pointer, or a pointer to an\n empty string, will cause NULL to be returned.\n\n @return pointer to device structure with the given name; `NULL` if the device\n is not found or if the device with that name's initialization function\n failed."]
    #[link_name = "device_get_binding__extern"]
    pub fn device_get_binding(name: *const cty::c_char) -> *const device;
}
extern "C" {
    #[doc = " @brief Get access to the static array of static devices.\n\n @param devices where to store the pointer to the array of statically\n allocated devices. The array must not be mutated through this pointer.\n\n @return the number of statically allocated devices."]
    pub fn z_device_get_all_static(devices: *mut *const device) -> usize;
}
extern "C" {
    #[doc = " @brief Verify that a device is ready for use.\n\n This is the implementation underlying device_is_ready(), without the overhead\n of a syscall wrapper.\n\n @param dev pointer to the device in question.\n\n @retval true If the device is ready for use.\n @retval false If the device is not ready for use or if a NULL device pointer\n is passed as argument.\n\n @see device_is_ready()"]
    pub fn z_device_is_ready(dev: *const device) -> bool;
}
extern "C" {
    #[doc = " @brief Verify that a device is ready for use.\n\n Indicates whether the provided device pointer is for a device known to be\n in a state where it can be used with its standard API.\n\n This can be used with device pointers captured from DEVICE_DT_GET(), which\n does not include the readiness checks of device_get_binding(). At minimum\n this means that the device has been successfully initialized.\n\n @param dev pointer to the device in question.\n\n @retval true If the device is ready for use.\n @retval false If the device is not ready for use or if a NULL device pointer\n is passed as argument."]
    #[link_name = "device_is_ready__extern"]
    pub fn device_is_ready(dev: *const device) -> bool;
}
extern "C" {
    #[link_name = "z_impl_device_is_ready__extern"]
    pub fn z_impl_device_is_ready(dev: *const device) -> bool;
}
extern "C" {
    pub static __device_dts_ord_0: device;
}
extern "C" {
    pub static __device_dts_ord_2: device;
}
extern "C" {
    pub static __device_dts_ord_1: device;
}
extern "C" {
    pub static __device_dts_ord_3: device;
}
extern "C" {
    pub static __device_dts_ord_14: device;
}
extern "C" {
    pub static __device_dts_ord_4: device;
}
extern "C" {
    pub static __device_dts_ord_8: device;
}
extern "C" {
    pub static __device_dts_ord_9: device;
}
extern "C" {
    pub static __device_dts_ord_10: device;
}
extern "C" {
    pub static __device_dts_ord_15: device;
}
extern "C" {
    pub static __device_dts_ord_6: device;
}
extern "C" {
    pub static __device_dts_ord_7: device;
}
extern "C" {
    pub static __device_dts_ord_5: device;
}
extern "C" {
    pub static __device_dts_ord_11: device;
}
extern "C" {
    pub static __device_dts_ord_13: device;
}
extern "C" {
    pub static __device_dts_ord_12: device;
}
extern "C" {
    pub fn z_impl_device_get_binding(name: *const cty::c_char) -> *const device;
}
extern "C" {
    pub fn _isr_wrapper();
}
extern "C" {
    pub fn z_irq_spurious(unused: *const cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _isr_table_entry {
    pub arg: *const cty::c_void,
    pub isr: ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_void)>,
}
#[test]
fn bindgen_test_layout__isr_table_entry() {
    const UNINIT: ::core::mem::MaybeUninit<_isr_table_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_isr_table_entry>(),
        16usize,
        concat!("Size of: ", stringify!(_isr_table_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<_isr_table_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(_isr_table_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_table_entry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).isr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_table_entry),
            "::",
            stringify!(isr)
        )
    );
}
extern "C" {
    pub static mut _sw_isr_table: [_isr_table_entry; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _irq_parent_entry {
    pub dev: *const device,
    pub irq: cty::c_uint,
    pub offset: cty::c_uint,
}
#[test]
fn bindgen_test_layout__irq_parent_entry() {
    const UNINIT: ::core::mem::MaybeUninit<_irq_parent_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_irq_parent_entry>(),
        16usize,
        concat!("Size of: ", stringify!(_irq_parent_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<_irq_parent_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(_irq_parent_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_irq_parent_entry),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).irq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_irq_parent_entry),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_irq_parent_entry),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _isr_list {
    #[doc = " IRQ line number"]
    pub irq: i32,
    #[doc = " Flags for this IRQ, see ISR_FLAG_* definitions"]
    pub flags: i32,
    #[doc = " ISR to call"]
    pub func: *mut cty::c_void,
    #[doc = " Parameter for non-direct IRQs"]
    pub param: *const cty::c_void,
}
#[test]
fn bindgen_test_layout__isr_list() {
    const UNINIT: ::core::mem::MaybeUninit<_isr_list> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_isr_list>(),
        24usize,
        concat!("Size of: ", stringify!(_isr_list))
    );
    assert_eq!(
        ::core::mem::align_of::<_isr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(_isr_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).irq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(param)
        )
    );
}
extern "C" {
    pub fn z_arm64_irq_priority_set(irq: cty::c_uint, prio: cty::c_uint, flags: u32);
}
extern "C" {
    pub fn z_arm64_interrupt_init();
}
extern "C" {
    pub fn sys_clock_cycle_get_32() -> u32;
}
extern "C" {
    pub fn sys_clock_cycle_get_64() -> u64;
}
extern "C" {
    #[link_name = "arch_nop__extern"]
    pub fn arch_nop();
}
extern "C" {
    #[doc = " @brief Full/sequentially-consistent data memory barrier.\n\n This routine acts as a synchronization fence between threads and prevents\n re-ordering of data accesses instructions across the barrier instruction."]
    #[link_name = "barrier_dmem_fence_full__extern"]
    pub fn barrier_dmem_fence_full();
}
extern "C" {
    #[doc = " @brief Full/sequentially-consistent data synchronization barrier.\n\n This routine acts as a synchronization fence between threads and prevents\n re-ordering of data accesses instructions across the barrier instruction\n like @ref barrier_dmem_fence_full(), but has the additional effect of\n blocking execution of any further instructions, not just loads or stores, or\n both, until synchronization is complete.\n\n @note When not supported by hardware or architecture, this instruction falls\n back to a full/sequentially-consistent data memory barrier."]
    #[link_name = "barrier_dsync_fence_full__extern"]
    pub fn barrier_dsync_fence_full();
}
extern "C" {
    #[doc = " @brief Full/sequentially-consistent instruction synchronization barrier.\n\n This routine is used to guarantee that any subsequent instructions are\n fetched and to ensure any previously executed context-changing operations,\n such as writes to system control registers, have completed by the time the\n routine completes. In hardware terms, this might mean that the instruction\n pipeline is flushed, for example.\n\n @note When not supported by hardware or architecture, this instruction falls\n back to a compiler barrier."]
    #[link_name = "barrier_isync_fence_full__extern"]
    pub fn barrier_isync_fence_full();
}
extern "C" {
    #[link_name = "sys_read8__extern"]
    pub fn sys_read8(addr: mem_addr_t) -> u8;
}
extern "C" {
    #[link_name = "sys_write8__extern"]
    pub fn sys_write8(data: u8, addr: mem_addr_t);
}
extern "C" {
    #[link_name = "sys_read16__extern"]
    pub fn sys_read16(addr: mem_addr_t) -> u16;
}
extern "C" {
    #[link_name = "sys_write16__extern"]
    pub fn sys_write16(data: u16, addr: mem_addr_t);
}
extern "C" {
    #[link_name = "sys_read32__extern"]
    pub fn sys_read32(addr: mem_addr_t) -> u32;
}
extern "C" {
    #[link_name = "sys_write32__extern"]
    pub fn sys_write32(data: u32, addr: mem_addr_t);
}
extern "C" {
    #[link_name = "sys_read64__extern"]
    pub fn sys_read64(addr: mem_addr_t) -> u64;
}
extern "C" {
    #[link_name = "sys_write64__extern"]
    pub fn sys_write64(data: u64, addr: mem_addr_t);
}
extern "C" {
    #[link_name = "arm_arch_timer_init__extern"]
    pub fn arm_arch_timer_init();
}
extern "C" {
    #[link_name = "arm_arch_timer_set_compare__extern"]
    pub fn arm_arch_timer_set_compare(val: u64);
}
extern "C" {
    #[link_name = "arm_arch_timer_enable__extern"]
    pub fn arm_arch_timer_enable(enable: cty::c_uchar);
}
extern "C" {
    #[link_name = "arm_arch_timer_set_irq_mask__extern"]
    pub fn arm_arch_timer_set_irq_mask(mask: bool);
}
extern "C" {
    #[link_name = "arm_arch_timer_count__extern"]
    pub fn arm_arch_timer_count() -> u64;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct z_arm64_thread_stack_header {
    pub privilege_stack: [cty::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_z_arm64_thread_stack_header() {
    const UNINIT: ::core::mem::MaybeUninit<z_arm64_thread_stack_header> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_arm64_thread_stack_header>(),
        16usize,
        concat!("Size of: ", stringify!(z_arm64_thread_stack_header))
    );
    assert_eq!(
        ::core::mem::align_of::<z_arm64_thread_stack_header>(),
        16usize,
        concat!("Alignment of ", stringify!(z_arm64_thread_stack_header))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).privilege_stack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_arm64_thread_stack_header),
            "::",
            stringify!(privilege_stack)
        )
    );
}
pub type paddr_t = usize;
pub type vaddr_t = *mut cty::c_void;
extern "C" {
    #[link_name = "sys_set_bit__extern"]
    pub fn sys_set_bit(addr: mem_addr_t, bit: cty::c_uint);
}
extern "C" {
    #[link_name = "sys_clear_bit__extern"]
    pub fn sys_clear_bit(addr: mem_addr_t, bit: cty::c_uint);
}
extern "C" {
    #[link_name = "sys_test_bit__extern"]
    pub fn sys_test_bit(addr: mem_addr_t, bit: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[link_name = "sys_set_bits__extern"]
    pub fn sys_set_bits(addr: mem_addr_t, mask: cty::c_uint);
}
extern "C" {
    #[link_name = "sys_clear_bits__extern"]
    pub fn sys_clear_bits(addr: mem_addr_t, mask: cty::c_uint);
}
extern "C" {
    #[link_name = "sys_bitfield_set_bit__extern"]
    pub fn sys_bitfield_set_bit(addr: mem_addr_t, bit: cty::c_uint);
}
extern "C" {
    #[link_name = "sys_bitfield_clear_bit__extern"]
    pub fn sys_bitfield_clear_bit(addr: mem_addr_t, bit: cty::c_uint);
}
extern "C" {
    #[link_name = "sys_bitfield_test_bit__extern"]
    pub fn sys_bitfield_test_bit(addr: mem_addr_t, bit: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[link_name = "sys_test_and_set_bit__extern"]
    pub fn sys_test_and_set_bit(addr: mem_addr_t, bit: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[link_name = "sys_test_and_clear_bit__extern"]
    pub fn sys_test_and_clear_bit(addr: mem_addr_t, bit: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[link_name = "sys_bitfield_test_and_set_bit__extern"]
    pub fn sys_bitfield_test_and_set_bit(addr: mem_addr_t, bit: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[link_name = "sys_bitfield_test_and_clear_bit__extern"]
    pub fn sys_bitfield_test_and_clear_bit(addr: mem_addr_t, bit: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief find most significant bit set in a 32-bit word\n\n This routine finds the first bit set starting from the most significant bit\n in the argument passed in and returns the index of that bit.  Bits are\n numbered starting at 1 from the least significant bit.  A return value of\n zero indicates that the value passed is zero.\n\n @return most significant bit set, 0 if @a op is 0"]
    #[link_name = "find_msb_set__extern"]
    pub fn find_msb_set(op: u32) -> cty::c_uint;
}
extern "C" {
    #[doc = " @brief find least significant bit set in a 32-bit word\n\n This routine finds the first bit set starting from the least significant bit\n in the argument passed in and returns the index of that bit.  Bits are\n numbered starting at 1 from the least significant bit.  A return value of\n zero indicates that the value passed is zero.\n\n @return least significant bit set, 0 if @a op is 0"]
    #[link_name = "find_lsb_set__extern"]
    pub fn find_lsb_set(op: u32) -> cty::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_mem_domain {
    pub node: sys_snode_t,
}
#[test]
fn bindgen_test_layout_arch_mem_domain() {
    const UNINIT: ::core::mem::MaybeUninit<arch_mem_domain> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arch_mem_domain>(),
        8usize,
        concat!("Size of: ", stringify!(arch_mem_domain))
    );
    assert_eq!(
        ::core::mem::align_of::<arch_mem_domain>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_mem_domain))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_mem_domain),
            "::",
            stringify!(node)
        )
    );
}
pub type k_ticks_t = u32;
#[doc = " @brief Kernel timeout type\n\n Timeout arguments presented to kernel APIs are stored in this\n opaque type, which is capable of representing times in various\n formats and units.  It should be constructed from application data\n using one of the macros defined for this purpose (e.g. `K_MSEC()`,\n `K_TIMEOUT_ABS_TICKS()`, etc...), or be one of the two constants\n K_NO_WAIT or K_FOREVER.  Applications should not inspect the\n internal data once constructed.  Timeout values may be compared for\n equality with the `K_TIMEOUT_EQ()` macro."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_timeout_t {
    pub ticks: k_ticks_t,
}
#[test]
fn bindgen_test_layout_k_timeout_t() {
    const UNINIT: ::core::mem::MaybeUninit<k_timeout_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_timeout_t>(),
        4usize,
        concat!("Size of: ", stringify!(k_timeout_t))
    );
    assert_eq!(
        ::core::mem::align_of::<k_timeout_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k_timeout_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ticks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timeout_t),
            "::",
            stringify!(ticks)
        )
    );
}
extern "C" {
    #[doc = " @brief Return the lower part of the current system tick count\n\n @return the current system tick count\n"]
    pub fn sys_clock_tick_get_32() -> u32;
}
extern "C" {
    #[doc = " @brief Return the current system tick count\n\n @return the current system tick count\n"]
    pub fn sys_clock_tick_get() -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_timepoint_t {
    pub wait: bool,
}
#[test]
fn bindgen_test_layout_k_timepoint_t() {
    const UNINIT: ::core::mem::MaybeUninit<k_timepoint_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_timepoint_t>(),
        1usize,
        concat!("Size of: ", stringify!(k_timepoint_t))
    );
    assert_eq!(
        ::core::mem::align_of::<k_timepoint_t>(),
        1usize,
        concat!("Alignment of ", stringify!(k_timepoint_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timepoint_t),
            "::",
            stringify!(wait)
        )
    );
}
extern "C" {
    #[link_name = "sys_timepoint_calc__extern"]
    pub fn sys_timepoint_calc(timeout: k_timeout_t) -> k_timepoint_t;
}
extern "C" {
    #[link_name = "sys_timepoint_timeout__extern"]
    pub fn sys_timepoint_timeout(timepoint: k_timepoint_t) -> k_timeout_t;
}
extern "C" {
    #[link_name = "sys_timepoint_cmp__extern"]
    pub fn sys_timepoint_cmp(a: k_timepoint_t, b: k_timepoint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Indicates if timepoint is expired\n\n @param timepoint Timepoint to evaluate\n @retval true if the timepoint is in the past, false otherwise\n\n @see sys_timepoint_calc()"]
    #[link_name = "sys_timepoint_expired__extern"]
    pub fn sys_timepoint_expired(timepoint: k_timepoint_t) -> bool;
}
extern "C" {
    pub fn __errno_location() -> *mut cty::c_int;
}
#[doc = " @brief Spinlock APIs\n @defgroup spinlock_apis Spinlock APIs\n @ingroup kernel_apis\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_spinlock_key {
    pub key: cty::c_int,
}
#[test]
fn bindgen_test_layout_z_spinlock_key() {
    const UNINIT: ::core::mem::MaybeUninit<z_spinlock_key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_spinlock_key>(),
        4usize,
        concat!("Size of: ", stringify!(z_spinlock_key))
    );
    assert_eq!(
        ::core::mem::align_of::<z_spinlock_key>(),
        4usize,
        concat!("Alignment of ", stringify!(z_spinlock_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_spinlock_key),
            "::",
            stringify!(key)
        )
    );
}
#[doc = " @brief Kernel Spin Lock\n\n This struct defines a spin lock record on which CPUs can wait with\n k_spin_lock().  Any number of spinlocks may be defined in\n application code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_spinlock {
    is_empty: bool
}
#[test]
fn bindgen_test_layout_k_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<k_spinlock>(),
        0usize,
        concat!("Size of: ", stringify!(k_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<k_spinlock>(),
        1usize,
        concat!("Alignment of ", stringify!(k_spinlock))
    );
}
#[doc = " @brief Spinlock key type\n\n This type defines a \"key\" value used by a spinlock implementation\n to store the system interrupt state at the time of a call to\n k_spin_lock().  It is expected to be passed to a matching\n k_spin_unlock().\n\n This type is opaque and should not be inspected by application\n code."]
pub type k_spinlock_key_t = z_spinlock_key;
extern "C" {
    #[link_name = "z_spinlock_validate_pre__extern"]
    pub fn z_spinlock_validate_pre(l: *mut k_spinlock);
}
extern "C" {
    #[link_name = "z_spinlock_validate_post__extern"]
    pub fn z_spinlock_validate_post(l: *mut k_spinlock);
}
extern "C" {
    #[doc = " @brief Lock a spinlock\n\n This routine locks the specified spinlock, returning a key handle\n representing interrupt state needed at unlock time.  Upon\n returning, the calling thread is guaranteed not to be suspended or\n interrupted on its current CPU until it calls k_spin_unlock().  The\n implementation guarantees mutual exclusion: exactly one thread on\n one CPU will return from k_spin_lock() at a time.  Other CPUs\n trying to acquire a lock already held by another CPU will enter an\n implementation-defined busy loop (\"spinning\") until the lock is\n released.\n\n Separate spin locks may be nested. It is legal to lock an\n (unlocked) spin lock while holding a different lock.  Spin locks\n are not recursive, however: an attempt to acquire a spin lock that\n the CPU already holds will deadlock.\n\n In circumstances where only one CPU exists, the behavior of\n k_spin_lock() remains as specified above, though obviously no\n spinning will take place.  Implementations may be free to optimize\n in uniprocessor contexts such that the locking reduces to an\n interrupt mask operation.\n\n @param l A pointer to the spinlock to lock\n @return A key value that must be passed to k_spin_unlock() when the\n         lock is released."]
    #[link_name = "k_spin_lock__extern"]
    pub fn k_spin_lock(l: *mut k_spinlock) -> k_spinlock_key_t;
}
extern "C" {
    #[doc = " @brief Attempt to lock a spinlock\n\n This routine makes one attempt to lock @p l. If it is successful, then\n it will store the key into @p k.\n\n @param[in] l A pointer to the spinlock to lock\n @param[out] k A pointer to the spinlock key\n @retval 0 on success\n @retval -EBUSY if another thread holds the lock\n\n @see k_spin_lock\n @see k_spin_unlock"]
    #[link_name = "k_spin_trylock__extern"]
    pub fn k_spin_trylock(l: *mut k_spinlock, k: *mut k_spinlock_key_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Unlock a spin lock\n\n This releases a lock acquired by k_spin_lock().  After this\n function is called, any CPU will be able to acquire the lock.  If\n other CPUs are currently spinning inside k_spin_lock() waiting for\n this lock, exactly one of them will return synchronously with the\n lock held.\n\n Spin locks must be properly nested.  A call to k_spin_unlock() must\n be made on the lock object most recently locked using\n k_spin_lock(), using the key value that it returned.  Attempts to\n unlock mis-nested locks, or to unlock locks that are not held, or\n to passing a key parameter other than the one returned from\n k_spin_lock(), are illegal.  When CONFIG_SPIN_VALIDATE is set, some\n of these errors can be detected by the framework.\n\n @param l A pointer to the spinlock to release\n @param key The value returned from k_spin_lock() when this lock was\n        acquired"]
    #[link_name = "k_spin_unlock__extern"]
    pub fn k_spin_unlock(l: *mut k_spinlock, key: k_spinlock_key_t);
}
extern "C" {
    #[link_name = "k_spin_release__extern"]
    pub fn k_spin_release(l: *mut k_spinlock);
}
#[doc = " Generic CPU exception, not covered by other codes"]
pub const k_fatal_error_reason_K_ERR_CPU_EXCEPTION: k_fatal_error_reason = 0;
#[doc = " Unhandled hardware interrupt"]
pub const k_fatal_error_reason_K_ERR_SPURIOUS_IRQ: k_fatal_error_reason = 1;
#[doc = " Faulting context overflowed its stack buffer"]
pub const k_fatal_error_reason_K_ERR_STACK_CHK_FAIL: k_fatal_error_reason = 2;
#[doc = " Moderate severity software error"]
pub const k_fatal_error_reason_K_ERR_KERNEL_OOPS: k_fatal_error_reason = 3;
#[doc = " High severity software error"]
pub const k_fatal_error_reason_K_ERR_KERNEL_PANIC: k_fatal_error_reason = 4;
#[doc = " Arch specific fatal errors"]
pub const k_fatal_error_reason_K_ERR_ARCH_START: k_fatal_error_reason = 16;
#[doc = " @defgroup fatal_types Fatal error base types\n @ingroup fatal_apis\n @{"]
pub type k_fatal_error_reason = cty::c_uint;
extern "C" {
    #[doc = " @brief Halt the system on a fatal error\n\n Invokes architecture-specific code to power off or halt the system in\n a low power state. Lacking that, lock interrupts and sit in an idle loop.\n\n @param reason Fatal exception reason code"]
    pub fn k_fatal_halt(reason: cty::c_uint) -> !;
}
extern "C" {
    #[doc = " @brief Fatal error policy handler\n\n This function is not invoked by application code, but is declared as a\n weak symbol so that applications may introduce their own policy.\n\n The default implementation of this function halts the system\n unconditionally. Depending on architecture support, this may be\n a simple infinite loop, power off the hardware, or exit an emulator.\n\n If this function returns, then the currently executing thread will be\n aborted.\n\n A few notes for custom implementations:\n\n - If the error is determined to be unrecoverable, LOG_PANIC() should be\n   invoked to flush any pending logging buffers.\n - K_ERR_KERNEL_PANIC indicates a severe unrecoverable error in the kernel\n   itself, and should not be considered recoverable. There is an assertion\n   in z_fatal_error() to enforce this.\n - Even outside of a kernel panic, unless the fault occurred in user mode,\n   the kernel itself may be in an inconsistent state, with API calls to\n   kernel objects possibly exhibiting undefined behavior or triggering\n   another exception.\n\n @param reason The reason for the fatal error\n @param esf Exception context, with details and partial or full register\n            state when the error occurred. May in some cases be NULL."]
    pub fn k_sys_fatal_error_handler(reason: cty::c_uint, esf: *const z_arch_esf_t);
}
extern "C" {
    #[doc = " Called by architecture code upon a fatal error.\n\n This function dumps out architecture-agnostic information about the error\n and then makes a policy decision on what to do by invoking\n k_sys_fatal_error_handler().\n\n On architectures where k_thread_abort() never returns, this function\n never returns either.\n\n @param reason The reason for the fatal error\n @param esf Exception context, with details and partial or full register\n            state when the error occurred. May in some cases be NULL."]
    pub fn z_fatal_error(reason: cty::c_uint, esf: *const z_arch_esf_t);
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct z_thread_stack_element {
    pub data: cty::c_char,
}
#[test]
fn bindgen_test_layout_z_thread_stack_element() {
    const UNINIT: ::core::mem::MaybeUninit<z_thread_stack_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_thread_stack_element>(),
        1usize,
        concat!("Size of: ", stringify!(z_thread_stack_element))
    );
    assert_eq!(
        ::core::mem::align_of::<z_thread_stack_element>(),
        1usize,
        concat!("Alignment of ", stringify!(z_thread_stack_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_thread_stack_element),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " @brief Properly align a CPU stack pointer value\n\n Take the provided value and round it down such that the value is aligned\n to the CPU and ABI requirements. This is not used for any memory protection\n hardware requirements.\n\n @param ptr Proposed stack pointer address\n @return Properly aligned stack pointer address"]
    #[link_name = "z_stack_ptr_align__extern"]
    pub fn z_stack_ptr_align(ptr: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " @}"]
    #[link_name = "Z_KERNEL_STACK_BUFFER__extern"]
    pub fn Z_KERNEL_STACK_BUFFER(sym: *mut k_thread_stack_t) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _pipe_desc {
    pub node: sys_dnode_t,
    pub buffer: *mut cty::c_uchar,
    pub bytes_to_xfer: usize,
    pub thread: *mut k_thread,
}
#[test]
fn bindgen_test_layout__pipe_desc() {
    const UNINIT: ::core::mem::MaybeUninit<_pipe_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_pipe_desc>(),
        40usize,
        concat!("Size of: ", stringify!(_pipe_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<_pipe_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(_pipe_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pipe_desc),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pipe_desc),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_to_xfer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pipe_desc),
            "::",
            stringify!(bytes_to_xfer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_pipe_desc),
            "::",
            stringify!(thread)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _thread_base {
    pub __bindgen_anon_1: _thread_base__bindgen_ty_1,
    pub pended_on: *mut _wait_q_t,
    pub user_options: u8,
    pub thread_state: u8,
    pub __bindgen_anon_2: _thread_base__bindgen_ty_2,
    pub order_key: u32,
    pub swap_data: *mut cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _thread_base__bindgen_ty_1 {
    pub qnode_dlist: sys_dnode_t,
    pub qnode_rb: rbnode,
}
#[test]
fn bindgen_test_layout__thread_base__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_thread_base__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_thread_base__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_thread_base__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_thread_base__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qnode_dlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_1),
            "::",
            stringify!(qnode_dlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qnode_rb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_1),
            "::",
            stringify!(qnode_rb)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _thread_base__bindgen_ty_2 {
    pub __bindgen_anon_1: _thread_base__bindgen_ty_2__bindgen_ty_1,
    pub preempt: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _thread_base__bindgen_ty_2__bindgen_ty_1 {
    pub prio: i8,
    pub sched_locked: u8,
}
#[test]
fn bindgen_test_layout__thread_base__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_thread_base__bindgen_ty_2__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_thread_base__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_locked) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sched_locked)
        )
    );
}
#[test]
fn bindgen_test_layout__thread_base__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_thread_base__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_thread_base__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(_thread_base__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(_thread_base__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).preempt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_2),
            "::",
            stringify!(preempt)
        )
    );
}
#[test]
fn bindgen_test_layout__thread_base() {
    const UNINIT: ::core::mem::MaybeUninit<_thread_base> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_thread_base>(),
        40usize,
        concat!("Size of: ", stringify!(_thread_base))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base>(),
        8usize,
        concat!("Alignment of ", stringify!(_thread_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pended_on) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(pended_on)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(user_options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_state) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(thread_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).order_key) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(order_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swap_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(swap_data)
        )
    );
}
pub type _thread_base_t = _thread_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_thread_runtime_stats {
    is_empty: bool
}
#[test]
fn bindgen_test_layout_k_thread_runtime_stats() {
    assert_eq!(
        ::core::mem::size_of::<k_thread_runtime_stats>(),
        0usize,
        concat!("Size of: ", stringify!(k_thread_runtime_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<k_thread_runtime_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(k_thread_runtime_stats))
    );
}
pub type k_thread_runtime_stats_t = k_thread_runtime_stats;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_poller {
    pub is_polling: bool,
    pub mode: u8,
}
#[test]
fn bindgen_test_layout_z_poller() {
    const UNINIT: ::core::mem::MaybeUninit<z_poller> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_poller>(),
        2usize,
        concat!("Size of: ", stringify!(z_poller))
    );
    assert_eq!(
        ::core::mem::align_of::<z_poller>(),
        1usize,
        concat!("Alignment of ", stringify!(z_poller))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_polling) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_poller),
            "::",
            stringify!(is_polling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(z_poller),
            "::",
            stringify!(mode)
        )
    );
}
#[doc = " @ingroup thread_apis\n Thread Structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_thread {
    pub base: _thread_base,
    #[doc = " defined by the architecture, but all archs need these"]
    pub callee_saved: _callee_saved,
    #[doc = " static thread init data"]
    pub init_data: *mut cty::c_void,
    #[doc = " threads waiting in k_thread_join()"]
    pub join_queue: _wait_q_t,
    #[doc = " resource pool"]
    pub resource_pool: *mut k_heap,
    #[doc = " arch-specifics: must always be at the end"]
    pub arch: _thread_arch,
}
#[test]
fn bindgen_test_layout_k_thread() {
    const UNINIT: ::core::mem::MaybeUninit<k_thread> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_thread>(),
        192usize,
        concat!("Size of: ", stringify!(k_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<k_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(k_thread))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callee_saved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(callee_saved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_data) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(init_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).join_queue) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(join_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resource_pool) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(resource_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arch) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(arch)
        )
    );
}
#[doc = " @ingroup thread_apis\n Thread Structure"]
pub type _thread_t = k_thread;
pub type k_tid_t = *mut k_thread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mem_partition {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Initialize a memory domain.\n\n Initialize a memory domain with given name and memory partitions.\n\n See documentation for k_mem_domain_add_partition() for details about\n partition constraints.\n\n Do not call k_mem_domain_init() on the same memory domain more than once,\n doing so is undefined behavior.\n\n @param domain The memory domain to be initialized.\n @param num_parts The number of array items of \"parts\" parameter.\n @param parts An array of pointers to the memory partitions. Can be NULL\n              if num_parts is zero.\n\n @retval 0 if successful\n @retval -EINVAL if invalid parameters supplied\n @retval -ENOMEM if insufficient memory"]
    pub fn k_mem_domain_init(
        domain: *mut k_mem_domain,
        num_parts: u8,
        parts: *mut *mut k_mem_partition,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Add a memory partition into a memory domain.\n\n Add a memory partition into a memory domain. Partitions must conform to\n the following constraints:\n\n - Partitions in the same memory domain may not overlap each other.\n - Partitions must not be defined which expose private kernel\n   data structures or kernel objects.\n - The starting address alignment, and the partition size must conform to\n   the constraints of the underlying memory management hardware, which\n   varies per architecture.\n - Memory domain partitions are only intended to control access to memory\n   from user mode threads.\n - If CONFIG_EXECUTE_XOR_WRITE is enabled, the partition must not allow\n   both writes and execution.\n\n Violating these constraints may lead to CPU exceptions or undefined\n behavior.\n\n @param domain The memory domain to be added a memory partition.\n @param part The memory partition to be added\n\n @retval 0 if successful\n @retval -EINVAL if invalid parameters supplied\n @retval -ENOSPC if no free partition slots available"]
    pub fn k_mem_domain_add_partition(
        domain: *mut k_mem_domain,
        part: *mut k_mem_partition,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Remove a memory partition from a memory domain.\n\n Remove a memory partition from a memory domain.\n\n @param domain The memory domain to be removed a memory partition.\n @param part The memory partition to be removed\n\n @retval 0 if successful\n @retval -EINVAL if invalid parameters supplied\n @retval -ENOENT if no matching partition found"]
    pub fn k_mem_domain_remove_partition(
        domain: *mut k_mem_domain,
        part: *mut k_mem_partition,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Add a thread into a memory domain.\n\n Add a thread into a memory domain. It will be removed from whatever\n memory domain it previously belonged to.\n\n @param domain The memory domain that the thread is going to be added into.\n @param thread ID of thread going to be added into the memory domain.\n\n @return 0 if successful, fails otherwise."]
    pub fn k_mem_domain_add_thread(domain: *mut k_mem_domain, thread: k_tid_t) -> cty::c_int;
}
extern "C" {
    #[link_name = "k_object_init__extern"]
    pub fn k_object_init(obj: *const cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_object {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "k_object_create_dynamic_aligned__extern"]
    pub fn k_object_create_dynamic_aligned(align: usize, size: usize) -> *mut k_object;
}
extern "C" {
    #[link_name = "k_object_create_dynamic__extern"]
    pub fn k_object_create_dynamic(size: usize) -> *mut k_object;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_futex_data {
    _unused: [u8; 0],
}
pub const k_objects_K_OBJ_ANY: k_objects = 0;
pub const k_objects_K_OBJ_MEM_SLAB: k_objects = 1;
pub const k_objects_K_OBJ_MSGQ: k_objects = 2;
pub const k_objects_K_OBJ_MUTEX: k_objects = 3;
pub const k_objects_K_OBJ_PIPE: k_objects = 4;
pub const k_objects_K_OBJ_QUEUE: k_objects = 5;
pub const k_objects_K_OBJ_POLL_SIGNAL: k_objects = 6;
pub const k_objects_K_OBJ_SEM: k_objects = 7;
pub const k_objects_K_OBJ_STACK: k_objects = 8;
pub const k_objects_K_OBJ_THREAD: k_objects = 9;
pub const k_objects_K_OBJ_TIMER: k_objects = 10;
pub const k_objects_K_OBJ_THREAD_STACK_ELEMENT: k_objects = 11;
pub const k_objects_K_OBJ_NET_SOCKET: k_objects = 12;
pub const k_objects_K_OBJ_NET_IF: k_objects = 13;
pub const k_objects_K_OBJ_SYS_MUTEX: k_objects = 14;
pub const k_objects_K_OBJ_FUTEX: k_objects = 15;
pub const k_objects_K_OBJ_CONDVAR: k_objects = 16;
pub const k_objects_K_OBJ_DRIVER_GPIO: k_objects = 17;
pub const k_objects_K_OBJ_DRIVER_UART: k_objects = 18;
pub const k_objects_K_OBJ_DRIVER_CRYPTO: k_objects = 19;
pub const k_objects_K_OBJ_DRIVER_ADC: k_objects = 20;
pub const k_objects_K_OBJ_DRIVER_AUXDISPLAY: k_objects = 21;
pub const k_objects_K_OBJ_DRIVER_BBRAM: k_objects = 22;
pub const k_objects_K_OBJ_DRIVER_CAN: k_objects = 23;
pub const k_objects_K_OBJ_DRIVER_CHARGER: k_objects = 24;
pub const k_objects_K_OBJ_DRIVER_COREDUMP: k_objects = 25;
pub const k_objects_K_OBJ_DRIVER_COUNTER: k_objects = 26;
pub const k_objects_K_OBJ_DRIVER_DAC: k_objects = 27;
pub const k_objects_K_OBJ_DRIVER_DAI: k_objects = 28;
pub const k_objects_K_OBJ_DRIVER_DMA: k_objects = 29;
pub const k_objects_K_OBJ_DRIVER_EDAC: k_objects = 30;
pub const k_objects_K_OBJ_DRIVER_EEPROM: k_objects = 31;
pub const k_objects_K_OBJ_DRIVER_FUEL_GAUGE_EMUL: k_objects = 32;
pub const k_objects_K_OBJ_DRIVER_EMUL_SENSOR_BACKEND_API: k_objects = 33;
pub const k_objects_K_OBJ_DRIVER_ENTROPY: k_objects = 34;
pub const k_objects_K_OBJ_DRIVER_ESPI: k_objects = 35;
pub const k_objects_K_OBJ_DRIVER_ESPI_SAF: k_objects = 36;
pub const k_objects_K_OBJ_DRIVER_FLASH: k_objects = 37;
pub const k_objects_K_OBJ_DRIVER_FPGA: k_objects = 38;
pub const k_objects_K_OBJ_DRIVER_FUEL_GAUGE: k_objects = 39;
pub const k_objects_K_OBJ_DRIVER_GNSS: k_objects = 40;
pub const k_objects_K_OBJ_DRIVER_HWSPINLOCK: k_objects = 41;
pub const k_objects_K_OBJ_DRIVER_I2C: k_objects = 42;
pub const k_objects_K_OBJ_DRIVER_I2S: k_objects = 43;
pub const k_objects_K_OBJ_DRIVER_I3C: k_objects = 44;
pub const k_objects_K_OBJ_DRIVER_IPM: k_objects = 45;
pub const k_objects_K_OBJ_DRIVER_KSCAN: k_objects = 46;
pub const k_objects_K_OBJ_DRIVER_LED: k_objects = 47;
pub const k_objects_K_OBJ_DRIVER_MBOX: k_objects = 48;
pub const k_objects_K_OBJ_DRIVER_MDIO: k_objects = 49;
pub const k_objects_K_OBJ_DRIVER_MIPI_DSI: k_objects = 50;
pub const k_objects_K_OBJ_DRIVER_PECI: k_objects = 51;
pub const k_objects_K_OBJ_DRIVER_PS2: k_objects = 52;
pub const k_objects_K_OBJ_DRIVER_PTP_CLOCK: k_objects = 53;
pub const k_objects_K_OBJ_DRIVER_PWM: k_objects = 54;
pub const k_objects_K_OBJ_DRIVER_REGULATOR_PARENT: k_objects = 55;
pub const k_objects_K_OBJ_DRIVER_REGULATOR: k_objects = 56;
pub const k_objects_K_OBJ_DRIVER_RESET: k_objects = 57;
pub const k_objects_K_OBJ_DRIVER_RETAINED_MEM: k_objects = 58;
pub const k_objects_K_OBJ_DRIVER_RTC: k_objects = 59;
pub const k_objects_K_OBJ_DRIVER_SDHC: k_objects = 60;
pub const k_objects_K_OBJ_DRIVER_SENSOR: k_objects = 61;
pub const k_objects_K_OBJ_DRIVER_SMBUS: k_objects = 62;
pub const k_objects_K_OBJ_DRIVER_SPI: k_objects = 63;
pub const k_objects_K_OBJ_DRIVER_SYSCON: k_objects = 64;
pub const k_objects_K_OBJ_DRIVER_W1: k_objects = 65;
pub const k_objects_K_OBJ_DRIVER_WDT: k_objects = 66;
pub const k_objects_K_OBJ_DRIVER_CAN_TRANSCEIVER: k_objects = 67;
pub const k_objects_K_OBJ_DRIVER_UART_MUX: k_objects = 68;
pub const k_objects_K_OBJ_DRIVER_ITS: k_objects = 69;
pub const k_objects_K_OBJ_DRIVER_TGPIO: k_objects = 70;
pub const k_objects_K_OBJ_DRIVER_PCIE_CTRL: k_objects = 71;
pub const k_objects_K_OBJ_DRIVER_SVC: k_objects = 72;
pub const k_objects_K_OBJ_DRIVER_BC12_EMUL: k_objects = 73;
pub const k_objects_K_OBJ_DRIVER_BC12: k_objects = 74;
pub const k_objects_K_OBJ_DRIVER_TCPC: k_objects = 75;
pub const k_objects_K_OBJ_DRIVER_IVSHMEM: k_objects = 76;
pub const k_objects_K_OBJ_DRIVER_EC_HOST_CMD_BACKEND_API: k_objects = 77;
pub const k_objects_K_OBJ_DRIVER_ETHPHY: k_objects = 78;
#[doc = " @endcond"]
pub const k_objects_K_OBJ_LAST: k_objects = 79;
#[doc = " @brief Kernel Object Types\n\n This enumeration needs to be kept in sync with the lists of kernel objects\n and subsystems in scripts/build/gen_kobject_list.py, as well as the otype_to_str()\n function in kernel/userspace.c"]
pub type k_objects = cty::c_uint;
extern "C" {
    #[doc = " @internal"]
    #[link_name = "z_impl_k_object_access_grant__extern"]
    pub fn z_impl_k_object_access_grant(object: *const cty::c_void, thread: *mut k_thread);
}
extern "C" {
    #[doc = " @internal"]
    #[link_name = "k_object_access_revoke__extern"]
    pub fn k_object_access_revoke(object: *const cty::c_void, thread: *mut k_thread);
}
extern "C" {
    #[doc = " @internal"]
    #[link_name = "z_impl_k_object_release__extern"]
    pub fn z_impl_k_object_release(object: *const cty::c_void);
}
extern "C" {
    #[link_name = "k_object_access_all_grant__extern"]
    pub fn k_object_access_all_grant(object: *const cty::c_void);
}
extern "C" {
    #[link_name = "k_object_is_valid__extern"]
    pub fn k_object_is_valid(obj: *const cty::c_void, otype: k_objects) -> bool;
}
extern "C" {
    #[link_name = "z_impl_k_object_alloc__extern"]
    pub fn z_impl_k_object_alloc(otype: k_objects) -> *mut cty::c_void;
}
extern "C" {
    #[link_name = "z_impl_k_object_alloc_size__extern"]
    pub fn z_impl_k_object_alloc_size(otype: k_objects, size: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Free an object\n\n @param obj"]
    #[link_name = "k_object_free__extern"]
    pub fn k_object_free(obj: *mut cty::c_void);
}
extern "C" {
    #[link_name = "k_object_access_grant__extern"]
    pub fn k_object_access_grant(object: *const cty::c_void, thread: *mut k_thread);
}
extern "C" {
    #[link_name = "k_object_release__extern"]
    pub fn k_object_release(object: *const cty::c_void);
}
extern "C" {
    #[link_name = "k_object_alloc__extern"]
    pub fn k_object_alloc(otype: k_objects) -> *mut cty::c_void;
}
extern "C" {
    #[link_name = "k_object_alloc_size__extern"]
    pub fn k_object_alloc_size(otype: k_objects, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn z_init_cpu(id: cty::c_int);
}
extern "C" {
    pub fn z_sched_ipi();
}
extern "C" {
    pub fn z_smp_start_cpu(id: cty::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_futex {
    _unused: [u8; 0],
}
pub const execution_context_types_K_ISR: execution_context_types = 0;
pub const execution_context_types_K_COOP_THREAD: execution_context_types = 1;
pub const execution_context_types_K_PREEMPT_THREAD: execution_context_types = 2;
pub type execution_context_types = cty::c_uint;
pub type _poller_cb_t = ::core::option::Option<
    unsafe extern "C" fn(event: *mut k_poll_event, state: u32) -> cty::c_int,
>;
#[doc = " @addtogroup thread_apis\n @{"]
pub type k_thread_user_cb_t = ::core::option::Option<
    unsafe extern "C" fn(thread: *const k_thread, user_data: *mut cty::c_void),
>;
extern "C" {
    #[doc = " @brief Iterate over all the threads in the system.\n\n This routine iterates over all the threads in the system and\n calls the user_cb function for each thread.\n\n @param user_cb Pointer to the user callback function.\n @param user_data Pointer to user data.\n\n @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function\n to be effective.\n @note This API uses @ref k_spin_lock to protect the _kernel.threads\n list which means creation of new threads and terminations of existing\n threads are blocked until this API returns."]
    pub fn k_thread_foreach(user_cb: k_thread_user_cb_t, user_data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Iterate over all the threads in the system without locking.\n\n This routine works exactly the same like @ref k_thread_foreach\n but unlocks interrupts when user_cb is executed.\n\n @param user_cb Pointer to the user callback function.\n @param user_data Pointer to user data.\n\n @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function\n to be effective.\n @note This API uses @ref k_spin_lock only when accessing the _kernel.threads\n queue elements. It unlocks it during user callback function processing.\n If a new task is created when this @c foreach function is in progress,\n the added new task would not be included in the enumeration.\n If a task is aborted during this enumeration, there would be a race here\n and there is a possibility that this aborted task would be included in the\n enumeration.\n @note If the task is aborted and the memory occupied by its @c k_thread\n structure is reused when this @c k_thread_foreach_unlocked is in progress\n it might even lead to the system behave unstable.\n This function may never return, as it would follow some @c next task\n pointers treating given pointer as a pointer to the k_thread structure\n while it is something different right now.\n Do not reuse the memory that was occupied by k_thread structure of aborted\n task if it was aborted after this function was called in any context."]
    pub fn k_thread_foreach_unlocked(user_cb: k_thread_user_cb_t, user_data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Dynamically allocate a thread stack.\n\n Relevant stack creation flags include:\n - @ref K_USER allocate a userspace thread (requires `CONFIG_USERSPACE=y`)\n\n @param size Stack size in bytes.\n @param flags Stack creation flags, or 0.\n\n @retval the allocated thread stack on success.\n @retval NULL on failure.\n\n @see CONFIG_DYNAMIC_THREAD"]
    #[link_name = "k_thread_stack_alloc__extern"]
    pub fn k_thread_stack_alloc(size: usize, flags: cty::c_int) -> *mut k_thread_stack_t;
}
extern "C" {
    #[doc = " @brief Free a dynamically allocated thread stack.\n\n @param stack Pointer to the thread stack.\n\n @retval 0 on success.\n @retval -EBUSY if the thread stack is in use.\n @retval -EINVAL if @p stack is invalid.\n @retval -ENOSYS if dynamic thread stack allocation is disabled\n\n @see CONFIG_DYNAMIC_THREAD"]
    #[link_name = "k_thread_stack_free__extern"]
    pub fn k_thread_stack_free(stack: *mut k_thread_stack_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Create a thread.\n\n This routine initializes a thread, then schedules it for execution.\n\n The new thread may be scheduled for immediate execution or a delayed start.\n If the newly spawned thread does not have a delayed start the kernel\n scheduler may preempt the current thread to allow the new thread to\n execute.\n\n Thread options are architecture-specific, and can include K_ESSENTIAL,\n K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating\n them using \"|\" (the logical OR operator).\n\n Stack objects passed to this function must be originally defined with\n either of these macros in order to be portable:\n\n - K_THREAD_STACK_DEFINE() - For stacks that may support either user or\n   supervisor threads.\n - K_KERNEL_STACK_DEFINE() - For stacks that may support supervisor\n   threads only. These stacks use less memory if CONFIG_USERSPACE is\n   enabled.\n\n The stack_size parameter has constraints. It must either be:\n\n - The original size value passed to K_THREAD_STACK_DEFINE() or\n   K_KERNEL_STACK_DEFINE()\n - The return value of K_THREAD_STACK_SIZEOF(stack) if the stack was\n   defined with K_THREAD_STACK_DEFINE()\n - The return value of K_KERNEL_STACK_SIZEOF(stack) if the stack was\n   defined with K_KERNEL_STACK_DEFINE().\n\n Using other values, or sizeof(stack) may produce undefined behavior.\n\n @param new_thread Pointer to uninitialized struct k_thread\n @param stack Pointer to the stack space.\n @param stack_size Stack size in bytes.\n @param entry Thread entry function.\n @param p1 1st entry point parameter.\n @param p2 2nd entry point parameter.\n @param p3 3rd entry point parameter.\n @param prio Thread priority.\n @param options Thread options.\n @param delay Scheduling delay, or K_NO_WAIT (for no delay).\n\n @return ID of new thread.\n"]
    #[link_name = "k_thread_create__extern"]
    pub fn k_thread_create(
        new_thread: *mut k_thread,
        stack: *mut k_thread_stack_t,
        stack_size: usize,
        entry: k_thread_entry_t,
        p1: *mut cty::c_void,
        p2: *mut cty::c_void,
        p3: *mut cty::c_void,
        prio: cty::c_int,
        options: u32,
        delay: k_timeout_t,
    ) -> k_tid_t;
}
extern "C" {
    #[doc = " @brief Drop a thread's privileges permanently to user mode\n\n This allows a supervisor thread to be re-used as a user thread.\n This function does not return, but control will transfer to the provided\n entry point as if this was a new user thread.\n\n The implementation ensures that the stack buffer contents are erased.\n Any thread-local storage will be reverted to a pristine state.\n\n Memory domain membership, resource pool assignment, kernel object\n permissions, priority, and thread options are preserved.\n\n A common use of this function is to re-use the main thread as a user thread\n once all supervisor mode-only tasks have been completed.\n\n @param entry Function to start executing from\n @param p1 1st entry point parameter\n @param p2 2nd entry point parameter\n @param p3 3rd entry point parameter"]
    pub fn k_thread_user_mode_enter(
        entry: k_thread_entry_t,
        p1: *mut cty::c_void,
        p2: *mut cty::c_void,
        p3: *mut cty::c_void,
    ) -> !;
}
extern "C" {
    #[doc = " @brief Assign a resource memory pool to a thread\n\n By default, threads have no resource pool assigned unless their parent\n thread has a resource pool, in which case it is inherited. Multiple\n threads may be assigned to the same memory pool.\n\n Changing a thread's resource pool will not migrate allocations from the\n previous pool.\n\n @param thread Target thread to assign a memory pool for resource requests.\n @param heap Heap object to use for resources,\n             or NULL if the thread should no longer have a memory pool."]
    #[link_name = "k_thread_heap_assign__extern"]
    pub fn k_thread_heap_assign(thread: *mut k_thread, heap: *mut k_heap);
}
extern "C" {
    #[doc = " @brief Sleep until a thread exits\n\n The caller will be put to sleep until the target thread exits, either due\n to being aborted, self-exiting, or taking a fatal error. This API returns\n immediately if the thread isn't running.\n\n This API may only be called from ISRs with a K_NO_WAIT timeout,\n where it can be useful as a predicate to detect when a thread has\n aborted.\n\n @param thread Thread to wait to exit\n @param timeout upper bound time to wait for the thread to exit.\n @retval 0 success, target thread has exited or wasn't running\n @retval -EBUSY returned without waiting\n @retval -EAGAIN waiting period timed out\n @retval -EDEADLK target thread is joining on the caller, or target thread\n                  is the caller"]
    #[link_name = "k_thread_join__extern"]
    pub fn k_thread_join(thread: *mut k_thread, timeout: k_timeout_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Put the current thread to sleep.\n\n This routine puts the current thread to sleep for @a duration,\n specified as a k_timeout_t object.\n\n @note if @a timeout is set to K_FOREVER then the thread is suspended.\n\n @param timeout Desired duration of sleep.\n\n @return Zero if the requested time has elapsed or if the thread was woken up\n by the \\ref k_wakeup call, the time left to sleep rounded up to the nearest\n millisecond."]
    #[link_name = "k_sleep__extern"]
    pub fn k_sleep(timeout: k_timeout_t) -> i32;
}
extern "C" {
    #[doc = " @brief Put the current thread to sleep.\n\n This routine puts the current thread to sleep for @a duration milliseconds.\n\n @param ms Number of milliseconds to sleep.\n\n @return Zero if the requested time has elapsed or if the thread was woken up\n by the \\ref k_wakeup call, the time left to sleep rounded up to the nearest\n millisecond."]
    #[link_name = "k_msleep__extern"]
    pub fn k_msleep(ms: i32) -> i32;
}
extern "C" {
    #[doc = " @brief Put the current thread to sleep with microsecond resolution.\n\n This function is unlikely to work as expected without kernel tuning.\n In particular, because the lower bound on the duration of a sleep is\n the duration of a tick, @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} must be\n adjusted to achieve the resolution desired. The implications of doing\n this must be understood before attempting to use k_usleep(). Use with\n caution.\n\n @param us Number of microseconds to sleep.\n\n @return Zero if the requested time has elapsed or if the thread was woken up\n by the \\ref k_wakeup call, the time left to sleep rounded up to the nearest\n microsecond."]
    #[link_name = "k_usleep__extern"]
    pub fn k_usleep(us: i32) -> i32;
}
extern "C" {
    #[doc = " @brief Cause the current thread to busy wait.\n\n This routine causes the current thread to execute a \"do nothing\" loop for\n @a usec_to_wait microseconds.\n\n @note The clock used for the microsecond-resolution delay here may\n be skewed relative to the clock used for system timeouts like\n k_sleep().  For example k_busy_wait(1000) may take slightly more or\n less time than k_sleep(K_MSEC(1)), with the offset dependent on\n clock tolerances.\n\n @note In case when @kconfig{CONFIG_SYSTEM_CLOCK_SLOPPY_IDLE} and\n @kconfig{CONFIG_PM} options are enabled, this function may not work.\n The timer/clock used for delay processing may be disabled/inactive."]
    #[link_name = "k_busy_wait__extern"]
    pub fn k_busy_wait(usec_to_wait: u32);
}
extern "C" {
    #[doc = " @brief Check whether it is possible to yield in the current context.\n\n This routine checks whether the kernel is in a state where it is possible to\n yield or call blocking API's. It should be used by code that needs to yield\n to perform correctly, but can feasibly be called from contexts where that\n is not possible. For example in the PRE_KERNEL initialization step, or when\n being run from the idle thread.\n\n @return True if it is possible to yield in the current context, false otherwise."]
    pub fn k_can_yield() -> bool;
}
extern "C" {
    #[doc = " @brief Yield the current thread.\n\n This routine causes the current thread to yield execution to another\n thread of the same or higher priority. If there are no other ready threads\n of the same or higher priority, the routine returns immediately."]
    #[link_name = "k_yield__extern"]
    pub fn k_yield();
}
extern "C" {
    #[doc = " @brief Wake up a sleeping thread.\n\n This routine prematurely wakes up @a thread from sleeping.\n\n If @a thread is not currently sleeping, the routine has no effect.\n\n @param thread ID of thread to wake."]
    #[link_name = "k_wakeup__extern"]
    pub fn k_wakeup(thread: k_tid_t);
}
extern "C" {
    #[doc = " @brief Query thread ID of the current thread.\n\n This unconditionally queries the kernel via a system call.\n\n @note Use k_current_get() unless absolutely sure this is necessary.\n       This should only be used directly where the thread local\n       variable cannot be used or may contain invalid values\n       if thread local storage (TLS) is enabled. If TLS is not\n       enabled, this is the same as k_current_get().\n\n @return ID of current thread."]
    #[link_name = "k_sched_current_thread_query__extern"]
    pub fn k_sched_current_thread_query() -> k_tid_t;
}
extern "C" {
    #[doc = " @brief Get thread ID of the current thread.\n\n @return ID of current thread.\n"]
    #[link_name = "k_current_get__extern"]
    pub fn k_current_get() -> k_tid_t;
}
extern "C" {
    #[doc = " @brief Abort a thread.\n\n This routine permanently stops execution of @a thread. The thread is taken\n off all kernel queues it is part of (i.e. the ready queue, the timeout\n queue, or a kernel object wait queue). However, any kernel resources the\n thread might currently own (such as mutexes or memory blocks) are not\n released. It is the responsibility of the caller of this routine to ensure\n all necessary cleanup is performed.\n\n After k_thread_abort() returns, the thread is guaranteed not to be\n running or to become runnable anywhere on the system.  Normally\n this is done via blocking the caller (in the same manner as\n k_thread_join()), but in interrupt context on SMP systems the\n implementation is required to spin for threads that are running on\n other CPUs.\n\n @param thread ID of thread to abort."]
    #[link_name = "k_thread_abort__extern"]
    pub fn k_thread_abort(thread: k_tid_t);
}
extern "C" {
    #[doc = " @brief Start an inactive thread\n\n If a thread was created with K_FOREVER in the delay parameter, it will\n not be added to the scheduling queue until this function is called\n on it.\n\n @param thread thread to start"]
    #[link_name = "k_thread_start__extern"]
    pub fn k_thread_start(thread: k_tid_t);
}
extern "C" {
    pub fn z_timeout_expires(timeout: *const _timeout) -> k_ticks_t;
}
extern "C" {
    pub fn z_timeout_remaining(timeout: *const _timeout) -> k_ticks_t;
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _static_thread_data {
    pub init_thread: *mut k_thread,
    pub init_stack: *mut k_thread_stack_t,
    pub init_stack_size: cty::c_uint,
    pub init_entry: k_thread_entry_t,
    pub init_p1: *mut cty::c_void,
    pub init_p2: *mut cty::c_void,
    pub init_p3: *mut cty::c_void,
    pub init_prio: cty::c_int,
    pub init_options: u32,
    pub init_name: *const cty::c_char,
    pub init_delay: k_timeout_t,
}
#[test]
fn bindgen_test_layout__static_thread_data() {
    const UNINIT: ::core::mem::MaybeUninit<_static_thread_data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_static_thread_data>(),
        80usize,
        concat!("Size of: ", stringify!(_static_thread_data))
    );
    assert_eq!(
        ::core::mem::align_of::<_static_thread_data>(),
        8usize,
        concat!("Alignment of ", stringify!(_static_thread_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_stack_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_stack_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_entry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_p1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_p1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_p2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_p2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_p3) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_p3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_prio) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_prio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_options) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_delay) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_delay)
        )
    );
}
extern "C" {
    #[doc = " @brief Get a thread's priority.\n\n This routine gets the priority of @a thread.\n\n @param thread ID of thread whose priority is needed.\n\n @return Priority of @a thread."]
    #[link_name = "k_thread_priority_get__extern"]
    pub fn k_thread_priority_get(thread: k_tid_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set a thread's priority.\n\n This routine immediately changes the priority of @a thread.\n\n Rescheduling can occur immediately depending on the priority @a thread is\n set to:\n\n - If its priority is raised above the priority of the caller of this\n function, and the caller is preemptible, @a thread will be scheduled in.\n\n - If the caller operates on itself, it lowers its priority below that of\n other threads in the system, and the caller is preemptible, the thread of\n highest priority will be scheduled in.\n\n Priority can be assigned in the range of -CONFIG_NUM_COOP_PRIORITIES to\n CONFIG_NUM_PREEMPT_PRIORITIES-1, where -CONFIG_NUM_COOP_PRIORITIES is the\n highest priority.\n\n @param thread ID of thread whose priority is to be set.\n @param prio New priority.\n\n @warning Changing the priority of a thread currently involved in mutex\n priority inheritance may result in undefined behavior."]
    #[link_name = "k_thread_priority_set__extern"]
    pub fn k_thread_priority_set(thread: k_tid_t, prio: cty::c_int);
}
extern "C" {
    #[doc = " @brief Suspend a thread.\n\n This routine prevents the kernel scheduler from making @a thread\n the current thread. All other internal operations on @a thread are\n still performed; for example, kernel objects it is waiting on are\n still handed to it.  Note that any existing timeouts\n (e.g. k_sleep(), or a timeout argument to k_sem_take() et. al.)\n will be canceled.  On resume, the thread will begin running\n immediately and return from the blocked call.\n\n When the target thread is active on another CPU, the caller will block until\n the target thread is halted (suspended or aborted).  But if the caller is in\n an interrupt context, it will spin waiting for that target thread active on\n another CPU to halt.\n\n If @a thread is already suspended, the routine has no effect.\n\n @param thread ID of thread to suspend."]
    #[link_name = "k_thread_suspend__extern"]
    pub fn k_thread_suspend(thread: k_tid_t);
}
extern "C" {
    #[doc = " @brief Resume a suspended thread.\n\n This routine allows the kernel scheduler to make @a thread the current\n thread, when it is next eligible for that role.\n\n If @a thread is not currently suspended, the routine has no effect.\n\n @param thread ID of thread to resume."]
    #[link_name = "k_thread_resume__extern"]
    pub fn k_thread_resume(thread: k_tid_t);
}
extern "C" {
    #[doc = " @brief Set time-slicing period and scope.\n\n This routine specifies how the scheduler will perform time slicing of\n preemptible threads.\n\n To enable time slicing, @a slice must be non-zero. The scheduler\n ensures that no thread runs for more than the specified time limit\n before other threads of that priority are given a chance to execute.\n Any thread whose priority is higher than @a prio is exempted, and may\n execute as long as desired without being preempted due to time slicing.\n\n Time slicing only limits the maximum amount of time a thread may continuously\n execute. Once the scheduler selects a thread for execution, there is no\n minimum guaranteed time the thread will execute before threads of greater or\n equal priority are scheduled.\n\n When the current thread is the only one of that priority eligible\n for execution, this routine has no effect; the thread is immediately\n rescheduled after the slice period expires.\n\n To disable timeslicing, set both @a slice and @a prio to zero.\n\n @param slice Maximum time slice length (in milliseconds).\n @param prio Highest thread priority level eligible for time slicing."]
    pub fn k_sched_time_slice_set(slice: i32, prio: cty::c_int);
}
extern "C" {
    #[doc = " @brief Set thread time slice\n\n As for k_sched_time_slice_set, but (when\n CONFIG_TIMESLICE_PER_THREAD=y) sets the timeslice for a specific\n thread.  When non-zero, this timeslice will take precedence over\n the global value.\n\n When such a thread's timeslice expires, the configured callback\n will be called before the thread is removed/re-added to the run\n queue.  This callback will occur in interrupt context, and the\n specified thread is guaranteed to have been preempted by the\n currently-executing ISR.  Such a callback is free to, for example,\n modify the thread priority or slice time for future execution,\n suspend the thread, etc...\n\n @note Unlike the older API, the time slice parameter here is\n specified in ticks, not milliseconds.  Ticks have always been the\n internal unit, and not all platforms have integer conversions\n between the two.\n\n @note Threads with a non-zero slice time set will be timesliced\n always, even if they are higher priority than the maximum timeslice\n priority set via k_sched_time_slice_set().\n\n @note The callback notification for slice expiration happens, as it\n must, while the thread is still \"current\", and thus it happens\n before any registered timeouts at this tick.  This has the somewhat\n confusing side effect that the tick time (c.f. k_uptime_get()) does\n not yet reflect the expired ticks.  Applications wishing to make\n fine-grained timing decisions within this callback should use the\n cycle API, or derived facilities like k_thread_runtime_stats_get().\n\n @param th A valid, initialized thread\n @param slice_ticks Maximum timeslice, in ticks\n @param expired Callback function called on slice expiration\n @param data Parameter for the expiration handler"]
    pub fn k_thread_time_slice_set(
        th: *mut k_thread,
        slice_ticks: i32,
        expired: k_thread_timeslice_fn_t,
        data: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief Determine if code is running at interrupt level.\n\n This routine allows the caller to customize its actions, depending on\n whether it is a thread or an ISR.\n\n @funcprops \\isr_ok\n\n @return false if invoked by a thread.\n @return true if invoked by an ISR."]
    pub fn k_is_in_isr() -> bool;
}
extern "C" {
    #[doc = " @brief Determine if code is running in a preemptible thread.\n\n This routine allows the caller to customize its actions, depending on\n whether it can be preempted by another thread. The routine returns a 'true'\n value if all of the following conditions are met:\n\n - The code is running in a thread, not at ISR.\n - The thread's priority is in the preemptible range.\n - The thread has not locked the scheduler.\n\n @funcprops \\isr_ok\n\n @return 0 if invoked by an ISR or by a cooperative thread.\n @return Non-zero if invoked by a preemptible thread."]
    #[link_name = "k_is_preempt_thread__extern"]
    pub fn k_is_preempt_thread() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Test whether startup is in the before-main-task phase.\n\n This routine allows the caller to customize its actions, depending on\n whether it being invoked before the kernel is fully active.\n\n @funcprops \\isr_ok\n\n @return true if invoked before post-kernel initialization\n @return false if invoked during/after post-kernel initialization"]
    #[link_name = "k_is_pre_kernel__extern"]
    pub fn k_is_pre_kernel() -> bool;
}
extern "C" {
    #[doc = " @brief Lock the scheduler.\n\n This routine prevents the current thread from being preempted by another\n thread by instructing the scheduler to treat it as a cooperative thread.\n If the thread subsequently performs an operation that makes it unready,\n it will be context switched out in the normal manner. When the thread\n again becomes the current thread, its non-preemptible status is maintained.\n\n This routine can be called recursively.\n\n Owing to clever implementation details, scheduler locks are\n extremely fast for non-userspace threads (just one byte\n inc/decrement in the thread struct).\n\n @note This works by elevating the thread priority temporarily to a\n cooperative priority, allowing cheap synchronization vs. other\n preemptible or cooperative threads running on the current CPU.  It\n does not prevent preemption or asynchrony of other types.  It does\n not prevent threads from running on other CPUs when CONFIG_SMP=y.\n It does not prevent interrupts from happening, nor does it prevent\n threads with MetaIRQ priorities from preempting the current thread.\n In general this is a historical API not well-suited to modern\n applications, use with care."]
    pub fn k_sched_lock();
}
extern "C" {
    #[doc = " @brief Unlock the scheduler.\n\n This routine reverses the effect of a previous call to k_sched_lock().\n A thread must call the routine once for each time it called k_sched_lock()\n before the thread becomes preemptible."]
    pub fn k_sched_unlock();
}
extern "C" {
    #[doc = " @brief Set current thread's custom data.\n\n This routine sets the custom data for the current thread to @ value.\n\n Custom data is not used by the kernel itself, and is freely available\n for a thread to use as it sees fit. It can be used as a framework\n upon which to build thread-local storage.\n\n @param value New custom data value.\n"]
    #[link_name = "k_thread_custom_data_set__extern"]
    pub fn k_thread_custom_data_set(value: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Get current thread's custom data.\n\n This routine returns the custom data for the current thread.\n\n @return Current custom data value."]
    #[link_name = "k_thread_custom_data_get__extern"]
    pub fn k_thread_custom_data_get() -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Set current thread name\n\n Set the name of the thread to be used when @kconfig{CONFIG_THREAD_MONITOR}\n is enabled for tracing and debugging.\n\n @param thread Thread to set name, or NULL to set the current thread\n @param str Name string\n @retval 0 on success\n @retval -EFAULT Memory access error with supplied string\n @retval -ENOSYS Thread name configuration option not enabled\n @retval -EINVAL Thread name too long"]
    #[link_name = "k_thread_name_set__extern"]
    pub fn k_thread_name_set(thread: k_tid_t, str_: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get thread name\n\n Get the name of a thread\n\n @param thread Thread ID\n @retval Thread name, or NULL if configuration not enabled"]
    pub fn k_thread_name_get(thread: k_tid_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " @brief Copy the thread name into a supplied buffer\n\n @param thread Thread to obtain name information\n @param buf Destination buffer\n @param size Destination buffer size\n @retval -ENOSPC Destination buffer too small\n @retval -EFAULT Memory access error\n @retval -ENOSYS Thread name feature not enabled\n @retval 0 Success"]
    #[link_name = "k_thread_name_copy__extern"]
    pub fn k_thread_name_copy(thread: k_tid_t, buf: *mut cty::c_char, size: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get thread state string\n\n This routine generates a human friendly string containing the thread's\n state, and copies as much of it as possible into @a buf.\n\n @param thread_id Thread ID\n @param buf Buffer into which to copy state strings\n @param buf_size Size of the buffer\n\n @retval Pointer to @a buf if data was copied, else a pointer to \"\"."]
    pub fn k_thread_state_str(
        thread_id: k_tid_t,
        buf: *mut cty::c_char,
        buf_size: usize,
    ) -> *const cty::c_char;
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_timer {
    pub timeout: _timeout,
    pub wait_q: _wait_q_t,
    pub expiry_fn: ::core::option::Option<unsafe extern "C" fn(timer: *mut k_timer)>,
    pub stop_fn: ::core::option::Option<unsafe extern "C" fn(timer: *mut k_timer)>,
    pub period: k_timeout_t,
    pub status: u32,
    pub user_data: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_k_timer() {
    const UNINIT: ::core::mem::MaybeUninit<k_timer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_timer>(),
        80usize,
        concat!("Size of: ", stringify!(k_timer))
    );
    assert_eq!(
        ::core::mem::align_of::<k_timer>(),
        8usize,
        concat!("Alignment of ", stringify!(k_timer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expiry_fn) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(expiry_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop_fn) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(stop_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " @typedef k_timer_expiry_t\n @brief Timer expiry function type.\n\n A timer's expiry function is executed by the system clock interrupt handler\n each time the timer expires. The expiry function is optional, and is only\n invoked if the timer has been initialized with one.\n\n @param timer     Address of timer."]
pub type k_timer_expiry_t = ::core::option::Option<unsafe extern "C" fn(timer: *mut k_timer)>;
#[doc = " @typedef k_timer_stop_t\n @brief Timer stop function type.\n\n A timer's stop function is executed if the timer is stopped prematurely.\n The function runs in the context of call that stops the timer.  As\n k_timer_stop() can be invoked from an ISR, the stop function must be\n callable from interrupt context (isr-ok).\n\n The stop function is optional, and is only invoked if the timer has been\n initialized with one.\n\n @param timer     Address of timer."]
pub type k_timer_stop_t = ::core::option::Option<unsafe extern "C" fn(timer: *mut k_timer)>;
extern "C" {
    #[doc = " @brief Initialize a timer.\n\n This routine initializes a timer, prior to its first use.\n\n @param timer     Address of timer.\n @param expiry_fn Function to invoke each time the timer expires.\n @param stop_fn   Function to invoke if the timer is stopped while running."]
    pub fn k_timer_init(timer: *mut k_timer, expiry_fn: k_timer_expiry_t, stop_fn: k_timer_stop_t);
}
extern "C" {
    #[doc = " @brief Start a timer.\n\n This routine starts a timer, and resets its status to zero. The timer\n begins counting down using the specified duration and period values.\n\n Attempting to start a timer that is already running is permitted.\n The timer's status is reset to zero and the timer begins counting down\n using the new duration and period values.\n\n @param timer     Address of timer.\n @param duration  Initial timer duration.\n @param period    Timer period."]
    #[link_name = "k_timer_start__extern"]
    pub fn k_timer_start(timer: *mut k_timer, duration: k_timeout_t, period: k_timeout_t);
}
extern "C" {
    #[doc = " @brief Stop a timer.\n\n This routine stops a running timer prematurely. The timer's stop function,\n if one exists, is invoked by the caller.\n\n Attempting to stop a timer that is not running is permitted, but has no\n effect on the timer.\n\n @note The stop handler has to be callable from ISRs if @a k_timer_stop is to\n be called from ISRs.\n\n @funcprops \\isr_ok\n\n @param timer     Address of timer."]
    #[link_name = "k_timer_stop__extern"]
    pub fn k_timer_stop(timer: *mut k_timer);
}
extern "C" {
    #[doc = " @brief Read timer status.\n\n This routine reads the timer's status, which indicates the number of times\n it has expired since its status was last read.\n\n Calling this routine resets the timer's status to zero.\n\n @param timer     Address of timer.\n\n @return Timer status."]
    #[link_name = "k_timer_status_get__extern"]
    pub fn k_timer_status_get(timer: *mut k_timer) -> u32;
}
extern "C" {
    #[doc = " @brief Synchronize thread to timer expiration.\n\n This routine blocks the calling thread until the timer's status is non-zero\n (indicating that it has expired at least once since it was last examined)\n or the timer is stopped. If the timer status is already non-zero,\n or the timer is already stopped, the caller continues without waiting.\n\n Calling this routine resets the timer's status to zero.\n\n This routine must not be used by interrupt handlers, since they are not\n allowed to block.\n\n @param timer     Address of timer.\n\n @return Timer status."]
    #[link_name = "k_timer_status_sync__extern"]
    pub fn k_timer_status_sync(timer: *mut k_timer) -> u32;
}
extern "C" {
    #[doc = " @brief Associate user-specific data with a timer.\n\n This routine records the @a user_data with the @a timer, to be retrieved\n later.\n\n It can be used e.g. in a timer handler shared across multiple subsystems to\n retrieve data specific to the subsystem this timer is associated with.\n\n @param timer     Address of timer.\n @param user_data User data to associate with the timer."]
    #[link_name = "k_timer_user_data_set__extern"]
    pub fn k_timer_user_data_set(timer: *mut k_timer, user_data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @internal"]
    #[link_name = "z_impl_k_timer_user_data_set__extern"]
    pub fn z_impl_k_timer_user_data_set(timer: *mut k_timer, user_data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Retrieve the user-specific data from a timer.\n\n @param timer     Address of timer.\n\n @return The user data."]
    #[link_name = "k_timer_user_data_get__extern"]
    pub fn k_timer_user_data_get(timer: *const k_timer) -> *mut cty::c_void;
}
extern "C" {
    #[link_name = "z_impl_k_timer_user_data_get__extern"]
    pub fn z_impl_k_timer_user_data_get(timer: *const k_timer) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Get system uptime, in system ticks.\n\n This routine returns the elapsed time since the system booted, in\n ticks (c.f. @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC}), which is the\n fundamental unit of resolution of kernel timekeeping.\n\n @return Current uptime in ticks."]
    #[link_name = "k_uptime_ticks__extern"]
    pub fn k_uptime_ticks() -> i64;
}
extern "C" {
    #[doc = " @brief Get system uptime.\n\n This routine returns the elapsed time since the system booted,\n in milliseconds.\n\n @note\n    While this function returns time in milliseconds, it does\n    not mean it has millisecond resolution. The actual resolution depends on\n    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option.\n\n @return Current uptime in milliseconds."]
    #[link_name = "k_uptime_get__extern"]
    pub fn k_uptime_get() -> i64;
}
extern "C" {
    #[doc = " @brief Get system uptime (32-bit version).\n\n This routine returns the lower 32 bits of the system uptime in\n milliseconds.\n\n Because correct conversion requires full precision of the system\n clock there is no benefit to using this over k_uptime_get() unless\n you know the application will never run long enough for the system\n clock to approach 2^32 ticks.  Calls to this function may involve\n interrupt blocking and 64-bit math.\n\n @note\n    While this function returns time in milliseconds, it does\n    not mean it has millisecond resolution. The actual resolution depends on\n    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option\n\n @return The low 32 bits of the current uptime, in milliseconds."]
    #[link_name = "k_uptime_get_32__extern"]
    pub fn k_uptime_get_32() -> u32;
}
extern "C" {
    #[doc = " @brief Get elapsed time.\n\n This routine computes the elapsed time between the current system uptime\n and an earlier reference time, in milliseconds.\n\n @param reftime Pointer to a reference time, which is updated to the current\n                uptime upon return.\n\n @return Elapsed time."]
    #[link_name = "k_uptime_delta__extern"]
    pub fn k_uptime_delta(reftime: *mut i64) -> i64;
}
extern "C" {
    #[doc = " @brief Read the hardware clock.\n\n This routine returns the current time, as measured by the system's hardware\n clock.\n\n @return Current hardware clock up-counter (in cycles)."]
    #[link_name = "k_cycle_get_32__extern"]
    pub fn k_cycle_get_32() -> u32;
}
extern "C" {
    #[doc = " @brief Read the 64-bit hardware clock.\n\n This routine returns the current time in 64-bits, as measured by the\n system's hardware clock, if available.\n\n @see CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER\n\n @return Current hardware clock up-counter (in cycles)."]
    #[link_name = "k_cycle_get_64__extern"]
    pub fn k_cycle_get_64() -> u64;
}
#[doc = " @}"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_queue {
    pub data_q: sys_sflist_t,
    pub lock: k_spinlock,
    pub wait_q: _wait_q_t,
}
#[test]
fn bindgen_test_layout_k_queue() {
    const UNINIT: ::core::mem::MaybeUninit<k_queue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_queue>(),
        32usize,
        concat!("Size of: ", stringify!(k_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<k_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(k_queue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_queue),
            "::",
            stringify!(data_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_queue),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_queue),
            "::",
            stringify!(wait_q)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a queue.\n\n This routine initializes a queue object, prior to its first use.\n\n @param queue Address of the queue."]
    #[link_name = "k_queue_init__extern"]
    pub fn k_queue_init(queue: *mut k_queue);
}
extern "C" {
    #[doc = " @brief Cancel waiting on a queue.\n\n This routine causes first thread pending on @a queue, if any, to\n return from k_queue_get() call with NULL value (as if timeout expired).\n If the queue is being waited on by k_poll(), it will return with\n -EINTR and K_POLL_STATE_CANCELLED state (and per above, subsequent\n k_queue_get() will return NULL).\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue."]
    #[link_name = "k_queue_cancel_wait__extern"]
    pub fn k_queue_cancel_wait(queue: *mut k_queue);
}
extern "C" {
    #[doc = " @brief Append an element to the end of a queue.\n\n This routine appends a data item to @a queue. A queue data item must be\n aligned on a word boundary, and the first word of the item is reserved\n for the kernel's use.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param data Address of the data item."]
    pub fn k_queue_append(queue: *mut k_queue, data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Append an element to a queue.\n\n This routine appends a data item to @a queue. There is an implicit memory\n allocation to create an additional temporary bookkeeping data structure from\n the calling thread's resource pool, which is automatically freed when the\n item is removed. The data itself is not copied.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param data Address of the data item.\n\n @retval 0 on success\n @retval -ENOMEM if there isn't sufficient RAM in the caller's resource pool"]
    #[link_name = "k_queue_alloc_append__extern"]
    pub fn k_queue_alloc_append(queue: *mut k_queue, data: *mut cty::c_void) -> i32;
}
extern "C" {
    #[doc = " @brief Prepend an element to a queue.\n\n This routine prepends a data item to @a queue. A queue data item must be\n aligned on a word boundary, and the first word of the item is reserved\n for the kernel's use.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param data Address of the data item."]
    pub fn k_queue_prepend(queue: *mut k_queue, data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Prepend an element to a queue.\n\n This routine prepends a data item to @a queue. There is an implicit memory\n allocation to create an additional temporary bookkeeping data structure from\n the calling thread's resource pool, which is automatically freed when the\n item is removed. The data itself is not copied.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param data Address of the data item.\n\n @retval 0 on success\n @retval -ENOMEM if there isn't sufficient RAM in the caller's resource pool"]
    #[link_name = "k_queue_alloc_prepend__extern"]
    pub fn k_queue_alloc_prepend(queue: *mut k_queue, data: *mut cty::c_void) -> i32;
}
extern "C" {
    #[doc = " @brief Inserts an element to a queue.\n\n This routine inserts a data item to @a queue after previous item. A queue\n data item must be aligned on a word boundary, and the first word of\n the item is reserved for the kernel's use.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param prev Address of the previous data item.\n @param data Address of the data item."]
    pub fn k_queue_insert(queue: *mut k_queue, prev: *mut cty::c_void, data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Atomically append a list of elements to a queue.\n\n This routine adds a list of data items to @a queue in one operation.\n The data items must be in a singly-linked list, with the first word\n in each data item pointing to the next data item; the list must be\n NULL-terminated.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param head Pointer to first node in singly-linked list.\n @param tail Pointer to last node in singly-linked list.\n\n @retval 0 on success\n @retval -EINVAL on invalid supplied data\n"]
    pub fn k_queue_append_list(
        queue: *mut k_queue,
        head: *mut cty::c_void,
        tail: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Atomically add a list of elements to a queue.\n\n This routine adds a list of data items to @a queue in one operation.\n The data items must be in a singly-linked list implemented using a\n sys_slist_t object. Upon completion, the original list is empty.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param list Pointer to sys_slist_t object.\n\n @retval 0 on success\n @retval -EINVAL on invalid data"]
    pub fn k_queue_merge_slist(queue: *mut k_queue, list: *mut sys_slist_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get an element from a queue.\n\n This routine removes first data item from @a queue. The first word of the\n data item is reserved for the kernel's use.\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param timeout Non-negative waiting period to obtain a data item\n                or one of the special values K_NO_WAIT and\n                K_FOREVER.\n\n @return Address of the data item if successful; NULL if returned\n without waiting, or waiting period timed out."]
    #[link_name = "k_queue_get__extern"]
    pub fn k_queue_get(queue: *mut k_queue, timeout: k_timeout_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Remove an element from a queue.\n\n This routine removes data item from @a queue. The first word of the\n data item is reserved for the kernel's use. Removing elements from k_queue\n rely on sys_slist_find_and_remove which is not a constant time operation.\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param data Address of the data item.\n\n @return true if data item was removed"]
    pub fn k_queue_remove(queue: *mut k_queue, data: *mut cty::c_void) -> bool;
}
extern "C" {
    #[doc = " @brief Append an element to a queue only if it's not present already.\n\n This routine appends data item to @a queue. The first word of the data\n item is reserved for the kernel's use. Appending elements to k_queue\n relies on sys_slist_is_node_in_list which is not a constant time operation.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n @param data Address of the data item.\n\n @return true if data item was added, false if not"]
    pub fn k_queue_unique_append(queue: *mut k_queue, data: *mut cty::c_void) -> bool;
}
extern "C" {
    #[doc = " @brief Query a queue to see if it has data available.\n\n Note that the data might be already gone by the time this function returns\n if other threads are also trying to read from the queue.\n\n @funcprops \\isr_ok\n\n @param queue Address of the queue.\n\n @return Non-zero if the queue is empty.\n @return 0 if data is available."]
    #[link_name = "k_queue_is_empty__extern"]
    pub fn k_queue_is_empty(queue: *mut k_queue) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_k_queue_is_empty__extern"]
    pub fn z_impl_k_queue_is_empty(queue: *mut k_queue) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Peek element at the head of queue.\n\n Return element from the head of queue without removing it.\n\n @param queue Address of the queue.\n\n @return Head element, or NULL if queue is empty."]
    #[link_name = "k_queue_peek_head__extern"]
    pub fn k_queue_peek_head(queue: *mut k_queue) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Peek element at the tail of queue.\n\n Return element from the tail of queue without removing it.\n\n @param queue Address of the queue.\n\n @return Tail element, or NULL if queue is empty."]
    #[link_name = "k_queue_peek_tail__extern"]
    pub fn k_queue_peek_tail(queue: *mut k_queue) -> *mut cty::c_void;
}
#[doc = " Event Structure\n @ingroup event_apis"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_event {
    pub wait_q: _wait_q_t,
    pub events: u32,
    pub lock: k_spinlock,
}
#[test]
fn bindgen_test_layout_k_event() {
    const UNINIT: ::core::mem::MaybeUninit<k_event> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_event>(),
        24usize,
        concat!("Size of: ", stringify!(k_event))
    );
    assert_eq!(
        ::core::mem::align_of::<k_event>(),
        8usize,
        concat!("Alignment of ", stringify!(k_event))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_event),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_event),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_event),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize an event object\n\n This routine initializes an event object, prior to its first use.\n\n @param event Address of the event object."]
    #[link_name = "k_event_init__extern"]
    pub fn k_event_init(event: *mut k_event);
}
extern "C" {
    #[doc = " @brief Post one or more events to an event object\n\n This routine posts one or more events to an event object. All tasks waiting\n on the event object @a event whose waiting conditions become met by this\n posting immediately unpend.\n\n Posting differs from setting in that posted events are merged together with\n the current set of events tracked by the event object.\n\n @param event Address of the event object\n @param events Set of events to post to @a event\n\n @retval Previous value of the events in @a event"]
    #[link_name = "k_event_post__extern"]
    pub fn k_event_post(event: *mut k_event, events: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Set the events in an event object\n\n This routine sets the events stored in event object to the specified value.\n All tasks waiting on the event object @a event whose waiting conditions\n become met by this immediately unpend.\n\n Setting differs from posting in that set events replace the current set of\n events tracked by the event object.\n\n @param event Address of the event object\n @param events Set of events to set in @a event\n\n @retval Previous value of the events in @a event"]
    #[link_name = "k_event_set__extern"]
    pub fn k_event_set(event: *mut k_event, events: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Set or clear the events in an event object\n\n This routine sets the events stored in event object to the specified value.\n All tasks waiting on the event object @a event whose waiting conditions\n become met by this immediately unpend. Unlike @ref k_event_set, this routine\n allows specific event bits to be set and cleared as determined by the mask.\n\n @param event Address of the event object\n @param events Set of events to set/clear in @a event\n @param events_mask Mask to be applied to @a events\n\n @retval Previous value of the events in @a events_mask"]
    #[link_name = "k_event_set_masked__extern"]
    pub fn k_event_set_masked(event: *mut k_event, events: u32, events_mask: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Clear the events in an event object\n\n This routine clears (resets) the specified events stored in an event object.\n\n @param event Address of the event object\n @param events Set of events to clear in @a event\n\n @retval Previous value of the events in @a event"]
    #[link_name = "k_event_clear__extern"]
    pub fn k_event_clear(event: *mut k_event, events: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Wait for any of the specified events\n\n This routine waits on event object @a event until any of the specified\n events have been delivered to the event object, or the maximum wait time\n @a timeout has expired. A thread may wait on up to 32 distinctly numbered\n events that are expressed as bits in a single 32-bit word.\n\n @note The caller must be careful when resetting if there are multiple threads\n waiting for the event object @a event.\n\n @param event Address of the event object\n @param events Set of desired events on which to wait\n @param reset If true, clear the set of events tracked by the event object\n              before waiting. If false, do not clear the events.\n @param timeout Waiting period for the desired set of events or one of the\n                special values K_NO_WAIT and K_FOREVER.\n\n @retval set of matching events upon success\n @retval 0 if matching events were not received within the specified time"]
    #[link_name = "k_event_wait__extern"]
    pub fn k_event_wait(event: *mut k_event, events: u32, reset: bool, timeout: k_timeout_t)
        -> u32;
}
extern "C" {
    #[doc = " @brief Wait for all of the specified events\n\n This routine waits on event object @a event until all of the specified\n events have been delivered to the event object, or the maximum wait time\n @a timeout has expired. A thread may wait on up to 32 distinctly numbered\n events that are expressed as bits in a single 32-bit word.\n\n @note The caller must be careful when resetting if there are multiple threads\n waiting for the event object @a event.\n\n @param event Address of the event object\n @param events Set of desired events on which to wait\n @param reset If true, clear the set of events tracked by the event object\n              before waiting. If false, do not clear the events.\n @param timeout Waiting period for the desired set of events or one of the\n                special values K_NO_WAIT and K_FOREVER.\n\n @retval set of matching events upon success\n @retval 0 if matching events were not received within the specified time"]
    #[link_name = "k_event_wait_all__extern"]
    pub fn k_event_wait_all(
        event: *mut k_event,
        events: u32,
        reset: bool,
        timeout: k_timeout_t,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Test the events currently tracked in the event object\n\n @param event Address of the event object\n @param events_mask Set of desired events to test\n\n @retval Current value of events in @a events_mask"]
    #[link_name = "k_event_test__extern"]
    pub fn k_event_test(event: *mut k_event, events_mask: u32) -> u32;
}
#[doc = " @}"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_fifo {
    pub _queue: k_queue,
}
#[test]
fn bindgen_test_layout_k_fifo() {
    const UNINIT: ::core::mem::MaybeUninit<k_fifo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_fifo>(),
        32usize,
        concat!("Size of: ", stringify!(k_fifo))
    );
    assert_eq!(
        ::core::mem::align_of::<k_fifo>(),
        8usize,
        concat!("Alignment of ", stringify!(k_fifo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_fifo),
            "::",
            stringify!(_queue)
        )
    );
}
#[doc = " @}"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_lifo {
    pub _queue: k_queue,
}
#[test]
fn bindgen_test_layout_k_lifo() {
    const UNINIT: ::core::mem::MaybeUninit<k_lifo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_lifo>(),
        32usize,
        concat!("Size of: ", stringify!(k_lifo))
    );
    assert_eq!(
        ::core::mem::align_of::<k_lifo>(),
        8usize,
        concat!("Alignment of ", stringify!(k_lifo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_lifo),
            "::",
            stringify!(_queue)
        )
    );
}
pub type stack_data_t = usize;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_stack {
    pub wait_q: _wait_q_t,
    pub lock: k_spinlock,
    pub base: *mut stack_data_t,
    pub next: *mut stack_data_t,
    pub top: *mut stack_data_t,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_k_stack() {
    const UNINIT: ::core::mem::MaybeUninit<k_stack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_stack>(),
        48usize,
        concat!("Size of: ", stringify!(k_stack))
    );
    assert_eq!(
        ::core::mem::align_of::<k_stack>(),
        8usize,
        concat!("Alignment of ", stringify!(k_stack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a stack.\n\n This routine initializes a stack object, prior to its first use.\n\n @param stack Address of the stack.\n @param buffer Address of array used to hold stacked values.\n @param num_entries Maximum number of values that can be stacked."]
    pub fn k_stack_init(stack: *mut k_stack, buffer: *mut stack_data_t, num_entries: u32);
}
extern "C" {
    #[doc = " @brief Initialize a stack.\n\n This routine initializes a stack object, prior to its first use. Internal\n buffers will be allocated from the calling thread's resource pool.\n This memory will be released if k_stack_cleanup() is called, or\n userspace is enabled and the stack object loses all references to it.\n\n @param stack Address of the stack.\n @param num_entries Maximum number of values that can be stacked.\n\n @return -ENOMEM if memory couldn't be allocated"]
    #[link_name = "k_stack_alloc_init__extern"]
    pub fn k_stack_alloc_init(stack: *mut k_stack, num_entries: u32) -> i32;
}
extern "C" {
    #[doc = " @brief Release a stack's allocated buffer\n\n If a stack object was given a dynamically allocated buffer via\n k_stack_alloc_init(), this will free it. This function does nothing\n if the buffer wasn't dynamically allocated.\n\n @param stack Address of the stack.\n @retval 0 on success\n @retval -EAGAIN when object is still in use"]
    pub fn k_stack_cleanup(stack: *mut k_stack) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Push an element onto a stack.\n\n This routine adds a stack_data_t value @a data to @a stack.\n\n @funcprops \\isr_ok\n\n @param stack Address of the stack.\n @param data Value to push onto the stack.\n\n @retval 0 on success\n @retval -ENOMEM if stack is full"]
    #[link_name = "k_stack_push__extern"]
    pub fn k_stack_push(stack: *mut k_stack, data: stack_data_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Pop an element from a stack.\n\n This routine removes a stack_data_t value from @a stack in a \"last in,\n first out\" manner and stores the value in @a data.\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n\n @funcprops \\isr_ok\n\n @param stack Address of the stack.\n @param data Address of area to hold the value popped from the stack.\n @param timeout Waiting period to obtain a value,\n                or one of the special values K_NO_WAIT and\n                K_FOREVER.\n\n @retval 0 Element popped from stack.\n @retval -EBUSY Returned without waiting.\n @retval -EAGAIN Waiting period timed out."]
    #[link_name = "k_stack_pop__extern"]
    pub fn k_stack_pop(
        stack: *mut k_stack,
        data: *mut stack_data_t,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
#[doc = " @brief A structure used to hold work until it can be processed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_work_q {
    pub thread: k_thread,
    pub pending: sys_slist_t,
    pub notifyq: _wait_q_t,
    pub drainq: _wait_q_t,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_k_work_q() {
    const UNINIT: ::core::mem::MaybeUninit<k_work_q> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work_q>(),
        248usize,
        concat!("Size of: ", stringify!(k_work_q))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_q>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_q))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_q),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_q),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notifyq) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_q),
            "::",
            stringify!(notifyq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drainq) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_q),
            "::",
            stringify!(drainq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_q),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub static mut k_sys_work_q: k_work_q;
}
#[doc = " Mutex Structure\n @ingroup mutex_apis"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_mutex {
    #[doc = " Mutex wait queue"]
    pub wait_q: _wait_q_t,
    #[doc = " Mutex owner"]
    pub owner: *mut k_thread,
    #[doc = " Current lock count"]
    pub lock_count: u32,
    #[doc = " Original thread priority"]
    pub owner_orig_prio: cty::c_int,
}
#[test]
fn bindgen_test_layout_k_mutex() {
    const UNINIT: ::core::mem::MaybeUninit<k_mutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_mutex>(),
        32usize,
        concat!("Size of: ", stringify!(k_mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(k_mutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(lock_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner_orig_prio) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(owner_orig_prio)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a mutex.\n\n This routine initializes a mutex object, prior to its first use.\n\n Upon completion, the mutex is available and does not have an owner.\n\n @param mutex Address of the mutex.\n\n @retval 0 Mutex object created\n"]
    #[link_name = "k_mutex_init__extern"]
    pub fn k_mutex_init(mutex: *mut k_mutex) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Lock a mutex.\n\n This routine locks @a mutex. If the mutex is locked by another thread,\n the calling thread waits until the mutex becomes available or until\n a timeout occurs.\n\n A thread is permitted to lock a mutex it has already locked. The operation\n completes immediately and the lock count is increased by 1.\n\n Mutexes may not be locked in ISRs.\n\n @param mutex Address of the mutex.\n @param timeout Waiting period to lock the mutex,\n                or one of the special values K_NO_WAIT and\n                K_FOREVER.\n\n @retval 0 Mutex locked.\n @retval -EBUSY Returned without waiting.\n @retval -EAGAIN Waiting period timed out."]
    #[link_name = "k_mutex_lock__extern"]
    pub fn k_mutex_lock(mutex: *mut k_mutex, timeout: k_timeout_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Unlock a mutex.\n\n This routine unlocks @a mutex. The mutex must already be locked by the\n calling thread.\n\n The mutex cannot be claimed by another thread until it has been unlocked by\n the calling thread as many times as it was previously locked by that\n thread.\n\n Mutexes may not be unlocked in ISRs, as mutexes must only be manipulated\n in thread context due to ownership and priority inheritance semantics.\n\n @param mutex Address of the mutex.\n\n @retval 0 Mutex unlocked.\n @retval -EPERM The current thread does not own the mutex\n @retval -EINVAL The mutex is not locked\n"]
    #[link_name = "k_mutex_unlock__extern"]
    pub fn k_mutex_unlock(mutex: *mut k_mutex) -> cty::c_int;
}
#[doc = " @}"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_condvar {
    pub wait_q: _wait_q_t,
}
#[test]
fn bindgen_test_layout_k_condvar() {
    const UNINIT: ::core::mem::MaybeUninit<k_condvar> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_condvar>(),
        16usize,
        concat!("Size of: ", stringify!(k_condvar))
    );
    assert_eq!(
        ::core::mem::align_of::<k_condvar>(),
        8usize,
        concat!("Alignment of ", stringify!(k_condvar))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_condvar),
            "::",
            stringify!(wait_q)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a condition variable\n\n @param condvar pointer to a @p k_condvar structure\n @retval 0 Condition variable created successfully"]
    #[link_name = "k_condvar_init__extern"]
    pub fn k_condvar_init(condvar: *mut k_condvar) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Signals one thread that is pending on the condition variable\n\n @param condvar pointer to a @p k_condvar structure\n @retval 0 On success"]
    #[link_name = "k_condvar_signal__extern"]
    pub fn k_condvar_signal(condvar: *mut k_condvar) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Unblock all threads that are pending on the condition\n variable\n\n @param condvar pointer to a @p k_condvar structure\n @return An integer with number of woken threads on success"]
    #[link_name = "k_condvar_broadcast__extern"]
    pub fn k_condvar_broadcast(condvar: *mut k_condvar) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Waits on the condition variable releasing the mutex lock\n\n Atomically releases the currently owned mutex, blocks the current thread\n waiting on the condition variable specified by @a condvar,\n and finally acquires the mutex again.\n\n The waiting thread unblocks only after another thread calls\n k_condvar_signal, or k_condvar_broadcast with the same condition variable.\n\n @param condvar pointer to a @p k_condvar structure\n @param mutex Address of the mutex.\n @param timeout Waiting period for the condition variable\n                or one of the special values K_NO_WAIT and K_FOREVER.\n @retval 0 On success\n @retval -EAGAIN Waiting period timed out."]
    #[link_name = "k_condvar_wait__extern"]
    pub fn k_condvar_wait(
        condvar: *mut k_condvar,
        mutex: *mut k_mutex,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_sem {
    pub wait_q: _wait_q_t,
    pub count: cty::c_uint,
    pub limit: cty::c_uint,
}
#[test]
fn bindgen_test_layout_k_sem() {
    const UNINIT: ::core::mem::MaybeUninit<k_sem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_sem>(),
        24usize,
        concat!("Size of: ", stringify!(k_sem))
    );
    assert_eq!(
        ::core::mem::align_of::<k_sem>(),
        8usize,
        concat!("Alignment of ", stringify!(k_sem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sem),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sem),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sem),
            "::",
            stringify!(limit)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a semaphore.\n\n This routine initializes a semaphore object, prior to its first use.\n\n @param sem Address of the semaphore.\n @param initial_count Initial semaphore count.\n @param limit Maximum permitted semaphore count.\n\n @see K_SEM_MAX_LIMIT\n\n @retval 0 Semaphore created successfully\n @retval -EINVAL Invalid values\n"]
    #[link_name = "k_sem_init__extern"]
    pub fn k_sem_init(
        sem: *mut k_sem,
        initial_count: cty::c_uint,
        limit: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Take a semaphore.\n\n This routine takes @a sem.\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n\n @funcprops \\isr_ok\n\n @param sem Address of the semaphore.\n @param timeout Waiting period to take the semaphore,\n                or one of the special values K_NO_WAIT and K_FOREVER.\n\n @retval 0 Semaphore taken.\n @retval -EBUSY Returned without waiting.\n @retval -EAGAIN Waiting period timed out,\n\t\t\tor the semaphore was reset during the waiting period."]
    #[link_name = "k_sem_take__extern"]
    pub fn k_sem_take(sem: *mut k_sem, timeout: k_timeout_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Give a semaphore.\n\n This routine gives @a sem, unless the semaphore is already at its maximum\n permitted count.\n\n @funcprops \\isr_ok\n\n @param sem Address of the semaphore."]
    #[link_name = "k_sem_give__extern"]
    pub fn k_sem_give(sem: *mut k_sem);
}
extern "C" {
    #[doc = " @brief Resets a semaphore's count to zero.\n\n This routine sets the count of @a sem to zero.\n Any outstanding semaphore takes will be aborted\n with -EAGAIN.\n\n @param sem Address of the semaphore."]
    #[link_name = "k_sem_reset__extern"]
    pub fn k_sem_reset(sem: *mut k_sem);
}
extern "C" {
    #[doc = " @brief Get a semaphore's count.\n\n This routine returns the current count of @a sem.\n\n @param sem Address of the semaphore.\n\n @return Current semaphore count."]
    #[link_name = "k_sem_count_get__extern"]
    pub fn k_sem_count_get(sem: *mut k_sem) -> cty::c_uint;
}
extern "C" {
    #[doc = " @internal"]
    #[link_name = "z_impl_k_sem_count_get__extern"]
    pub fn z_impl_k_sem_count_get(sem: *mut k_sem) -> cty::c_uint;
}
#[doc = " @brief The signature for a work item handler function.\n\n The function will be invoked by the thread animating a work queue.\n\n @param work the work item that provided the handler."]
pub type k_work_handler_t = ::core::option::Option<unsafe extern "C" fn(work: *mut k_work)>;
extern "C" {
    #[doc = " @brief Initialize a (non-delayable) work structure.\n\n This must be invoked before submitting a work structure for the first time.\n It need not be invoked again on the same work structure.  It can be\n re-invoked to change the associated handler, but this must be done when the\n work item is idle.\n\n @funcprops \\isr_ok\n\n @param work the work structure to be initialized.\n\n @param handler the handler to be invoked by the work item."]
    pub fn k_work_init(work: *mut k_work, handler: k_work_handler_t);
}
extern "C" {
    #[doc = " @brief Busy state flags from the work item.\n\n A zero return value indicates the work item appears to be idle.\n\n @note This is a live snapshot of state, which may change before the result\n is checked.  Use locks where appropriate.\n\n @funcprops \\isr_ok\n\n @param work pointer to the work item.\n\n @return a mask of flags K_WORK_DELAYED, K_WORK_QUEUED,\n K_WORK_RUNNING, and K_WORK_CANCELING."]
    pub fn k_work_busy_get(work: *const k_work) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Test whether a work item is currently pending.\n\n Wrapper to determine whether a work item is in a non-idle dstate.\n\n @note This is a live snapshot of state, which may change before the result\n is checked.  Use locks where appropriate.\n\n @funcprops \\isr_ok\n\n @param work pointer to the work item.\n\n @return true if and only if k_work_busy_get() returns a non-zero value."]
    #[link_name = "k_work_is_pending__extern"]
    pub fn k_work_is_pending(work: *const k_work) -> bool;
}
extern "C" {
    #[doc = " @brief Submit a work item to a queue.\n\n @param queue pointer to the work queue on which the item should run.  If\n NULL the queue from the most recent submission will be used.\n\n @funcprops \\isr_ok\n\n @param work pointer to the work item.\n\n @retval 0 if work was already submitted to a queue\n @retval 1 if work was not submitted and has been queued to @p queue\n @retval 2 if work was running and has been queued to the queue that was\n running it\n @retval -EBUSY\n * if work submission was rejected because the work item is cancelling; or\n * @p queue is draining; or\n * @p queue is plugged.\n @retval -EINVAL if @p queue is null and the work item has never been run.\n @retval -ENODEV if @p queue has not been started."]
    pub fn k_work_submit_to_queue(queue: *mut k_work_q, work: *mut k_work) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Submit a work item to the system queue.\n\n @funcprops \\isr_ok\n\n @param work pointer to the work item.\n\n @return as with k_work_submit_to_queue()."]
    pub fn k_work_submit(work: *mut k_work) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Wait for last-submitted instance to complete.\n\n Resubmissions may occur while waiting, including chained submissions (from\n within the handler).\n\n @note Be careful of caller and work queue thread relative priority.  If\n this function sleeps it will not return until the work queue thread\n completes the tasks that allow this thread to resume.\n\n @note Behavior is undefined if this function is invoked on @p work from a\n work queue running @p work.\n\n @param work pointer to the work item.\n\n @param sync pointer to an opaque item containing state related to the\n pending cancellation.  The object must persist until the call returns, and\n be accessible from both the caller thread and the work queue thread.  The\n object must not be used for any other flush or cancel operation until this\n one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n must be allocated in coherent memory.\n\n @retval true if call had to wait for completion\n @retval false if work was already idle"]
    pub fn k_work_flush(work: *mut k_work, sync: *mut k_work_sync) -> bool;
}
extern "C" {
    #[doc = " @brief Cancel a work item.\n\n This attempts to prevent a pending (non-delayable) work item from being\n processed by removing it from the work queue.  If the item is being\n processed, the work item will continue to be processed, but resubmissions\n are rejected until cancellation completes.\n\n If this returns zero cancellation is complete, otherwise something\n (probably a work queue thread) is still referencing the item.\n\n See also k_work_cancel_sync().\n\n @funcprops \\isr_ok\n\n @param work pointer to the work item.\n\n @return the k_work_busy_get() status indicating the state of the item after all\n cancellation steps performed by this call are completed."]
    pub fn k_work_cancel(work: *mut k_work) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Cancel a work item and wait for it to complete.\n\n Same as k_work_cancel() but does not return until cancellation is complete.\n This can be invoked by a thread after k_work_cancel() to synchronize with a\n previous cancellation.\n\n On return the work structure will be idle unless something submits it after\n the cancellation was complete.\n\n @note Be careful of caller and work queue thread relative priority.  If\n this function sleeps it will not return until the work queue thread\n completes the tasks that allow this thread to resume.\n\n @note Behavior is undefined if this function is invoked on @p work from a\n work queue running @p work.\n\n @param work pointer to the work item.\n\n @param sync pointer to an opaque item containing state related to the\n pending cancellation.  The object must persist until the call returns, and\n be accessible from both the caller thread and the work queue thread.  The\n object must not be used for any other flush or cancel operation until this\n one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n must be allocated in coherent memory.\n\n @retval true if work was pending (call had to wait for cancellation of a\n running handler to complete, or scheduled or submitted operations were\n cancelled);\n @retval false otherwise"]
    pub fn k_work_cancel_sync(work: *mut k_work, sync: *mut k_work_sync) -> bool;
}
extern "C" {
    #[doc = " @brief Initialize a work queue structure.\n\n This must be invoked before starting a work queue structure for the first time.\n It need not be invoked again on the same work queue structure.\n\n @funcprops \\isr_ok\n\n @param queue the queue structure to be initialized."]
    pub fn k_work_queue_init(queue: *mut k_work_q);
}
extern "C" {
    #[doc = " @brief Initialize a work queue.\n\n This configures the work queue thread and starts it running.  The function\n should not be re-invoked on a queue.\n\n @param queue pointer to the queue structure. It must be initialized\n        in zeroed/bss memory or with @ref k_work_queue_init before\n        use.\n\n @param stack pointer to the work thread stack area.\n\n @param stack_size size of the the work thread stack area, in bytes.\n\n @param prio initial thread priority\n\n @param cfg optional additional configuration parameters.  Pass @c\n NULL if not required, to use the defaults documented in\n k_work_queue_config."]
    pub fn k_work_queue_start(
        queue: *mut k_work_q,
        stack: *mut k_thread_stack_t,
        stack_size: usize,
        prio: cty::c_int,
        cfg: *const k_work_queue_config,
    );
}
extern "C" {
    #[doc = " @brief Access the thread that animates a work queue.\n\n This is necessary to grant a work queue thread access to things the work\n items it will process are expected to use.\n\n @param queue pointer to the queue structure.\n\n @return the thread associated with the work queue."]
    #[link_name = "k_work_queue_thread_get__extern"]
    pub fn k_work_queue_thread_get(queue: *mut k_work_q) -> k_tid_t;
}
extern "C" {
    #[doc = " @brief Wait until the work queue has drained, optionally plugging it.\n\n This blocks submission to the work queue except when coming from queue\n thread, and blocks the caller until no more work items are available in the\n queue.\n\n If @p plug is true then submission will continue to be blocked after the\n drain operation completes until k_work_queue_unplug() is invoked.\n\n Note that work items that are delayed are not yet associated with their\n work queue.  They must be cancelled externally if a goal is to ensure the\n work queue remains empty.  The @p plug feature can be used to prevent\n delayed items from being submitted after the drain completes.\n\n @param queue pointer to the queue structure.\n\n @param plug if true the work queue will continue to block new submissions\n after all items have drained.\n\n @retval 1 if call had to wait for the drain to complete\n @retval 0 if call did not have to wait\n @retval negative if wait was interrupted or failed"]
    pub fn k_work_queue_drain(queue: *mut k_work_q, plug: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Release a work queue to accept new submissions.\n\n This releases the block on new submissions placed when k_work_queue_drain()\n is invoked with the @p plug option enabled.  If this is invoked before the\n drain completes new items may be submitted as soon as the drain completes.\n\n @funcprops \\isr_ok\n\n @param queue pointer to the queue structure.\n\n @retval 0 if successfully unplugged\n @retval -EALREADY if the work queue was not plugged."]
    pub fn k_work_queue_unplug(queue: *mut k_work_q) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Initialize a delayable work structure.\n\n This must be invoked before scheduling a delayable work structure for the\n first time.  It need not be invoked again on the same work structure.  It\n can be re-invoked to change the associated handler, but this must be done\n when the work item is idle.\n\n @funcprops \\isr_ok\n\n @param dwork the delayable work structure to be initialized.\n\n @param handler the handler to be invoked by the work item."]
    pub fn k_work_init_delayable(dwork: *mut k_work_delayable, handler: k_work_handler_t);
}
extern "C" {
    #[doc = " @brief Get the parent delayable work structure from a work pointer.\n\n This function is necessary when a @c k_work_handler_t function is passed to\n k_work_schedule_for_queue() and the handler needs to access data from the\n container of the containing `k_work_delayable`.\n\n @param work Address passed to the work handler\n\n @return Address of the containing @c k_work_delayable structure."]
    #[link_name = "k_work_delayable_from_work__extern"]
    pub fn k_work_delayable_from_work(work: *mut k_work) -> *mut k_work_delayable;
}
extern "C" {
    #[doc = " @brief Busy state flags from the delayable work item.\n\n @funcprops \\isr_ok\n\n @note This is a live snapshot of state, which may change before the result\n can be inspected.  Use locks where appropriate.\n\n @param dwork pointer to the delayable work item.\n\n @return a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, and\n K_WORK_CANCELING.  A zero return value indicates the work item appears to\n be idle."]
    pub fn k_work_delayable_busy_get(dwork: *const k_work_delayable) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Test whether a delayed work item is currently pending.\n\n Wrapper to determine whether a delayed work item is in a non-idle state.\n\n @note This is a live snapshot of state, which may change before the result\n can be inspected.  Use locks where appropriate.\n\n @funcprops \\isr_ok\n\n @param dwork pointer to the delayable work item.\n\n @return true if and only if k_work_delayable_busy_get() returns a non-zero\n value."]
    #[link_name = "k_work_delayable_is_pending__extern"]
    pub fn k_work_delayable_is_pending(dwork: *const k_work_delayable) -> bool;
}
extern "C" {
    #[doc = " @brief Get the absolute tick count at which a scheduled delayable work\n will be submitted.\n\n @note This is a live snapshot of state, which may change before the result\n can be inspected.  Use locks where appropriate.\n\n @funcprops \\isr_ok\n\n @param dwork pointer to the delayable work item.\n\n @return the tick count when the timer that will schedule the work item will\n expire, or the current tick count if the work is not scheduled."]
    #[link_name = "k_work_delayable_expires_get__extern"]
    pub fn k_work_delayable_expires_get(dwork: *const k_work_delayable) -> k_ticks_t;
}
extern "C" {
    #[doc = " @brief Get the number of ticks until a scheduled delayable work will be\n submitted.\n\n @note This is a live snapshot of state, which may change before the result\n can be inspected.  Use locks where appropriate.\n\n @funcprops \\isr_ok\n\n @param dwork pointer to the delayable work item.\n\n @return the number of ticks until the timer that will schedule the work\n item will expire, or zero if the item is not scheduled."]
    #[link_name = "k_work_delayable_remaining_get__extern"]
    pub fn k_work_delayable_remaining_get(dwork: *const k_work_delayable) -> k_ticks_t;
}
extern "C" {
    #[doc = " @brief Submit an idle work item to a queue after a delay.\n\n Unlike k_work_reschedule_for_queue() this is a no-op if the work item is\n already scheduled or submitted, even if @p delay is @c K_NO_WAIT.\n\n @funcprops \\isr_ok\n\n @param queue the queue on which the work item should be submitted after the\n delay.\n\n @param dwork pointer to the delayable work item.\n\n @param delay the time to wait before submitting the work item.  If @c\n K_NO_WAIT and the work is not pending this is equivalent to\n k_work_submit_to_queue().\n\n @retval 0 if work was already scheduled or submitted.\n @retval 1 if work has been scheduled.\n @retval -EBUSY if @p delay is @c K_NO_WAIT and\n         k_work_submit_to_queue() fails with this code.\n @retval -EINVAL if @p delay is @c K_NO_WAIT and\n         k_work_submit_to_queue() fails with this code.\n @retval -ENODEV if @p delay is @c K_NO_WAIT and\n         k_work_submit_to_queue() fails with this code."]
    pub fn k_work_schedule_for_queue(
        queue: *mut k_work_q,
        dwork: *mut k_work_delayable,
        delay: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Submit an idle work item to the system work queue after a\n delay.\n\n This is a thin wrapper around k_work_schedule_for_queue(), with all the API\n characteristics of that function.\n\n @param dwork pointer to the delayable work item.\n\n @param delay the time to wait before submitting the work item.  If @c\n K_NO_WAIT this is equivalent to k_work_submit_to_queue().\n\n @return as with k_work_schedule_for_queue()."]
    pub fn k_work_schedule(dwork: *mut k_work_delayable, delay: k_timeout_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Reschedule a work item to a queue after a delay.\n\n Unlike k_work_schedule_for_queue() this function can change the deadline of\n a scheduled work item, and will schedule a work item that is in any state\n (e.g. is idle, submitted, or running).  This function does not affect\n (\"unsubmit\") a work item that has been submitted to a queue.\n\n @funcprops \\isr_ok\n\n @param queue the queue on which the work item should be submitted after the\n delay.\n\n @param dwork pointer to the delayable work item.\n\n @param delay the time to wait before submitting the work item.  If @c\n K_NO_WAIT this is equivalent to k_work_submit_to_queue() after canceling\n any previous scheduled submission.\n\n @note If delay is @c K_NO_WAIT (\"no delay\") the return values are as with\n k_work_submit_to_queue().\n\n @retval 0 if delay is @c K_NO_WAIT and work was already on a queue\n @retval 1 if\n * delay is @c K_NO_WAIT and work was not submitted but has now been queued\n   to @p queue; or\n * delay not @c K_NO_WAIT and work has been scheduled\n @retval 2 if delay is @c K_NO_WAIT and work was running and has been queued\n to the queue that was running it\n @retval -EBUSY if @p delay is @c K_NO_WAIT and\n         k_work_submit_to_queue() fails with this code.\n @retval -EINVAL if @p delay is @c K_NO_WAIT and\n         k_work_submit_to_queue() fails with this code.\n @retval -ENODEV if @p delay is @c K_NO_WAIT and\n         k_work_submit_to_queue() fails with this code."]
    pub fn k_work_reschedule_for_queue(
        queue: *mut k_work_q,
        dwork: *mut k_work_delayable,
        delay: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Reschedule a work item to the system work queue after a\n delay.\n\n This is a thin wrapper around k_work_reschedule_for_queue(), with all the\n API characteristics of that function.\n\n @param dwork pointer to the delayable work item.\n\n @param delay the time to wait before submitting the work item.\n\n @return as with k_work_reschedule_for_queue()."]
    pub fn k_work_reschedule(dwork: *mut k_work_delayable, delay: k_timeout_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Flush delayable work.\n\n If the work is scheduled, it is immediately submitted.  Then the caller\n blocks until the work completes, as with k_work_flush().\n\n @note Be careful of caller and work queue thread relative priority.  If\n this function sleeps it will not return until the work queue thread\n completes the tasks that allow this thread to resume.\n\n @note Behavior is undefined if this function is invoked on @p dwork from a\n work queue running @p dwork.\n\n @param dwork pointer to the delayable work item.\n\n @param sync pointer to an opaque item containing state related to the\n pending cancellation.  The object must persist until the call returns, and\n be accessible from both the caller thread and the work queue thread.  The\n object must not be used for any other flush or cancel operation until this\n one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n must be allocated in coherent memory.\n\n @retval true if call had to wait for completion\n @retval false if work was already idle"]
    pub fn k_work_flush_delayable(dwork: *mut k_work_delayable, sync: *mut k_work_sync) -> bool;
}
extern "C" {
    #[doc = " @brief Cancel delayable work.\n\n Similar to k_work_cancel() but for delayable work.  If the work is\n scheduled or submitted it is canceled.  This function does not wait for the\n cancellation to complete.\n\n @note The work may still be running when this returns.  Use\n k_work_flush_delayable() or k_work_cancel_delayable_sync() to ensure it is\n not running.\n\n @note Canceling delayable work does not prevent rescheduling it.  It does\n prevent submitting it until the cancellation completes.\n\n @funcprops \\isr_ok\n\n @param dwork pointer to the delayable work item.\n\n @return the k_work_delayable_busy_get() status indicating the state of the\n item after all cancellation steps performed by this call are completed."]
    pub fn k_work_cancel_delayable(dwork: *mut k_work_delayable) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Cancel delayable work and wait.\n\n Like k_work_cancel_delayable() but waits until the work becomes idle.\n\n @note Canceling delayable work does not prevent rescheduling it.  It does\n prevent submitting it until the cancellation completes.\n\n @note Be careful of caller and work queue thread relative priority.  If\n this function sleeps it will not return until the work queue thread\n completes the tasks that allow this thread to resume.\n\n @note Behavior is undefined if this function is invoked on @p dwork from a\n work queue running @p dwork.\n\n @param dwork pointer to the delayable work item.\n\n @param sync pointer to an opaque item containing state related to the\n pending cancellation.  The object must persist until the call returns, and\n be accessible from both the caller thread and the work queue thread.  The\n object must not be used for any other flush or cancel operation until this\n one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object\n must be allocated in coherent memory.\n\n @retval true if work was not idle (call had to wait for cancellation of a\n running handler to complete, or scheduled or submitted operations were\n cancelled);\n @retval false otherwise"]
    pub fn k_work_cancel_delayable_sync(
        dwork: *mut k_work_delayable,
        sync: *mut k_work_sync,
    ) -> bool;
}
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_RUNNING_BIT: _bindgen_ty_1 = 0;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_CANCELING_BIT: _bindgen_ty_1 = 1;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUED_BIT: _bindgen_ty_1 = 2;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_DELAYED_BIT: _bindgen_ty_1 = 3;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_MASK: _bindgen_ty_1 = 15;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_DELAYABLE_BIT: _bindgen_ty_1 = 8;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_DELAYABLE: _bindgen_ty_1 = 256;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_STARTED_BIT: _bindgen_ty_1 = 0;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_STARTED: _bindgen_ty_1 = 1;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_BUSY_BIT: _bindgen_ty_1 = 1;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_BUSY: _bindgen_ty_1 = 2;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_DRAIN_BIT: _bindgen_ty_1 = 2;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_DRAIN: _bindgen_ty_1 = 4;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_PLUGGED_BIT: _bindgen_ty_1 = 3;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_PLUGGED: _bindgen_ty_1 = 8;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_NO_YIELD_BIT: _bindgen_ty_1 = 8;
#[doc = " @cond INTERNAL_HIDDEN"]
pub const K_WORK_QUEUE_NO_YIELD: _bindgen_ty_1 = 256;
#[doc = " @brief Flag indicating a work item that is running under a work\n queue thread.\n\n Accessed via k_work_busy_get().  May co-occur with other flags."]
pub const K_WORK_RUNNING: _bindgen_ty_1 = 1;
#[doc = " @brief Flag indicating a work item that is being canceled.\n\n Accessed via k_work_busy_get().  May co-occur with other flags."]
pub const K_WORK_CANCELING: _bindgen_ty_1 = 2;
#[doc = " @brief Flag indicating a work item that has been submitted to a\n queue but has not started running.\n\n Accessed via k_work_busy_get().  May co-occur with other flags."]
pub const K_WORK_QUEUED: _bindgen_ty_1 = 4;
#[doc = " @brief Flag indicating a delayed work item that is scheduled for\n submission to a queue.\n\n Accessed via k_work_busy_get().  May co-occur with other flags."]
pub const K_WORK_DELAYED: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = cty::c_uint;
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_work {
    pub node: sys_snode_t,
    pub handler: k_work_handler_t,
    pub queue: *mut k_work_q,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_k_work() {
    const UNINIT: ::core::mem::MaybeUninit<k_work> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work>(),
        32usize,
        concat!("Size of: ", stringify!(k_work))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_work_delayable {
    pub work: k_work,
    pub timeout: _timeout,
    pub queue: *mut k_work_q,
}
#[test]
fn bindgen_test_layout_k_work_delayable() {
    const UNINIT: ::core::mem::MaybeUninit<k_work_delayable> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work_delayable>(),
        72usize,
        concat!("Size of: ", stringify!(k_work_delayable))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_delayable>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_delayable))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_delayable),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_delayable),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_delayable),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_work_flusher {
    pub work: k_work,
    pub sem: k_sem,
}
#[test]
fn bindgen_test_layout_z_work_flusher() {
    const UNINIT: ::core::mem::MaybeUninit<z_work_flusher> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_work_flusher>(),
        56usize,
        concat!("Size of: ", stringify!(z_work_flusher))
    );
    assert_eq!(
        ::core::mem::align_of::<z_work_flusher>(),
        8usize,
        concat!("Alignment of ", stringify!(z_work_flusher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_work_flusher),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(z_work_flusher),
            "::",
            stringify!(sem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_work_canceller {
    pub node: sys_snode_t,
    pub work: *mut k_work,
    pub sem: k_sem,
}
#[test]
fn bindgen_test_layout_z_work_canceller() {
    const UNINIT: ::core::mem::MaybeUninit<z_work_canceller> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<z_work_canceller>(),
        40usize,
        concat!("Size of: ", stringify!(z_work_canceller))
    );
    assert_eq!(
        ::core::mem::align_of::<z_work_canceller>(),
        8usize,
        concat!("Alignment of ", stringify!(z_work_canceller))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_work_canceller),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(z_work_canceller),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(z_work_canceller),
            "::",
            stringify!(sem)
        )
    );
}
#[doc = " @brief A structure holding internal state for a pending synchronous\n operation on a work item or queue.\n\n Instances of this type are provided by the caller for invocation of\n k_work_flush(), k_work_cancel_sync() and sibling flush and cancel APIs.  A\n referenced object must persist until the call returns, and be accessible\n from both the caller thread and the work queue thread.\n\n @note If CONFIG_KERNEL_COHERENCE is enabled the object must be allocated in\n coherent memory; see arch_mem_coherent().  The stack on these architectures\n is generally not coherent.  be stack-allocated.  Violations are detected by\n runtime assertion."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_work_sync {
    pub __bindgen_anon_1: k_work_sync__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_work_sync__bindgen_ty_1 {
    pub flusher: z_work_flusher,
    pub canceller: z_work_canceller,
}
#[test]
fn bindgen_test_layout_k_work_sync__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<k_work_sync__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work_sync__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(k_work_sync__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_sync__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_sync__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flusher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_sync__bindgen_ty_1),
            "::",
            stringify!(flusher)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).canceller) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_sync__bindgen_ty_1),
            "::",
            stringify!(canceller)
        )
    );
}
#[test]
fn bindgen_test_layout_k_work_sync() {
    assert_eq!(
        ::core::mem::size_of::<k_work_sync>(),
        56usize,
        concat!("Size of: ", stringify!(k_work_sync))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_sync>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_sync))
    );
}
#[doc = " @brief A structure holding optional configuration items for a work\n queue.\n\n This structure, and values it references, are not retained by\n k_work_queue_start()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_work_queue_config {
    #[doc = " The name to be given to the work queue thread.\n\n If left null the thread will not have a name."]
    pub name: *const cty::c_char,
    #[doc = " Control whether the work queue thread should yield between\n items.\n\n Yielding between items helps guarantee the work queue\n thread does not starve other threads, including cooperative\n ones released by a work item.  This is the default behavior.\n\n Set this to @c true to prevent the work queue thread from\n yielding between items.  This may be appropriate when a\n sequence of items should complete without yielding\n control."]
    pub no_yield: bool,
}
#[test]
fn bindgen_test_layout_k_work_queue_config() {
    const UNINIT: ::core::mem::MaybeUninit<k_work_queue_config> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work_queue_config>(),
        16usize,
        concat!("Size of: ", stringify!(k_work_queue_config))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_queue_config>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_queue_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_queue_config),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_yield) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_queue_config),
            "::",
            stringify!(no_yield)
        )
    );
}
#[doc = " @typedef k_work_user_handler_t\n @brief Work item handler function type for user work queues.\n\n A work item's handler function is executed by a user workqueue's thread\n when the work item is processed by the workqueue.\n\n @param work Address of the work item."]
pub type k_work_user_handler_t =
    ::core::option::Option<unsafe extern "C" fn(work: *mut k_work_user)>;
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_work_user_q {
    pub queue: k_queue,
    pub thread: k_thread,
}
#[test]
fn bindgen_test_layout_k_work_user_q() {
    const UNINIT: ::core::mem::MaybeUninit<k_work_user_q> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work_user_q>(),
        224usize,
        concat!("Size of: ", stringify!(k_work_user_q))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_user_q>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_user_q))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_user_q),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_user_q),
            "::",
            stringify!(thread)
        )
    );
}
pub const K_WORK_USER_STATE_PENDING: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = cty::c_uint;
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_work_user {
    pub _reserved: *mut cty::c_void,
    pub handler: k_work_user_handler_t,
    pub flags: atomic_t,
}
#[test]
fn bindgen_test_layout_k_work_user() {
    const UNINIT: ::core::mem::MaybeUninit<k_work_user> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work_user>(),
        24usize,
        concat!("Size of: ", stringify!(k_work_user))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_user>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_user))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_user),
            "::",
            stringify!(_reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_user),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_user),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a userspace work item.\n\n This routine initializes a user workqueue work item, prior to its\n first use.\n\n @param work Address of work item.\n @param handler Function to invoke each time work item is processed."]
    #[link_name = "k_work_user_init__extern"]
    pub fn k_work_user_init(work: *mut k_work_user, handler: k_work_user_handler_t);
}
extern "C" {
    #[doc = " @brief Check if a userspace work item is pending.\n\n This routine indicates if user work item @a work is pending in a workqueue's\n queue.\n\n @note Checking if the work is pending gives no guarantee that the\n       work will still be pending when this information is used. It is up to\n       the caller to make sure that this information is used in a safe manner.\n\n @funcprops \\isr_ok\n\n @param work Address of work item.\n\n @return true if work item is pending, or false if it is not pending."]
    #[link_name = "k_work_user_is_pending__extern"]
    pub fn k_work_user_is_pending(work: *mut k_work_user) -> bool;
}
extern "C" {
    #[doc = " @brief Submit a work item to a user mode workqueue\n\n Submits a work item to a workqueue that runs in user mode. A temporary\n memory allocation is made from the caller's resource pool which is freed\n once the worker thread consumes the k_work item. The workqueue\n thread must have memory access to the k_work item being submitted. The caller\n must have permission granted on the work_q parameter's queue object.\n\n @funcprops \\isr_ok\n\n @param work_q Address of workqueue.\n @param work Address of work item.\n\n @retval -EBUSY if the work item was already in some workqueue\n @retval -ENOMEM if no memory for thread resource pool allocation\n @retval 0 Success"]
    #[link_name = "k_work_user_submit_to_queue__extern"]
    pub fn k_work_user_submit_to_queue(
        work_q: *mut k_work_user_q,
        work: *mut k_work_user,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Start a workqueue in user mode\n\n This works identically to k_work_queue_start() except it is callable from\n user mode, and the worker thread created will run in user mode.  The caller\n must have permissions granted on both the work_q parameter's thread and\n queue objects, and the same restrictions on priority apply as\n k_thread_create().\n\n @param work_q Address of workqueue.\n @param stack Pointer to work queue thread's stack space, as defined by\n\t\tK_THREAD_STACK_DEFINE()\n @param stack_size Size of the work queue thread's stack (in bytes), which\n\t\tshould either be the same constant passed to\n\t\tK_THREAD_STACK_DEFINE() or the value of K_THREAD_STACK_SIZEOF().\n @param prio Priority of the work queue's thread.\n @param name optional thread name.  If not null a copy is made into the\n\t\tthread's name buffer."]
    pub fn k_work_user_queue_start(
        work_q: *mut k_work_user_q,
        stack: *mut k_thread_stack_t,
        stack_size: usize,
        prio: cty::c_int,
        name: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " @brief Access the user mode thread that animates a work queue.\n\n This is necessary to grant a user mode work queue thread access to things\n the work items it will process are expected to use.\n\n @param work_q pointer to the user mode queue structure.\n\n @return the user mode thread associated with the work queue."]
    #[link_name = "k_work_user_queue_thread_get__extern"]
    pub fn k_work_user_queue_thread_get(work_q: *mut k_work_user_q) -> k_tid_t;
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_work_poll {
    pub work: k_work,
    pub workq: *mut k_work_q,
    pub poller: z_poller,
    pub events: *mut k_poll_event,
    pub num_events: cty::c_int,
    pub real_handler: k_work_handler_t,
    pub timeout: _timeout,
    pub poll_result: cty::c_int,
}
#[test]
fn bindgen_test_layout_k_work_poll() {
    const UNINIT: ::core::mem::MaybeUninit<k_work_poll> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_work_poll>(),
        112usize,
        concat!("Size of: ", stringify!(k_work_poll))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_poll>(),
        8usize,
        concat!("Alignment of ", stringify!(k_work_poll))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).workq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(workq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poller) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(poller)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_events) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(num_events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real_handler) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(real_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_result) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_poll),
            "::",
            stringify!(poll_result)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a triggered work item.\n\n This routine initializes a workqueue triggered work item, prior to\n its first use.\n\n @param work Address of triggered work item.\n @param handler Function to invoke each time work item is processed."]
    pub fn k_work_poll_init(work: *mut k_work_poll, handler: k_work_handler_t);
}
extern "C" {
    #[doc = " @brief Submit a triggered work item.\n\n This routine schedules work item @a work to be processed by workqueue\n @a work_q when one of the given @a events is signaled. The routine\n initiates internal poller for the work item and then returns to the caller.\n Only when one of the watched events happen the work item is actually\n submitted to the workqueue and becomes pending.\n\n Submitting a previously submitted triggered work item that is still\n waiting for the event cancels the existing submission and reschedules it\n the using the new event list. Note that this behavior is inherently subject\n to race conditions with the pre-existing triggered work item and work queue,\n so care must be taken to synchronize such resubmissions externally.\n\n @funcprops \\isr_ok\n\n @warning\n Provided array of events as well as a triggered work item must be placed\n in persistent memory (valid until work handler execution or work\n cancellation) and cannot be modified after submission.\n\n @param work_q Address of workqueue.\n @param work Address of delayed work item.\n @param events An array of events which trigger the work.\n @param num_events The number of events in the array.\n @param timeout Timeout after which the work will be scheduled\n\t\t  for execution even if not triggered.\n\n\n @retval 0 Work item started watching for events.\n @retval -EINVAL Work item is being processed or has completed its work.\n @retval -EADDRINUSE Work item is pending on a different workqueue."]
    pub fn k_work_poll_submit_to_queue(
        work_q: *mut k_work_q,
        work: *mut k_work_poll,
        events: *mut k_poll_event,
        num_events: cty::c_int,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Submit a triggered work item to the system workqueue.\n\n This routine schedules work item @a work to be processed by system\n workqueue when one of the given @a events is signaled. The routine\n initiates internal poller for the work item and then returns to the caller.\n Only when one of the watched events happen the work item is actually\n submitted to the workqueue and becomes pending.\n\n Submitting a previously submitted triggered work item that is still\n waiting for the event cancels the existing submission and reschedules it\n the using the new event list. Note that this behavior is inherently subject\n to race conditions with the pre-existing triggered work item and work queue,\n so care must be taken to synchronize such resubmissions externally.\n\n @funcprops \\isr_ok\n\n @warning\n Provided array of events as well as a triggered work item must not be\n modified until the item has been processed by the workqueue.\n\n @param work Address of delayed work item.\n @param events An array of events which trigger the work.\n @param num_events The number of events in the array.\n @param timeout Timeout after which the work will be scheduled\n\t\t  for execution even if not triggered.\n\n @retval 0 Work item started watching for events.\n @retval -EINVAL Work item is being processed or has completed its work.\n @retval -EADDRINUSE Work item is pending on a different workqueue."]
    pub fn k_work_poll_submit(
        work: *mut k_work_poll,
        events: *mut k_poll_event,
        num_events: cty::c_int,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Cancel a triggered work item.\n\n This routine cancels the submission of triggered work item @a work.\n A triggered work item can only be canceled if no event triggered work\n submission.\n\n @funcprops \\isr_ok\n\n @param work Address of delayed work item.\n\n @retval 0 Work item canceled.\n @retval -EINVAL Work item is being processed or has completed its work."]
    pub fn k_work_poll_cancel(work: *mut k_work_poll) -> cty::c_int;
}
#[doc = " @brief Message Queue Structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_msgq {
    #[doc = " Message queue wait queue"]
    pub wait_q: _wait_q_t,
    #[doc = " Lock"]
    pub lock: k_spinlock,
    #[doc = " Message size"]
    pub msg_size: usize,
    #[doc = " Maximal number of messages"]
    pub max_msgs: u32,
    #[doc = " Start of message buffer"]
    pub buffer_start: *mut cty::c_char,
    #[doc = " End of message buffer"]
    pub buffer_end: *mut cty::c_char,
    #[doc = " Read pointer"]
    pub read_ptr: *mut cty::c_char,
    #[doc = " Write pointer"]
    pub write_ptr: *mut cty::c_char,
    #[doc = " Number of used messages"]
    pub used_msgs: u32,
    #[doc = " Message queue"]
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_k_msgq() {
    const UNINIT: ::core::mem::MaybeUninit<k_msgq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_msgq>(),
        72usize,
        concat!("Size of: ", stringify!(k_msgq))
    );
    assert_eq!(
        ::core::mem::align_of::<k_msgq>(),
        8usize,
        concat!("Alignment of ", stringify!(k_msgq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_msgs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(max_msgs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(buffer_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_end) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(buffer_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_ptr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_ptr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used_msgs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(used_msgs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief Message Queue Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_msgq_attrs {
    #[doc = " Message Size"]
    pub msg_size: usize,
    #[doc = " Maximal number of messages"]
    pub max_msgs: u32,
    #[doc = " Used messages"]
    pub used_msgs: u32,
}
#[test]
fn bindgen_test_layout_k_msgq_attrs() {
    const UNINIT: ::core::mem::MaybeUninit<k_msgq_attrs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_msgq_attrs>(),
        16usize,
        concat!("Size of: ", stringify!(k_msgq_attrs))
    );
    assert_eq!(
        ::core::mem::align_of::<k_msgq_attrs>(),
        8usize,
        concat!("Alignment of ", stringify!(k_msgq_attrs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq_attrs),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_msgs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq_attrs),
            "::",
            stringify!(max_msgs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used_msgs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq_attrs),
            "::",
            stringify!(used_msgs)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a message queue.\n\n This routine initializes a message queue object, prior to its first use.\n\n The message queue's ring buffer must contain space for @a max_msgs messages,\n each of which is @a msg_size bytes long. Alignment of the message queue's\n ring buffer is not necessary.\n\n @param msgq Address of the message queue.\n @param buffer Pointer to ring buffer that holds queued messages.\n @param msg_size Message size (in bytes).\n @param max_msgs Maximum number of messages that can be queued."]
    pub fn k_msgq_init(msgq: *mut k_msgq, buffer: *mut cty::c_char, msg_size: usize, max_msgs: u32);
}
extern "C" {
    #[doc = " @brief Initialize a message queue.\n\n This routine initializes a message queue object, prior to its first use,\n allocating its internal ring buffer from the calling thread's resource\n pool.\n\n Memory allocated for the ring buffer can be released by calling\n k_msgq_cleanup(), or if userspace is enabled and the msgq object loses\n all of its references.\n\n @param msgq Address of the message queue.\n @param msg_size Message size (in bytes).\n @param max_msgs Maximum number of messages that can be queued.\n\n @return 0 on success, -ENOMEM if there was insufficient memory in the\n\tthread's resource pool, or -EINVAL if the size parameters cause\n\tan integer overflow."]
    #[link_name = "k_msgq_alloc_init__extern"]
    pub fn k_msgq_alloc_init(msgq: *mut k_msgq, msg_size: usize, max_msgs: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Release allocated buffer for a queue\n\n Releases memory allocated for the ring buffer.\n\n @param msgq message queue to cleanup\n\n @retval 0 on success\n @retval -EBUSY Queue not empty"]
    pub fn k_msgq_cleanup(msgq: *mut k_msgq) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Send a message to a message queue.\n\n This routine sends a message to message queue @a q.\n\n @note The message content is copied from @a data into @a msgq and the @a data\n pointer is not retained, so the message content will not be modified\n by this function.\n\n @funcprops \\isr_ok\n\n @param msgq Address of the message queue.\n @param data Pointer to the message.\n @param timeout Non-negative waiting period to add the message,\n                or one of the special values K_NO_WAIT and\n                K_FOREVER.\n\n @retval 0 Message sent.\n @retval -ENOMSG Returned without waiting or queue purged.\n @retval -EAGAIN Waiting period timed out."]
    #[link_name = "k_msgq_put__extern"]
    pub fn k_msgq_put(
        msgq: *mut k_msgq,
        data: *const cty::c_void,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Receive a message from a message queue.\n\n This routine receives a message from message queue @a q in a \"first in,\n first out\" manner.\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n\n @funcprops \\isr_ok\n\n @param msgq Address of the message queue.\n @param data Address of area to hold the received message.\n @param timeout Waiting period to receive the message,\n                or one of the special values K_NO_WAIT and\n                K_FOREVER.\n\n @retval 0 Message received.\n @retval -ENOMSG Returned without waiting.\n @retval -EAGAIN Waiting period timed out."]
    #[link_name = "k_msgq_get__extern"]
    pub fn k_msgq_get(
        msgq: *mut k_msgq,
        data: *mut cty::c_void,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Peek/read a message from a message queue.\n\n This routine reads a message from message queue @a q in a \"first in,\n first out\" manner and leaves the message in the queue.\n\n @funcprops \\isr_ok\n\n @param msgq Address of the message queue.\n @param data Address of area to hold the message read from the queue.\n\n @retval 0 Message read.\n @retval -ENOMSG Returned when the queue has no message."]
    #[link_name = "k_msgq_peek__extern"]
    pub fn k_msgq_peek(msgq: *mut k_msgq, data: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Peek/read a message from a message queue at the specified index\n\n This routine reads a message from message queue at the specified index\n and leaves the message in the queue.\n k_msgq_peek_at(msgq, data, 0) is equivalent to k_msgq_peek(msgq, data)\n\n @funcprops \\isr_ok\n\n @param msgq Address of the message queue.\n @param data Address of area to hold the message read from the queue.\n @param idx Message queue index at which to peek\n\n @retval 0 Message read.\n @retval -ENOMSG Returned when the queue has no message at index."]
    #[link_name = "k_msgq_peek_at__extern"]
    pub fn k_msgq_peek_at(msgq: *mut k_msgq, data: *mut cty::c_void, idx: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Purge a message queue.\n\n This routine discards all unreceived messages in a message queue's ring\n buffer. Any threads that are blocked waiting to send a message to the\n message queue are unblocked and see an -ENOMSG error code.\n\n @param msgq Address of the message queue."]
    #[link_name = "k_msgq_purge__extern"]
    pub fn k_msgq_purge(msgq: *mut k_msgq);
}
extern "C" {
    #[doc = " @brief Get the amount of free space in a message queue.\n\n This routine returns the number of unused entries in a message queue's\n ring buffer.\n\n @param msgq Address of the message queue.\n\n @return Number of unused ring buffer entries."]
    #[link_name = "k_msgq_num_free_get__extern"]
    pub fn k_msgq_num_free_get(msgq: *mut k_msgq) -> u32;
}
extern "C" {
    #[doc = " @brief Get basic attributes of a message queue.\n\n This routine fetches basic attributes of message queue into attr argument.\n\n @param msgq Address of the message queue.\n @param attrs pointer to message queue attribute structure."]
    #[link_name = "k_msgq_get_attrs__extern"]
    pub fn k_msgq_get_attrs(msgq: *mut k_msgq, attrs: *mut k_msgq_attrs);
}
extern "C" {
    #[link_name = "z_impl_k_msgq_num_free_get__extern"]
    pub fn z_impl_k_msgq_num_free_get(msgq: *mut k_msgq) -> u32;
}
extern "C" {
    #[doc = " @brief Get the number of messages in a message queue.\n\n This routine returns the number of messages in a message queue's ring buffer.\n\n @param msgq Address of the message queue.\n\n @return Number of messages."]
    #[link_name = "k_msgq_num_used_get__extern"]
    pub fn k_msgq_num_used_get(msgq: *mut k_msgq) -> u32;
}
extern "C" {
    #[link_name = "z_impl_k_msgq_num_used_get__extern"]
    pub fn z_impl_k_msgq_num_used_get(msgq: *mut k_msgq) -> u32;
}
#[doc = " @brief Mailbox Message Structure\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mbox_msg {
    #[doc = " size of message (in bytes)"]
    pub size: usize,
    #[doc = " application-defined information value"]
    pub info: u32,
    #[doc = " sender's message data buffer"]
    pub tx_data: *mut cty::c_void,
    #[doc = " source thread id"]
    pub rx_source_thread: k_tid_t,
    #[doc = " target thread id"]
    pub tx_target_thread: k_tid_t,
    #[doc = " internal use only - thread waiting on send (may be a dummy)"]
    pub _syncing_thread: k_tid_t,
}
#[test]
fn bindgen_test_layout_k_mbox_msg() {
    const UNINIT: ::core::mem::MaybeUninit<k_mbox_msg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_mbox_msg>(),
        48usize,
        concat!("Size of: ", stringify!(k_mbox_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mbox_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(k_mbox_msg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(tx_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_source_thread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(rx_source_thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_target_thread) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(tx_target_thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._syncing_thread) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(_syncing_thread)
        )
    );
}
#[doc = " @brief Mailbox Structure\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_mbox {
    #[doc = " Transmit messages queue"]
    pub tx_msg_queue: _wait_q_t,
    #[doc = " Receive message queue"]
    pub rx_msg_queue: _wait_q_t,
    pub lock: k_spinlock,
}
#[test]
fn bindgen_test_layout_k_mbox() {
    const UNINIT: ::core::mem::MaybeUninit<k_mbox> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_mbox>(),
        32usize,
        concat!("Size of: ", stringify!(k_mbox))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mbox>(),
        8usize,
        concat!("Alignment of ", stringify!(k_mbox))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_msg_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox),
            "::",
            stringify!(tx_msg_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_msg_queue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox),
            "::",
            stringify!(rx_msg_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a mailbox.\n\n This routine initializes a mailbox object, prior to its first use.\n\n @param mbox Address of the mailbox."]
    pub fn k_mbox_init(mbox: *mut k_mbox);
}
extern "C" {
    #[doc = " @brief Send a mailbox message in a synchronous manner.\n\n This routine sends a message to @a mbox and waits for a receiver to both\n receive and process it. The message data may be in a buffer or non-existent\n (i.e. an empty message).\n\n @param mbox Address of the mailbox.\n @param tx_msg Address of the transmit message descriptor.\n @param timeout Waiting period for the message to be received,\n                or one of the special values K_NO_WAIT\n                and K_FOREVER. Once the message has been received,\n                this routine waits as long as necessary for the message\n                to be completely processed.\n\n @retval 0 Message sent.\n @retval -ENOMSG Returned without waiting.\n @retval -EAGAIN Waiting period timed out."]
    pub fn k_mbox_put(
        mbox: *mut k_mbox,
        tx_msg: *mut k_mbox_msg,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Send a mailbox message in an asynchronous manner.\n\n This routine sends a message to @a mbox without waiting for a receiver\n to process it. The message data may be in a buffer or non-existent\n (i.e. an empty message). Optionally, the semaphore @a sem will be given\n when the message has been both received and completely processed by\n the receiver.\n\n @param mbox Address of the mailbox.\n @param tx_msg Address of the transmit message descriptor.\n @param sem Address of a semaphore, or NULL if none is needed."]
    pub fn k_mbox_async_put(mbox: *mut k_mbox, tx_msg: *mut k_mbox_msg, sem: *mut k_sem);
}
extern "C" {
    #[doc = " @brief Receive a mailbox message.\n\n This routine receives a message from @a mbox, then optionally retrieves\n its data and disposes of the message.\n\n @param mbox Address of the mailbox.\n @param rx_msg Address of the receive message descriptor.\n @param buffer Address of the buffer to receive data, or NULL to defer data\n               retrieval and message disposal until later.\n @param timeout Waiting period for a message to be received,\n                or one of the special values K_NO_WAIT and K_FOREVER.\n\n @retval 0 Message received.\n @retval -ENOMSG Returned without waiting.\n @retval -EAGAIN Waiting period timed out."]
    pub fn k_mbox_get(
        mbox: *mut k_mbox,
        rx_msg: *mut k_mbox_msg,
        buffer: *mut cty::c_void,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve mailbox message data into a buffer.\n\n This routine completes the processing of a received message by retrieving\n its data into a buffer, then disposing of the message.\n\n Alternatively, this routine can be used to dispose of a received message\n without retrieving its data.\n\n @param rx_msg Address of the receive message descriptor.\n @param buffer Address of the buffer to receive data, or NULL to discard\n               the data."]
    pub fn k_mbox_data_get(rx_msg: *mut k_mbox_msg, buffer: *mut cty::c_void);
}
#[doc = " Pipe Structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_pipe {
    #[doc = "< Pipe buffer: may be NULL"]
    pub buffer: *mut cty::c_uchar,
    #[doc = "< Buffer size"]
    pub size: usize,
    #[doc = "< # bytes used in buffer"]
    pub bytes_used: usize,
    #[doc = "< Where in buffer to read from"]
    pub read_index: usize,
    #[doc = "< Where in buffer to write"]
    pub write_index: usize,
    #[doc = "< Synchronization lock"]
    pub lock: k_spinlock,
    pub wait_q: k_pipe__bindgen_ty_1,
    #[doc = "< Flags"]
    pub flags: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_pipe__bindgen_ty_1 {
    #[doc = "< Reader wait queue"]
    pub readers: _wait_q_t,
    #[doc = "< Writer wait queue"]
    pub writers: _wait_q_t,
}
#[test]
fn bindgen_test_layout_k_pipe__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<k_pipe__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_pipe__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(k_pipe__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<k_pipe__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(k_pipe__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe__bindgen_ty_1),
            "::",
            stringify!(readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe__bindgen_ty_1),
            "::",
            stringify!(writers)
        )
    );
}
#[test]
fn bindgen_test_layout_k_pipe() {
    const UNINIT: ::core::mem::MaybeUninit<k_pipe> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_pipe>(),
        80usize,
        concat!("Size of: ", stringify!(k_pipe))
    );
    assert_eq!(
        ::core::mem::align_of::<k_pipe>(),
        8usize,
        concat!("Alignment of ", stringify!(k_pipe))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_used) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(bytes_used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(read_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_index) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(write_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a pipe.\n\n This routine initializes a pipe object, prior to its first use.\n\n @param pipe Address of the pipe.\n @param buffer Address of the pipe's ring buffer, or NULL if no ring buffer\n               is used.\n @param size Size of the pipe's ring buffer (in bytes), or zero if no ring\n             buffer is used."]
    pub fn k_pipe_init(pipe: *mut k_pipe, buffer: *mut cty::c_uchar, size: usize);
}
extern "C" {
    #[doc = " @brief Release a pipe's allocated buffer\n\n If a pipe object was given a dynamically allocated buffer via\n k_pipe_alloc_init(), this will free it. This function does nothing\n if the buffer wasn't dynamically allocated.\n\n @param pipe Address of the pipe.\n @retval 0 on success\n @retval -EAGAIN nothing to cleanup"]
    pub fn k_pipe_cleanup(pipe: *mut k_pipe) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Initialize a pipe and allocate a buffer for it\n\n Storage for the buffer region will be allocated from the calling thread's\n resource pool. This memory will be released if k_pipe_cleanup() is called,\n or userspace is enabled and the pipe object loses all references to it.\n\n This function should only be called on uninitialized pipe objects.\n\n @param pipe Address of the pipe.\n @param size Size of the pipe's ring buffer (in bytes), or zero if no ring\n             buffer is used.\n @retval 0 on success\n @retval -ENOMEM if memory couldn't be allocated"]
    #[link_name = "k_pipe_alloc_init__extern"]
    pub fn k_pipe_alloc_init(pipe: *mut k_pipe, size: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Write data to a pipe.\n\n This routine writes up to @a bytes_to_write bytes of data to @a pipe.\n\n @param pipe Address of the pipe.\n @param data Address of data to write.\n @param bytes_to_write Size of data (in bytes).\n @param bytes_written Address of area to hold the number of bytes written.\n @param min_xfer Minimum number of bytes to write.\n @param timeout Waiting period to wait for the data to be written,\n                or one of the special values K_NO_WAIT and K_FOREVER.\n\n @retval 0 At least @a min_xfer bytes of data were written.\n @retval -EIO Returned without waiting; zero data bytes were written.\n @retval -EAGAIN Waiting period timed out; between zero and @a min_xfer\n                 minus one data bytes were written."]
    #[link_name = "k_pipe_put__extern"]
    pub fn k_pipe_put(
        pipe: *mut k_pipe,
        data: *const cty::c_void,
        bytes_to_write: usize,
        bytes_written: *mut usize,
        min_xfer: usize,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Read data from a pipe.\n\n This routine reads up to @a bytes_to_read bytes of data from @a pipe.\n\n @param pipe Address of the pipe.\n @param data Address to place the data read from pipe.\n @param bytes_to_read Maximum number of data bytes to read.\n @param bytes_read Address of area to hold the number of bytes read.\n @param min_xfer Minimum number of data bytes to read.\n @param timeout Waiting period to wait for the data to be read,\n                or one of the special values K_NO_WAIT and K_FOREVER.\n\n @retval 0 At least @a min_xfer bytes of data were read.\n @retval -EINVAL invalid parameters supplied\n @retval -EIO Returned without waiting; zero data bytes were read.\n @retval -EAGAIN Waiting period timed out; between zero and @a min_xfer\n                 minus one data bytes were read."]
    #[link_name = "k_pipe_get__extern"]
    pub fn k_pipe_get(
        pipe: *mut k_pipe,
        data: *mut cty::c_void,
        bytes_to_read: usize,
        bytes_read: *mut usize,
        min_xfer: usize,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Query the number of bytes that may be read from @a pipe.\n\n @param pipe Address of the pipe.\n\n @retval a number n such that 0 <= n <= @ref k_pipe.size; the\n         result is zero for unbuffered pipes."]
    #[link_name = "k_pipe_read_avail__extern"]
    pub fn k_pipe_read_avail(pipe: *mut k_pipe) -> usize;
}
extern "C" {
    #[doc = " @brief Query the number of bytes that may be written to @a pipe\n\n @param pipe Address of the pipe.\n\n @retval a number n such that 0 <= n <= @ref k_pipe.size; the\n         result is zero for unbuffered pipes."]
    #[link_name = "k_pipe_write_avail__extern"]
    pub fn k_pipe_write_avail(pipe: *mut k_pipe) -> usize;
}
extern "C" {
    #[doc = " @brief Flush the pipe of write data\n\n This routine flushes the pipe. Flushing the pipe is equivalent to reading\n both all the data in the pipe's buffer and all the data waiting to go into\n that pipe into a large temporary buffer and discarding the buffer. Any\n writers that were previously pended become unpended.\n\n @param pipe Address of the pipe."]
    #[link_name = "k_pipe_flush__extern"]
    pub fn k_pipe_flush(pipe: *mut k_pipe);
}
extern "C" {
    #[doc = " @brief Flush the pipe's internal buffer\n\n This routine flushes the pipe's internal buffer. This is equivalent to\n reading up to N bytes from the pipe (where N is the size of the pipe's\n buffer) into a temporary buffer and then discarding that buffer. If there\n were writers previously pending, then some may unpend as they try to fill\n up the pipe's emptied buffer.\n\n @param pipe Address of the pipe."]
    #[link_name = "k_pipe_buffer_flush__extern"]
    pub fn k_pipe_buffer_flush(pipe: *mut k_pipe);
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mem_slab_info {
    pub num_blocks: u32,
    pub block_size: usize,
    pub num_used: u32,
}
#[test]
fn bindgen_test_layout_k_mem_slab_info() {
    const UNINIT: ::core::mem::MaybeUninit<k_mem_slab_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_mem_slab_info>(),
        24usize,
        concat!("Size of: ", stringify!(k_mem_slab_info))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_slab_info>(),
        8usize,
        concat!("Alignment of ", stringify!(k_mem_slab_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_blocks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab_info),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab_info),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_used) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab_info),
            "::",
            stringify!(num_used)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_mem_slab {
    pub wait_q: _wait_q_t,
    pub lock: k_spinlock,
    pub buffer: *mut cty::c_char,
    pub free_list: *mut cty::c_char,
    pub info: k_mem_slab_info,
}
#[test]
fn bindgen_test_layout_k_mem_slab() {
    const UNINIT: ::core::mem::MaybeUninit<k_mem_slab> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_mem_slab>(),
        56usize,
        concat!("Size of: ", stringify!(k_mem_slab))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_slab>(),
        8usize,
        concat!("Alignment of ", stringify!(k_mem_slab))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(info)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a memory slab.\n\n Initializes a memory slab, prior to its first use.\n\n The memory slab's buffer contains @a slab_num_blocks memory blocks\n that are @a slab_block_size bytes long. The buffer must be aligned to an\n N-byte boundary matching a word boundary, where N is a power of 2\n (i.e. 4 on 32-bit systems, 8, 16, ...).\n To ensure that each memory block is similarly aligned to this boundary,\n @a slab_block_size must also be a multiple of N.\n\n @param slab Address of the memory slab.\n @param buffer Pointer to buffer used for the memory blocks.\n @param block_size Size of each memory block (in bytes).\n @param num_blocks Number of memory blocks.\n\n @retval 0 on success\n @retval -EINVAL invalid data supplied\n"]
    pub fn k_mem_slab_init(
        slab: *mut k_mem_slab,
        buffer: *mut cty::c_void,
        block_size: usize,
        num_blocks: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Allocate memory from a memory slab.\n\n This routine allocates a memory block from a memory slab.\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n\n @funcprops \\isr_ok\n\n @param slab Address of the memory slab.\n @param mem Pointer to block address area.\n @param timeout Non-negative waiting period to wait for operation to complete.\n        Use K_NO_WAIT to return without waiting,\n        or K_FOREVER to wait as long as necessary.\n\n @retval 0 Memory allocated. The block address area pointed at by @a mem\n         is set to the starting address of the memory block.\n @retval -ENOMEM Returned without waiting.\n @retval -EAGAIN Waiting period timed out.\n @retval -EINVAL Invalid data supplied"]
    pub fn k_mem_slab_alloc(
        slab: *mut k_mem_slab,
        mem: *mut *mut cty::c_void,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Free memory allocated from a memory slab.\n\n This routine releases a previously allocated memory block back to its\n associated memory slab.\n\n @param slab Address of the memory slab.\n @param mem Pointer to the memory block (as returned by k_mem_slab_alloc())."]
    pub fn k_mem_slab_free(slab: *mut k_mem_slab, mem: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Get the number of used blocks in a memory slab.\n\n This routine gets the number of memory blocks that are currently\n allocated in @a slab.\n\n @param slab Address of the memory slab.\n\n @return Number of allocated memory blocks."]
    #[link_name = "k_mem_slab_num_used_get__extern"]
    pub fn k_mem_slab_num_used_get(slab: *mut k_mem_slab) -> u32;
}
extern "C" {
    #[doc = " @brief Get the number of maximum used blocks so far in a memory slab.\n\n This routine gets the maximum number of memory blocks that were\n allocated in @a slab.\n\n @param slab Address of the memory slab.\n\n @return Maximum number of allocated memory blocks."]
    #[link_name = "k_mem_slab_max_used_get__extern"]
    pub fn k_mem_slab_max_used_get(slab: *mut k_mem_slab) -> u32;
}
extern "C" {
    #[doc = " @brief Get the number of unused blocks in a memory slab.\n\n This routine gets the number of memory blocks that are currently\n unallocated in @a slab.\n\n @param slab Address of the memory slab.\n\n @return Number of unallocated memory blocks."]
    #[link_name = "k_mem_slab_num_free_get__extern"]
    pub fn k_mem_slab_num_free_get(slab: *mut k_mem_slab) -> u32;
}
extern "C" {
    #[doc = " @brief Get the memory stats for a memory slab\n\n This routine gets the runtime memory usage stats for the slab @a slab.\n\n @param slab Address of the memory slab\n @param stats Pointer to memory into which to copy memory usage statistics\n\n @retval 0 Success\n @retval -EINVAL Any parameter points to NULL"]
    pub fn k_mem_slab_runtime_stats_get(
        slab: *mut k_mem_slab,
        stats: *mut sys_memory_stats,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Reset the maximum memory usage for a slab\n\n This routine resets the maximum memory usage for the slab @a slab to its\n current usage.\n\n @param slab Address of the memory slab\n\n @retval 0 Success\n @retval -EINVAL Memory slab is NULL"]
    pub fn k_mem_slab_runtime_stats_reset_max(slab: *mut k_mem_slab) -> cty::c_int;
}
#[doc = " @addtogroup heap_apis\n @{"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_heap {
    pub heap: sys_heap,
    pub wait_q: _wait_q_t,
    pub lock: k_spinlock,
}
#[test]
fn bindgen_test_layout_k_heap() {
    const UNINIT: ::core::mem::MaybeUninit<k_heap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_heap>(),
        40usize,
        concat!("Size of: ", stringify!(k_heap))
    );
    assert_eq!(
        ::core::mem::align_of::<k_heap>(),
        8usize,
        concat!("Alignment of ", stringify!(k_heap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_heap),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_q) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_heap),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_heap),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a k_heap\n\n This constructs a synchronized k_heap object over a memory region\n specified by the user.  Note that while any alignment and size can\n be passed as valid parameters, internal alignment restrictions\n inside the inner sys_heap mean that not all bytes may be usable as\n allocated memory.\n\n @param h Heap struct to initialize\n @param mem Pointer to memory.\n @param bytes Size of memory region, in bytes"]
    pub fn k_heap_init(h: *mut k_heap, mem: *mut cty::c_void, bytes: usize);
}
extern "C" {
    #[doc = " @brief Allocate aligned memory from a k_heap\n\n Behaves in all ways like k_heap_alloc(), except that the returned\n memory (if available) will have a starting address in memory which\n is a multiple of the specified power-of-two alignment value in\n bytes.  The resulting memory can be returned to the heap using\n k_heap_free().\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n\n @funcprops \\isr_ok\n\n @param h Heap from which to allocate\n @param align Alignment in bytes, must be a power of two\n @param bytes Number of bytes requested\n @param timeout How long to wait, or K_NO_WAIT\n @return Pointer to memory the caller can now use"]
    pub fn k_heap_aligned_alloc(
        h: *mut k_heap,
        align: usize,
        bytes: usize,
        timeout: k_timeout_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Allocate memory from a k_heap\n\n Allocates and returns a memory buffer from the memory region owned\n by the heap.  If no memory is available immediately, the call will\n block for the specified timeout (constructed via the standard\n timeout API, or K_NO_WAIT or K_FOREVER) waiting for memory to be\n freed.  If the allocation cannot be performed by the expiration of\n the timeout, NULL will be returned.\n Allocated memory is aligned on a multiple of pointer sizes.\n\n @note @a timeout must be set to K_NO_WAIT if called from ISR.\n @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.\n\n @funcprops \\isr_ok\n\n @param h Heap from which to allocate\n @param bytes Desired size of block to allocate\n @param timeout How long to wait, or K_NO_WAIT\n @return A pointer to valid heap memory, or NULL"]
    pub fn k_heap_alloc(h: *mut k_heap, bytes: usize, timeout: k_timeout_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Free memory allocated by k_heap_alloc()\n\n Returns the specified memory block, which must have been returned\n from k_heap_alloc(), to the heap for use by other callers.  Passing\n a NULL block is legal, and has no effect.\n\n @param h Heap to which to return the memory\n @param mem A valid memory block, or NULL"]
    pub fn k_heap_free(h: *mut k_heap, mem: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Allocate memory from the heap with a specified alignment.\n\n This routine provides semantics similar to aligned_alloc(); memory is\n allocated from the heap with a specified alignment. However, one minor\n difference is that k_aligned_alloc() accepts any non-zero @p size,\n whereas aligned_alloc() only accepts a @p size that is an integral\n multiple of @p align.\n\n Above, aligned_alloc() refers to:\n C11 standard (ISO/IEC 9899:2011): 7.22.3.1\n The aligned_alloc function (p: 347-348)\n\n @param align Alignment of memory requested (in bytes).\n @param size Amount of memory requested (in bytes).\n\n @return Address of the allocated memory if successful; otherwise NULL."]
    pub fn k_aligned_alloc(align: usize, size: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Allocate memory from the heap.\n\n This routine provides traditional malloc() semantics. Memory is\n allocated from the heap memory pool.\n Allocated memory is aligned on a multiple of pointer sizes.\n\n @param size Amount of memory requested (in bytes).\n\n @return Address of the allocated memory if successful; otherwise NULL."]
    pub fn k_malloc(size: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Free memory allocated from heap.\n\n This routine provides traditional free() semantics. The memory being\n returned must have been allocated from the heap memory pool.\n\n If @a ptr is NULL, no operation is performed.\n\n @param ptr Pointer to previously allocated memory."]
    pub fn k_free(ptr: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Allocate memory from heap, array style\n\n This routine provides traditional calloc() semantics. Memory is\n allocated from the heap memory pool and zeroed.\n\n @param nmemb Number of elements in the requested array\n @param size Size of each array element (in bytes).\n\n @return Address of the allocated memory if successful; otherwise NULL."]
    pub fn k_calloc(nmemb: usize, size: usize) -> *mut cty::c_void;
}
pub const _poll_types_bits__POLL_TYPE_IGNORE: _poll_types_bits = 0;
pub const _poll_types_bits__POLL_TYPE_SIGNAL: _poll_types_bits = 1;
pub const _poll_types_bits__POLL_TYPE_SEM_AVAILABLE: _poll_types_bits = 2;
pub const _poll_types_bits__POLL_TYPE_DATA_AVAILABLE: _poll_types_bits = 3;
pub const _poll_types_bits__POLL_TYPE_MSGQ_DATA_AVAILABLE: _poll_types_bits = 4;
pub const _poll_types_bits__POLL_TYPE_PIPE_DATA_AVAILABLE: _poll_types_bits = 5;
pub const _poll_types_bits__POLL_NUM_TYPES: _poll_types_bits = 6;
pub type _poll_types_bits = cty::c_uint;
pub const _poll_states_bits__POLL_STATE_NOT_READY: _poll_states_bits = 0;
pub const _poll_states_bits__POLL_STATE_SIGNALED: _poll_states_bits = 1;
pub const _poll_states_bits__POLL_STATE_SEM_AVAILABLE: _poll_states_bits = 2;
pub const _poll_states_bits__POLL_STATE_DATA_AVAILABLE: _poll_states_bits = 3;
pub const _poll_states_bits__POLL_STATE_CANCELLED: _poll_states_bits = 4;
pub const _poll_states_bits__POLL_STATE_MSGQ_DATA_AVAILABLE: _poll_states_bits = 5;
pub const _poll_states_bits__POLL_STATE_PIPE_DATA_AVAILABLE: _poll_states_bits = 6;
pub const _poll_states_bits__POLL_NUM_STATES: _poll_states_bits = 7;
pub type _poll_states_bits = cty::c_uint;
pub const k_poll_modes_K_POLL_MODE_NOTIFY_ONLY: k_poll_modes = 0;
pub const k_poll_modes_K_POLL_NUM_MODES: k_poll_modes = 1;
pub type k_poll_modes = cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_poll_signal {
    #[doc = " PRIVATE - DO NOT TOUCH"]
    pub poll_events: sys_dlist_t,
    #[doc = " 1 if the event has been signaled, 0 otherwise. Stays set to 1 until\n user resets it to 0."]
    pub signaled: cty::c_uint,
    #[doc = " custom result value passed to k_poll_signal_raise() if needed"]
    pub result: cty::c_int,
}
#[test]
fn bindgen_test_layout_k_poll_signal() {
    const UNINIT: ::core::mem::MaybeUninit<k_poll_signal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_poll_signal>(),
        24usize,
        concat!("Size of: ", stringify!(k_poll_signal))
    );
    assert_eq!(
        ::core::mem::align_of::<k_poll_signal>(),
        8usize,
        concat!("Alignment of ", stringify!(k_poll_signal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_events) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_signal),
            "::",
            stringify!(poll_events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signaled) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_signal),
            "::",
            stringify!(signaled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_signal),
            "::",
            stringify!(result)
        )
    );
}
#[doc = " @brief Poll Event\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_poll_event {
    #[doc = " PRIVATE - DO NOT TOUCH"]
    pub _node: sys_dnode_t,
    #[doc = " PRIVATE - DO NOT TOUCH"]
    pub poller: *mut z_poller,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: k_poll_event__bindgen_ty_1,
}
#[doc = " per-type data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_poll_event__bindgen_ty_1 {
    pub obj: *mut cty::c_void,
    pub signal: *mut k_poll_signal,
    pub sem: *mut k_sem,
    pub fifo: *mut k_fifo,
    pub queue: *mut k_queue,
    pub msgq: *mut k_msgq,
}
#[test]
fn bindgen_test_layout_k_poll_event__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<k_poll_event__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_poll_event__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(k_poll_event__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<k_poll_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(k_poll_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(fifo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msgq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(msgq)
        )
    );
}
#[test]
fn bindgen_test_layout_k_poll_event() {
    const UNINIT: ::core::mem::MaybeUninit<k_poll_event> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<k_poll_event>(),
        40usize,
        concat!("Size of: ", stringify!(k_poll_event))
    );
    assert_eq!(
        ::core::mem::align_of::<k_poll_event>(),
        8usize,
        concat!("Alignment of ", stringify!(k_poll_event))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event),
            "::",
            stringify!(_node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poller) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event),
            "::",
            stringify!(poller)
        )
    );
}
impl k_poll_event {
    #[inline]
    pub fn tag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tag: u32,
        type_: u32,
        state: u32,
        mode: u32,
        unused: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tag: u32 = unsafe { ::core::mem::transmute(tag) };
            tag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(14usize, 7u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let mode: u32 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let unused: u32 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Initialize one struct k_poll_event instance\n\n After this routine is called on a poll event, the event it ready to be\n placed in an event array to be passed to k_poll().\n\n @param event The event to initialize.\n @param type A bitfield of the types of event, from the K_POLL_TYPE_xxx\n             values. Only values that apply to the same object being polled\n             can be used together. Choosing K_POLL_TYPE_IGNORE disables the\n             event.\n @param mode Future. Use K_POLL_MODE_NOTIFY_ONLY.\n @param obj Kernel object or poll signal."]
    pub fn k_poll_event_init(
        event: *mut k_poll_event,
        type_: u32,
        mode: cty::c_int,
        obj: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief Wait for one or many of multiple poll events to occur\n\n This routine allows a thread to wait concurrently for one or many of\n multiple poll events to have occurred. Such events can be a kernel object\n being available, like a semaphore, or a poll signal event.\n\n When an event notifies that a kernel object is available, the kernel object\n is not \"given\" to the thread calling k_poll(): it merely signals the fact\n that the object was available when the k_poll() call was in effect. Also,\n all threads trying to acquire an object the regular way, i.e. by pending on\n the object, have precedence over the thread polling on the object. This\n means that the polling thread will never get the poll event on an object\n until the object becomes available and its pend queue is empty. For this\n reason, the k_poll() call is more effective when the objects being polled\n only have one thread, the polling thread, trying to acquire them.\n\n When k_poll() returns 0, the caller should loop on all the events that were\n passed to k_poll() and check the state field for the values that were\n expected and take the associated actions.\n\n Before being reused for another call to k_poll(), the user has to reset the\n state field to K_POLL_STATE_NOT_READY.\n\n When called from user mode, a temporary memory allocation is required from\n the caller's resource pool.\n\n @param events An array of events to be polled for.\n @param num_events The number of events in the array.\n @param timeout Waiting period for an event to be ready,\n                or one of the special values K_NO_WAIT and K_FOREVER.\n\n @retval 0 One or more events are ready.\n @retval -EAGAIN Waiting period timed out.\n @retval -EINTR Polling has been interrupted, e.g. with\n         k_queue_cancel_wait(). All output events are still set and valid,\n         cancelled event(s) will be set to K_POLL_STATE_CANCELLED. In other\n         words, -EINTR status means that at least one of output events is\n         K_POLL_STATE_CANCELLED.\n @retval -ENOMEM Thread resource pool insufficient memory (user mode only)\n @retval -EINVAL Bad parameters (user mode only)"]
    #[link_name = "k_poll__extern"]
    pub fn k_poll(
        events: *mut k_poll_event,
        num_events: cty::c_int,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Initialize a poll signal object.\n\n Ready a poll signal object to be signaled via k_poll_signal_raise().\n\n @param sig A poll signal."]
    #[link_name = "k_poll_signal_init__extern"]
    pub fn k_poll_signal_init(sig: *mut k_poll_signal);
}
extern "C" {
    #[link_name = "k_poll_signal_reset__extern"]
    pub fn k_poll_signal_reset(sig: *mut k_poll_signal);
}
extern "C" {
    #[doc = " @brief Fetch the signaled state and result value of a poll signal\n\n @param sig A poll signal object\n @param signaled An integer buffer which will be written nonzero if the\n\t\t   object was signaled\n @param result An integer destination buffer which will be written with the\n\t\t   result value if the object was signaled, or an undefined\n\t\t   value if it was not."]
    #[link_name = "k_poll_signal_check__extern"]
    pub fn k_poll_signal_check(
        sig: *mut k_poll_signal,
        signaled: *mut cty::c_uint,
        result: *mut cty::c_int,
    );
}
extern "C" {
    #[doc = " @brief Signal a poll signal object.\n\n This routine makes ready a poll signal, which is basically a poll event of\n type K_POLL_TYPE_SIGNAL. If a thread was polling on that event, it will be\n made ready to run. A @a result value can be specified.\n\n The poll signal contains a 'signaled' field that, when set by\n k_poll_signal_raise(), stays set until the user sets it back to 0 with\n k_poll_signal_reset(). It thus has to be reset by the user before being\n passed again to k_poll() or k_poll() will consider it being signaled, and\n will return immediately.\n\n @note The result is stored and the 'signaled' field is set even if\n this function returns an error indicating that an expiring poll was\n not notified.  The next k_poll() will detect the missed raise.\n\n @param sig A poll signal.\n @param result The value to store in the result field of the signal.\n\n @retval 0 The signal was delivered successfully.\n @retval -EAGAIN The polling thread's timeout is in the process of expiring."]
    #[link_name = "k_poll_signal_raise__extern"]
    pub fn k_poll_signal_raise(sig: *mut k_poll_signal, result: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " @defgroup cpu_idle_apis CPU Idling APIs\n @ingroup kernel_apis\n @{\n/\n/**\n @brief Make the CPU idle.\n\n This function makes the CPU idle until an event wakes it up.\n\n In a regular system, the idle thread should be the only thread responsible\n for making the CPU idle and triggering any type of power management.\n However, in some more constrained systems, such as a single-threaded system,\n the only thread would be responsible for this if needed.\n\n @note In some architectures, before returning, the function unmasks interrupts\n unconditionally."]
    #[link_name = "k_cpu_idle__extern"]
    pub fn k_cpu_idle();
}
extern "C" {
    #[doc = " @brief Make the CPU idle in an atomic fashion.\n\n Similar to k_cpu_idle(), but must be called with interrupts locked.\n\n Enabling interrupts and entering a low-power mode will be atomic,\n i.e. there will be no period of time where interrupts are enabled before\n the processor enters a low-power mode.\n\n After waking up from the low-power mode, the interrupt lockout state will\n be restored as if by irq_unlock(key).\n\n @param key Interrupt locking key obtained from irq_lock()."]
    #[link_name = "k_cpu_atomic_idle__extern"]
    pub fn k_cpu_atomic_idle(key: cty::c_uint);
}
extern "C" {
    #[doc = " @internal"]
    pub fn z_timer_expiration_handler(t: *mut _timeout);
}
extern "C" {
    #[doc = " @brief Disable preservation of floating point context information.\n\n This routine informs the kernel that the specified thread\n will no longer be using the floating point registers.\n\n @warning\n Some architectures apply restrictions on how the disabling of floating\n point preservation may be requested, see arch_float_disable.\n\n @warning\n This routine should only be used to disable floating point support for\n a thread that currently has such support enabled.\n\n @param thread ID of thread.\n\n @retval 0        On success.\n @retval -ENOTSUP If the floating point disabling is not implemented.\n         -EINVAL  If the floating point disabling could not be performed."]
    #[link_name = "k_float_disable__extern"]
    pub fn k_float_disable(thread: *mut k_thread) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Enable preservation of floating point context information.\n\n This routine informs the kernel that the specified thread\n will use the floating point registers.\n\n Invoking this routine initializes the thread's floating point context info\n to that of an FPU that has been reset. The next time the thread is scheduled\n by z_swap() it will either inherit an FPU that is guaranteed to be in a\n \"sane\" state (if the most recent user of the FPU was cooperatively swapped\n out) or the thread's own floating point context will be loaded (if the most\n recent user of the FPU was preempted, or if this thread is the first user\n of the FPU). Thereafter, the kernel will protect the thread's FP context\n so that it is not altered during a preemptive context switch.\n\n The @a options parameter indicates which floating point register sets will\n be used by the specified thread.\n\n For x86 options:\n\n - K_FP_REGS  indicates x87 FPU and MMX registers only\n - K_SSE_REGS indicates SSE registers (and also x87 FPU and MMX registers)\n\n @warning\n Some architectures apply restrictions on how the enabling of floating\n point preservation may be requested, see arch_float_enable.\n\n @warning\n This routine should only be used to enable floating point support for\n a thread that currently has such support enabled.\n\n @param thread  ID of thread.\n @param options architecture dependent options\n\n @retval 0        On success.\n @retval -ENOTSUP If the floating point enabling is not implemented.\n         -EINVAL  If the floating point enabling could not be performed."]
    #[link_name = "k_float_enable__extern"]
    pub fn k_float_enable(thread: *mut k_thread, options: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get the runtime statistics of a thread\n\n @param thread ID of thread.\n @param stats Pointer to struct to copy statistics into.\n @return -EINVAL if null pointers, otherwise 0"]
    pub fn k_thread_runtime_stats_get(
        thread: k_tid_t,
        stats: *mut k_thread_runtime_stats_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get the runtime statistics of all threads\n\n @param stats Pointer to struct to copy statistics into.\n @return -EINVAL if null pointers, otherwise 0"]
    pub fn k_thread_runtime_stats_all_get(stats: *mut k_thread_runtime_stats_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Enable gathering of runtime statistics for specified thread\n\n This routine enables the gathering of runtime statistics for the specified\n thread.\n\n @param thread ID of thread\n @return -EINVAL if invalid thread ID, otherwise 0"]
    pub fn k_thread_runtime_stats_enable(thread: k_tid_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Disable gathering of runtime statistics for specified thread\n\n This routine disables the gathering of runtime statistics for the specified\n thread.\n\n @param thread ID of thread\n @return -EINVAL if invalid thread ID, otherwise 0"]
    pub fn k_thread_runtime_stats_disable(thread: k_tid_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Enable gathering of system runtime statistics\n\n This routine enables the gathering of system runtime statistics. Note that\n it does not affect the gathering of similar statistics for individual\n threads."]
    pub fn k_sys_runtime_stats_enable();
}
extern "C" {
    #[doc = " @brief Disable gathering of system runtime statistics\n\n This routine disables the gathering of system runtime statistics. Note that\n it does not affect the gathering of similar statistics for individual\n threads."]
    pub fn k_sys_runtime_stats_disable();
}
extern "C" {
    #[doc = " @brief Called when entering an ISR"]
    pub fn sys_trace_isr_enter();
}
extern "C" {
    #[doc = " @brief Called when exiting an ISR"]
    pub fn sys_trace_isr_exit();
}
extern "C" {
    #[doc = " @brief Called when exiting an ISR and switching to scheduler"]
    pub fn sys_trace_isr_exit_to_scheduler();
}
extern "C" {
    #[doc = " @brief Called when the cpu enters the idle state"]
    pub fn sys_trace_idle();
}
extern "C" {
    pub fn z_impl_k_thread_stack_alloc(size: usize, flags: cty::c_int) -> *mut k_thread_stack_t;
}
extern "C" {
    pub fn z_impl_k_thread_stack_free(stack: *mut k_thread_stack_t) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_thread_create(
        new_thread: *mut k_thread,
        stack: *mut k_thread_stack_t,
        stack_size: usize,
        entry: k_thread_entry_t,
        p1: *mut cty::c_void,
        p2: *mut cty::c_void,
        p3: *mut cty::c_void,
        prio: cty::c_int,
        options: u32,
        delay: k_timeout_t,
    ) -> k_tid_t;
}
extern "C" {
    pub fn z_impl_k_thread_stack_space_get(
        thread: *const k_thread,
        unused_ptr: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "k_thread_stack_space_get__extern"]
    pub fn k_thread_stack_space_get(thread: *const k_thread, unused_ptr: *mut usize) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_thread_join(thread: *mut k_thread, timeout: k_timeout_t) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_sleep(timeout: k_timeout_t) -> i32;
}
extern "C" {
    pub fn z_impl_k_usleep(us: i32) -> i32;
}
extern "C" {
    pub fn z_impl_k_busy_wait(usec_to_wait: u32);
}
extern "C" {
    pub fn z_impl_k_yield();
}
extern "C" {
    pub fn z_impl_k_wakeup(thread: k_tid_t);
}
extern "C" {
    pub fn z_impl_k_sched_current_thread_query() -> k_tid_t;
}
extern "C" {
    pub fn z_impl_k_thread_abort(thread: k_tid_t);
}
extern "C" {
    pub fn z_impl_k_thread_start(thread: k_tid_t);
}
extern "C" {
    pub fn z_impl_k_thread_timeout_expires_ticks(t: *const k_thread) -> k_ticks_t;
}
extern "C" {
    #[link_name = "k_thread_timeout_expires_ticks__extern"]
    pub fn k_thread_timeout_expires_ticks(t: *const k_thread) -> k_ticks_t;
}
extern "C" {
    pub fn z_impl_k_thread_timeout_remaining_ticks(t: *const k_thread) -> k_ticks_t;
}
extern "C" {
    #[link_name = "k_thread_timeout_remaining_ticks__extern"]
    pub fn k_thread_timeout_remaining_ticks(t: *const k_thread) -> k_ticks_t;
}
extern "C" {
    pub fn z_impl_k_thread_priority_get(thread: k_tid_t) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_thread_priority_set(thread: k_tid_t, prio: cty::c_int);
}
extern "C" {
    pub fn z_impl_k_thread_deadline_set(thread: k_tid_t, deadline: cty::c_int);
}
extern "C" {
    #[link_name = "k_thread_deadline_set__extern"]
    pub fn k_thread_deadline_set(thread: k_tid_t, deadline: cty::c_int);
}
extern "C" {
    pub fn z_impl_k_thread_suspend(thread: k_tid_t);
}
extern "C" {
    pub fn z_impl_k_thread_resume(thread: k_tid_t);
}
extern "C" {
    pub fn z_impl_k_is_preempt_thread() -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_thread_custom_data_set(value: *mut cty::c_void);
}
extern "C" {
    pub fn z_impl_k_thread_custom_data_get() -> *mut cty::c_void;
}
extern "C" {
    pub fn z_impl_k_thread_name_set(thread: k_tid_t, str_: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_thread_name_copy(
        thread: k_tid_t,
        buf: *mut cty::c_char,
        size: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_timer_start(timer: *mut k_timer, duration: k_timeout_t, period: k_timeout_t);
}
extern "C" {
    pub fn z_impl_k_timer_stop(timer: *mut k_timer);
}
extern "C" {
    pub fn z_impl_k_timer_status_get(timer: *mut k_timer) -> u32;
}
extern "C" {
    pub fn z_impl_k_timer_status_sync(timer: *mut k_timer) -> u32;
}
extern "C" {
    pub fn z_impl_k_timer_expires_ticks(timer: *const k_timer) -> k_ticks_t;
}
extern "C" {
    #[link_name = "k_timer_expires_ticks__extern"]
    pub fn k_timer_expires_ticks(timer: *const k_timer) -> k_ticks_t;
}
extern "C" {
    pub fn z_impl_k_timer_remaining_ticks(timer: *const k_timer) -> k_ticks_t;
}
extern "C" {
    #[link_name = "k_timer_remaining_ticks__extern"]
    pub fn k_timer_remaining_ticks(timer: *const k_timer) -> k_ticks_t;
}
extern "C" {
    pub fn z_impl_k_uptime_ticks() -> i64;
}
extern "C" {
    pub fn z_impl_k_queue_init(queue: *mut k_queue);
}
extern "C" {
    pub fn z_impl_k_queue_cancel_wait(queue: *mut k_queue);
}
extern "C" {
    pub fn z_impl_k_queue_alloc_append(queue: *mut k_queue, data: *mut cty::c_void) -> i32;
}
extern "C" {
    pub fn z_impl_k_queue_alloc_prepend(queue: *mut k_queue, data: *mut cty::c_void) -> i32;
}
extern "C" {
    pub fn z_impl_k_queue_get(queue: *mut k_queue, timeout: k_timeout_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn z_impl_k_queue_peek_head(queue: *mut k_queue) -> *mut cty::c_void;
}
extern "C" {
    pub fn z_impl_k_queue_peek_tail(queue: *mut k_queue) -> *mut cty::c_void;
}
extern "C" {
    pub fn z_impl_k_futex_wait(
        futex: *mut k_futex,
        expected: cty::c_int,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "k_futex_wait__extern"]
    pub fn k_futex_wait(
        futex: *mut k_futex,
        expected: cty::c_int,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_futex_wake(futex: *mut k_futex, wake_all: bool) -> cty::c_int;
}
extern "C" {
    #[link_name = "k_futex_wake__extern"]
    pub fn k_futex_wake(futex: *mut k_futex, wake_all: bool) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_event_init(event: *mut k_event);
}
extern "C" {
    pub fn z_impl_k_event_post(event: *mut k_event, events: u32) -> u32;
}
extern "C" {
    pub fn z_impl_k_event_set(event: *mut k_event, events: u32) -> u32;
}
extern "C" {
    pub fn z_impl_k_event_set_masked(event: *mut k_event, events: u32, events_mask: u32) -> u32;
}
extern "C" {
    pub fn z_impl_k_event_clear(event: *mut k_event, events: u32) -> u32;
}
extern "C" {
    pub fn z_impl_k_event_wait(
        event: *mut k_event,
        events: u32,
        reset: bool,
        timeout: k_timeout_t,
    ) -> u32;
}
extern "C" {
    pub fn z_impl_k_event_wait_all(
        event: *mut k_event,
        events: u32,
        reset: bool,
        timeout: k_timeout_t,
    ) -> u32;
}
extern "C" {
    pub fn z_impl_k_stack_alloc_init(stack: *mut k_stack, num_entries: u32) -> i32;
}
extern "C" {
    pub fn z_impl_k_stack_push(stack: *mut k_stack, data: stack_data_t) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_stack_pop(
        stack: *mut k_stack,
        data: *mut stack_data_t,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_mutex_init(mutex: *mut k_mutex) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_mutex_lock(mutex: *mut k_mutex, timeout: k_timeout_t) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_mutex_unlock(mutex: *mut k_mutex) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_condvar_init(condvar: *mut k_condvar) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_condvar_signal(condvar: *mut k_condvar) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_condvar_broadcast(condvar: *mut k_condvar) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_condvar_wait(
        condvar: *mut k_condvar,
        mutex: *mut k_mutex,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_sem_init(
        sem: *mut k_sem,
        initial_count: cty::c_uint,
        limit: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_sem_take(sem: *mut k_sem, timeout: k_timeout_t) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_sem_give(sem: *mut k_sem);
}
extern "C" {
    pub fn z_impl_k_sem_reset(sem: *mut k_sem);
}
extern "C" {
    pub fn z_impl_k_msgq_alloc_init(
        msgq: *mut k_msgq,
        msg_size: usize,
        max_msgs: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_msgq_put(
        msgq: *mut k_msgq,
        data: *const cty::c_void,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_msgq_get(
        msgq: *mut k_msgq,
        data: *mut cty::c_void,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_msgq_peek(msgq: *mut k_msgq, data: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_msgq_peek_at(msgq: *mut k_msgq, data: *mut cty::c_void, idx: u32)
        -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_msgq_purge(msgq: *mut k_msgq);
}
extern "C" {
    pub fn z_impl_k_msgq_get_attrs(msgq: *mut k_msgq, attrs: *mut k_msgq_attrs);
}
extern "C" {
    pub fn z_impl_k_pipe_alloc_init(pipe: *mut k_pipe, size: usize) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_pipe_put(
        pipe: *mut k_pipe,
        data: *const cty::c_void,
        bytes_to_write: usize,
        bytes_written: *mut usize,
        min_xfer: usize,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_pipe_get(
        pipe: *mut k_pipe,
        data: *mut cty::c_void,
        bytes_to_read: usize,
        bytes_read: *mut usize,
        min_xfer: usize,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_pipe_read_avail(pipe: *mut k_pipe) -> usize;
}
extern "C" {
    pub fn z_impl_k_pipe_write_avail(pipe: *mut k_pipe) -> usize;
}
extern "C" {
    pub fn z_impl_k_pipe_flush(pipe: *mut k_pipe);
}
extern "C" {
    pub fn z_impl_k_pipe_buffer_flush(pipe: *mut k_pipe);
}
extern "C" {
    pub fn z_impl_k_poll(
        events: *mut k_poll_event,
        num_events: cty::c_int,
        timeout: k_timeout_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_poll_signal_init(sig: *mut k_poll_signal);
}
extern "C" {
    pub fn z_impl_k_poll_signal_reset(sig: *mut k_poll_signal);
}
extern "C" {
    pub fn z_impl_k_poll_signal_check(
        sig: *mut k_poll_signal,
        signaled: *mut cty::c_uint,
        result: *mut cty::c_int,
    );
}
extern "C" {
    pub fn z_impl_k_poll_signal_raise(sig: *mut k_poll_signal, result: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_str_out(c: *mut cty::c_char, n: usize);
}
extern "C" {
    #[link_name = "k_str_out__extern"]
    pub fn k_str_out(c: *mut cty::c_char, n: usize);
}
extern "C" {
    pub fn z_impl_k_float_disable(thread: *mut k_thread) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_k_float_enable(thread: *mut k_thread, options: cty::c_uint) -> cty::c_int;
}
#[doc = " @brief Identifies a set of pins associated with a port.\n\n The pin with index n is present in the set if and only if the bit\n identified by (1U << n) is set."]
pub type gpio_port_pins_t = u32;
#[doc = " @brief Provides values for a set of pins associated with a port.\n\n The value for a pin with index n is high (physical mode) or active\n (logical mode) if and only if the bit identified by (1U << n) is set.\n Otherwise the value for the pin is low (physical mode) or inactive\n (logical mode).\n\n Values of this type are often paired with a `gpio_port_pins_t` value\n that specifies which encoded pin values are valid for the operation."]
pub type gpio_port_value_t = u32;
#[doc = " @brief Provides a type to hold a GPIO pin index.\n\n This reduced-size type is sufficient to record a pin number,\n e.g. from a devicetree GPIOS property."]
pub type gpio_pin_t = u8;
#[doc = " @brief Provides a type to hold GPIO devicetree flags.\n\n All GPIO flags that can be expressed in devicetree fit in the low 16\n bits of the full flags field, so use a reduced-size type to record\n that part of a GPIOS property.\n\n The lower 8 bits are used for standard flags. The upper 8 bits are reserved\n for SoC specific flags."]
pub type gpio_dt_flags_t = u16;
#[doc = " @brief Provides a type to hold GPIO configuration flags.\n\n This type is sufficient to hold all flags used to control GPIO\n configuration, whether pin or interrupt."]
pub type gpio_flags_t = u32;
#[doc = " @brief Container for GPIO pin information specified in devicetree\n\n This type contains a pointer to a GPIO device, pin number for a pin\n controlled by that device, and the subset of pin configuration\n flags which may be given in devicetree.\n\n @see GPIO_DT_SPEC_GET_BY_IDX\n @see GPIO_DT_SPEC_GET_BY_IDX_OR\n @see GPIO_DT_SPEC_GET\n @see GPIO_DT_SPEC_GET_OR"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dt_spec {
    #[doc = " GPIO device controlling the pin"]
    pub port: *const device,
    #[doc = " The pin's number on the device"]
    pub pin: gpio_pin_t,
    #[doc = " The pin's configuration flags as specified in devicetree"]
    pub dt_flags: gpio_dt_flags_t,
}
#[test]
fn bindgen_test_layout_gpio_dt_spec() {
    const UNINIT: ::core::mem::MaybeUninit<gpio_dt_spec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpio_dt_spec>(),
        16usize,
        concat!("Size of: ", stringify!(gpio_dt_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<gpio_dt_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(gpio_dt_spec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dt_spec),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dt_spec),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dt_flags) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dt_spec),
            "::",
            stringify!(dt_flags)
        )
    );
}
#[doc = " This structure is common to all GPIO drivers and is expected to be\n the first element in the object pointed to by the config field\n in the device structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_driver_config {
    #[doc = " Mask identifying pins supported by the controller.\n\n Initialization of this mask is the responsibility of device\n instance generation in the driver."]
    pub port_pin_mask: gpio_port_pins_t,
}
#[test]
fn bindgen_test_layout_gpio_driver_config() {
    const UNINIT: ::core::mem::MaybeUninit<gpio_driver_config> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpio_driver_config>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_driver_config))
    );
    assert_eq!(
        ::core::mem::align_of::<gpio_driver_config>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_driver_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_pin_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_config),
            "::",
            stringify!(port_pin_mask)
        )
    );
}
#[doc = " This structure is common to all GPIO drivers and is expected to be the first\n element in the driver's struct driver_data declaration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_driver_data {
    #[doc = " Mask identifying pins that are configured as active low.\n\n Management of this mask is the responsibility of the\n wrapper functions in this header."]
    pub invert: gpio_port_pins_t,
}
#[test]
fn bindgen_test_layout_gpio_driver_data() {
    const UNINIT: ::core::mem::MaybeUninit<gpio_driver_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpio_driver_data>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_driver_data))
    );
    assert_eq!(
        ::core::mem::align_of::<gpio_driver_data>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_driver_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_data),
            "::",
            stringify!(invert)
        )
    );
}
#[doc = " @typedef gpio_callback_handler_t\n @brief Define the application callback handler function signature\n\n @param port Device struct for the GPIO device.\n @param cb Original struct gpio_callback owning this handler\n @param pins Mask of pins that triggers the callback handler\n\n Note: cb pointer can be used to retrieve private data through\n CONTAINER_OF() if original struct gpio_callback is stored in\n another private structure."]
pub type gpio_callback_handler_t = ::core::option::Option<
    unsafe extern "C" fn(port: *const device, cb: *mut gpio_callback, pins: gpio_port_pins_t),
>;
#[doc = " @brief GPIO callback structure\n\n Used to register a callback in the driver instance callback list.\n As many callbacks as needed can be added as long as each of them\n are unique pointers of struct gpio_callback.\n Beware such structure should not be allocated on stack.\n\n Note: To help setting it, see gpio_init_callback() below"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_callback {
    #[doc = " This is meant to be used in the driver and the user should not\n mess with it (see drivers/gpio/gpio_utils.h)"]
    pub node: sys_snode_t,
    #[doc = " Actual callback function being called when relevant."]
    pub handler: gpio_callback_handler_t,
    #[doc = " A mask of pins the callback is interested in, if 0 the callback\n will never be called. Such pin_mask can be modified whenever\n necessary by the owner, and thus will affect the handler being\n called or not. The selected pins must be configured to trigger\n an interrupt."]
    pub pin_mask: gpio_port_pins_t,
}
#[test]
fn bindgen_test_layout_gpio_callback() {
    const UNINIT: ::core::mem::MaybeUninit<gpio_callback> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpio_callback>(),
        24usize,
        concat!("Size of: ", stringify!(gpio_callback))
    );
    assert_eq!(
        ::core::mem::align_of::<gpio_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(gpio_callback))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_callback),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_callback),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_callback),
            "::",
            stringify!(pin_mask)
        )
    );
}
pub const gpio_int_mode_GPIO_INT_MODE_DISABLED: gpio_int_mode = 2097152;
pub const gpio_int_mode_GPIO_INT_MODE_LEVEL: gpio_int_mode = 4194304;
pub const gpio_int_mode_GPIO_INT_MODE_EDGE: gpio_int_mode = 20971520;
#[doc = " @cond INTERNAL_HIDDEN\n\n For internal use only, skip these in public documentation."]
pub type gpio_int_mode = cty::c_uint;
pub const gpio_int_trig_GPIO_INT_TRIG_LOW: gpio_int_trig = 33554432;
pub const gpio_int_trig_GPIO_INT_TRIG_HIGH: gpio_int_trig = 67108864;
pub const gpio_int_trig_GPIO_INT_TRIG_BOTH: gpio_int_trig = 100663296;
pub type gpio_int_trig = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_driver_api {
    pub pin_configure: ::core::option::Option<
        unsafe extern "C" fn(
            port: *const device,
            pin: gpio_pin_t,
            flags: gpio_flags_t,
        ) -> cty::c_int,
    >,
    pub port_get_raw: ::core::option::Option<
        unsafe extern "C" fn(port: *const device, value: *mut gpio_port_value_t) -> cty::c_int,
    >,
    pub port_set_masked_raw: ::core::option::Option<
        unsafe extern "C" fn(
            port: *const device,
            mask: gpio_port_pins_t,
            value: gpio_port_value_t,
        ) -> cty::c_int,
    >,
    pub port_set_bits_raw: ::core::option::Option<
        unsafe extern "C" fn(port: *const device, pins: gpio_port_pins_t) -> cty::c_int,
    >,
    pub port_clear_bits_raw: ::core::option::Option<
        unsafe extern "C" fn(port: *const device, pins: gpio_port_pins_t) -> cty::c_int,
    >,
    pub port_toggle_bits: ::core::option::Option<
        unsafe extern "C" fn(port: *const device, pins: gpio_port_pins_t) -> cty::c_int,
    >,
    pub pin_interrupt_configure: ::core::option::Option<
        unsafe extern "C" fn(
            port: *const device,
            pin: gpio_pin_t,
            arg1: gpio_int_mode,
            arg2: gpio_int_trig,
        ) -> cty::c_int,
    >,
    pub manage_callback: ::core::option::Option<
        unsafe extern "C" fn(port: *const device, cb: *mut gpio_callback, set: bool) -> cty::c_int,
    >,
    pub get_pending_int: ::core::option::Option<unsafe extern "C" fn(dev: *const device) -> u32>,
}
#[test]
fn bindgen_test_layout_gpio_driver_api() {
    const UNINIT: ::core::mem::MaybeUninit<gpio_driver_api> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpio_driver_api>(),
        72usize,
        concat!("Size of: ", stringify!(gpio_driver_api))
    );
    assert_eq!(
        ::core::mem::align_of::<gpio_driver_api>(),
        8usize,
        concat!("Alignment of ", stringify!(gpio_driver_api))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_configure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(pin_configure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_get_raw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(port_get_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_set_masked_raw) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(port_set_masked_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_set_bits_raw) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(port_set_bits_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_clear_bits_raw) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(port_clear_bits_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_toggle_bits) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(port_toggle_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_interrupt_configure) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(pin_interrupt_configure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manage_callback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(manage_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pending_int) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_driver_api),
            "::",
            stringify!(get_pending_int)
        )
    );
}
extern "C" {
    #[doc = " @brief Validate that GPIO port is ready.\n\n @param spec GPIO specification from devicetree\n\n @retval true if the GPIO spec is ready for use.\n @retval false if the GPIO spec is not ready for use."]
    #[link_name = "gpio_is_ready_dt__extern"]
    pub fn gpio_is_ready_dt(spec: *const gpio_dt_spec) -> bool;
}
extern "C" {
    #[doc = " @brief Configure pin interrupt.\n\n @note This function can also be used to configure interrupts on pins\n       not controlled directly by the GPIO module. That is, pins which are\n       routed to other modules such as I2C, SPI, UART.\n\n @param port Pointer to device structure for the driver instance.\n @param pin Pin number.\n @param flags Interrupt configuration flags as defined by GPIO_INT_*.\n\n @retval 0 If successful.\n @retval -ENOSYS If the operation is not implemented by the driver.\n @retval -ENOTSUP If any of the configuration options is not supported\n                  (unless otherwise directed by flag documentation).\n @retval -EINVAL  Invalid argument.\n @retval -EBUSY   Interrupt line required to configure pin interrupt is\n                  already in use.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_interrupt_configure__extern"]
    pub fn gpio_pin_interrupt_configure(
        port: *const device,
        pin: gpio_pin_t,
        flags: gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_pin_interrupt_configure__extern"]
    pub fn z_impl_gpio_pin_interrupt_configure(
        port: *const device,
        pin: gpio_pin_t,
        flags: gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Configure pin interrupts from a @p gpio_dt_spec.\n\n This is equivalent to:\n\n     gpio_pin_interrupt_configure(spec->port, spec->pin, flags);\n\n The <tt>spec->dt_flags</tt> value is not used.\n\n @param spec GPIO specification from devicetree\n @param flags interrupt configuration flags\n @return a value from gpio_pin_interrupt_configure()"]
    #[link_name = "gpio_pin_interrupt_configure_dt__extern"]
    pub fn gpio_pin_interrupt_configure_dt(
        spec: *const gpio_dt_spec,
        flags: gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Configure a single pin.\n\n @param port Pointer to device structure for the driver instance.\n @param pin Pin number to configure.\n @param flags Flags for pin configuration: 'GPIO input/output configuration\n        flags', 'GPIO pin drive flags', 'GPIO pin bias flags'.\n\n @retval 0 If successful.\n @retval -ENOTSUP if any of the configuration options is not supported\n                  (unless otherwise directed by flag documentation).\n @retval -EINVAL Invalid argument.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_configure__extern"]
    pub fn gpio_pin_configure(
        port: *const device,
        pin: gpio_pin_t,
        flags: gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_pin_configure__extern"]
    pub fn z_impl_gpio_pin_configure(
        port: *const device,
        pin: gpio_pin_t,
        flags: gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Configure a single pin from a @p gpio_dt_spec and some extra flags.\n\n This is equivalent to:\n\n     gpio_pin_configure(spec->port, spec->pin, spec->dt_flags | extra_flags);\n\n @param spec GPIO specification from devicetree\n @param extra_flags additional flags\n @return a value from gpio_pin_configure()"]
    #[link_name = "gpio_pin_configure_dt__extern"]
    pub fn gpio_pin_configure_dt(
        spec: *const gpio_dt_spec,
        extra_flags: gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get direction of select pins in a port.\n\n Retrieve direction of each pin specified in @p map.\n\n If @p inputs or @p outputs is NULL, then this function does not get the\n respective input or output direction information.\n\n @param port Pointer to the device structure for the driver instance.\n @param map Bitmap of pin directions to query.\n @param inputs Pointer to a variable where input directions will be stored.\n @param outputs Pointer to a variable where output directions will be stored.\n\n @retval 0 If successful.\n @retval -ENOSYS if the underlying driver does not support this call.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_get_direction__extern"]
    pub fn gpio_port_get_direction(
        port: *const device,
        map: gpio_port_pins_t,
        inputs: *mut gpio_port_pins_t,
        outputs: *mut gpio_port_pins_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Check if @p pin is configured for input\n\n @param port Pointer to device structure for the driver instance.\n @param pin Pin number to query the direction of\n\n @retval 1 if @p pin is configured as @ref GPIO_INPUT.\n @retval 0 if @p pin is not configured as @ref GPIO_INPUT.\n @retval -ENOSYS if the underlying driver does not support this call.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_is_input__extern"]
    pub fn gpio_pin_is_input(port: *const device, pin: gpio_pin_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Check if a single pin from @p gpio_dt_spec is configured for input\n\n This is equivalent to:\n\n     gpio_pin_is_input(spec->port, spec->pin);\n\n @param spec GPIO specification from devicetree.\n\n @return A value from gpio_pin_is_input()."]
    #[link_name = "gpio_pin_is_input_dt__extern"]
    pub fn gpio_pin_is_input_dt(spec: *const gpio_dt_spec) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Check if @p pin is configured for output\n\n @param port Pointer to device structure for the driver instance.\n @param pin Pin number to query the direction of\n\n @retval 1 if @p pin is configured as @ref GPIO_OUTPUT.\n @retval 0 if @p pin is not configured as @ref GPIO_OUTPUT.\n @retval -ENOSYS if the underlying driver does not support this call.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_is_output__extern"]
    pub fn gpio_pin_is_output(port: *const device, pin: gpio_pin_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Check if a single pin from @p gpio_dt_spec is configured for output\n\n This is equivalent to:\n\n     gpio_pin_is_output(spec->port, spec->pin);\n\n @param spec GPIO specification from devicetree.\n\n @return A value from gpio_pin_is_output()."]
    #[link_name = "gpio_pin_is_output_dt__extern"]
    pub fn gpio_pin_is_output_dt(spec: *const gpio_dt_spec) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get a configuration of a single pin.\n\n @param port Pointer to device structure for the driver instance.\n @param pin Pin number which configuration is get.\n @param flags Pointer to variable in which the current configuration will\n              be stored if function is successful.\n\n @retval 0 If successful.\n @retval -ENOSYS if getting current pin configuration is not implemented\n                  by the driver.\n @retval -EINVAL Invalid argument.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_get_config__extern"]
    pub fn gpio_pin_get_config(
        port: *const device,
        pin: gpio_pin_t,
        flags: *mut gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get a configuration of a single pin from a @p gpio_dt_spec.\n\n This is equivalent to:\n\n     gpio_pin_get_config(spec->port, spec->pin, flags);\n\n @param spec GPIO specification from devicetree\n @param flags Pointer to variable in which the current configuration will\n              be stored if function is successful.\n @return a value from gpio_pin_configure()"]
    #[link_name = "gpio_pin_get_config_dt__extern"]
    pub fn gpio_pin_get_config_dt(
        spec: *const gpio_dt_spec,
        flags: *mut gpio_flags_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get physical level of all input pins in a port.\n\n A low physical level on the pin will be interpreted as value 0. A high\n physical level will be interpreted as value 1. This function ignores\n GPIO_ACTIVE_LOW flag.\n\n Value of a pin with index n will be represented by bit n in the returned\n port value.\n\n @param port Pointer to the device structure for the driver instance.\n @param value Pointer to a variable where pin values will be stored.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_get_raw__extern"]
    pub fn gpio_port_get_raw(port: *const device, value: *mut gpio_port_value_t) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_port_get_raw__extern"]
    pub fn z_impl_gpio_port_get_raw(
        port: *const device,
        value: *mut gpio_port_value_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get logical level of all input pins in a port.\n\n Get logical level of an input pin taking into account GPIO_ACTIVE_LOW flag.\n If pin is configured as Active High, a low physical level will be interpreted\n as logical value 0. If pin is configured as Active Low, a low physical level\n will be interpreted as logical value 1.\n\n Value of a pin with index n will be represented by bit n in the returned\n port value.\n\n @param port Pointer to the device structure for the driver instance.\n @param value Pointer to a variable where pin values will be stored.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_get__extern"]
    pub fn gpio_port_get(port: *const device, value: *mut gpio_port_value_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set physical level of output pins in a port.\n\n Writing value 0 to the pin will set it to a low physical level. Writing\n value 1 will set it to a high physical level. This function ignores\n GPIO_ACTIVE_LOW flag.\n\n Pin with index n is represented by bit n in mask and value parameter.\n\n @param port Pointer to the device structure for the driver instance.\n @param mask Mask indicating which pins will be modified.\n @param value Value assigned to the output pins.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_set_masked_raw__extern"]
    pub fn gpio_port_set_masked_raw(
        port: *const device,
        mask: gpio_port_pins_t,
        value: gpio_port_value_t,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_port_set_masked_raw__extern"]
    pub fn z_impl_gpio_port_set_masked_raw(
        port: *const device,
        mask: gpio_port_pins_t,
        value: gpio_port_value_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set logical level of output pins in a port.\n\n Set logical level of an output pin taking into account GPIO_ACTIVE_LOW flag.\n Value 0 sets the pin in logical 0 / inactive state. Value 1 sets the pin in\n logical 1 / active state. If pin is configured as Active High, the default,\n setting it in inactive state will force the pin to a low physical level. If\n pin is configured as Active Low, setting it in inactive state will force the\n pin to a high physical level.\n\n Pin with index n is represented by bit n in mask and value parameter.\n\n @param port Pointer to the device structure for the driver instance.\n @param mask Mask indicating which pins will be modified.\n @param value Value assigned to the output pins.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_set_masked__extern"]
    pub fn gpio_port_set_masked(
        port: *const device,
        mask: gpio_port_pins_t,
        value: gpio_port_value_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set physical level of selected output pins to high.\n\n @param port Pointer to the device structure for the driver instance.\n @param pins Value indicating which pins will be modified.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_set_bits_raw__extern"]
    pub fn gpio_port_set_bits_raw(port: *const device, pins: gpio_port_pins_t) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_port_set_bits_raw__extern"]
    pub fn z_impl_gpio_port_set_bits_raw(port: *const device, pins: gpio_port_pins_t)
        -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set logical level of selected output pins to active.\n\n @param port Pointer to the device structure for the driver instance.\n @param pins Value indicating which pins will be modified.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_set_bits__extern"]
    pub fn gpio_port_set_bits(port: *const device, pins: gpio_port_pins_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set physical level of selected output pins to low.\n\n @param port Pointer to the device structure for the driver instance.\n @param pins Value indicating which pins will be modified.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_clear_bits_raw__extern"]
    pub fn gpio_port_clear_bits_raw(port: *const device, pins: gpio_port_pins_t) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_port_clear_bits_raw__extern"]
    pub fn z_impl_gpio_port_clear_bits_raw(
        port: *const device,
        pins: gpio_port_pins_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set logical level of selected output pins to inactive.\n\n @param port Pointer to the device structure for the driver instance.\n @param pins Value indicating which pins will be modified.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_clear_bits__extern"]
    pub fn gpio_port_clear_bits(port: *const device, pins: gpio_port_pins_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Toggle level of selected output pins.\n\n @param port Pointer to the device structure for the driver instance.\n @param pins Value indicating which pins will be modified.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_toggle_bits__extern"]
    pub fn gpio_port_toggle_bits(port: *const device, pins: gpio_port_pins_t) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_port_toggle_bits__extern"]
    pub fn z_impl_gpio_port_toggle_bits(port: *const device, pins: gpio_port_pins_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set physical level of selected output pins.\n\n @param port Pointer to the device structure for the driver instance.\n @param set_pins Value indicating which pins will be set to high.\n @param clear_pins Value indicating which pins will be set to low.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_set_clr_bits_raw__extern"]
    pub fn gpio_port_set_clr_bits_raw(
        port: *const device,
        set_pins: gpio_port_pins_t,
        clear_pins: gpio_port_pins_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set logical level of selected output pins.\n\n @param port Pointer to the device structure for the driver instance.\n @param set_pins Value indicating which pins will be set to active.\n @param clear_pins Value indicating which pins will be set to inactive.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_port_set_clr_bits__extern"]
    pub fn gpio_port_set_clr_bits(
        port: *const device,
        set_pins: gpio_port_pins_t,
        clear_pins: gpio_port_pins_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get physical level of an input pin.\n\n A low physical level on the pin will be interpreted as value 0. A high\n physical level will be interpreted as value 1. This function ignores\n GPIO_ACTIVE_LOW flag.\n\n @param port Pointer to the device structure for the driver instance.\n @param pin Pin number.\n\n @retval 1 If pin physical level is high.\n @retval 0 If pin physical level is low.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_get_raw__extern"]
    pub fn gpio_pin_get_raw(port: *const device, pin: gpio_pin_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get logical level of an input pin.\n\n Get logical level of an input pin taking into account GPIO_ACTIVE_LOW flag.\n If pin is configured as Active High, a low physical level will be interpreted\n as logical value 0. If pin is configured as Active Low, a low physical level\n will be interpreted as logical value 1.\n\n Note: If pin is configured as Active High, the default, gpio_pin_get()\n       function is equivalent to gpio_pin_get_raw().\n\n @param port Pointer to the device structure for the driver instance.\n @param pin Pin number.\n\n @retval 1 If pin logical value is 1 / active.\n @retval 0 If pin logical value is 0 / inactive.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_get__extern"]
    pub fn gpio_pin_get(port: *const device, pin: gpio_pin_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get logical level of an input pin from a @p gpio_dt_spec.\n\n This is equivalent to:\n\n     gpio_pin_get(spec->port, spec->pin);\n\n @param spec GPIO specification from devicetree\n @return a value from gpio_pin_get()"]
    #[link_name = "gpio_pin_get_dt__extern"]
    pub fn gpio_pin_get_dt(spec: *const gpio_dt_spec) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set physical level of an output pin.\n\n Writing value 0 to the pin will set it to a low physical level. Writing any\n value other than 0 will set it to a high physical level. This function\n ignores GPIO_ACTIVE_LOW flag.\n\n @param port Pointer to the device structure for the driver instance.\n @param pin Pin number.\n @param value Value assigned to the pin.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_set_raw__extern"]
    pub fn gpio_pin_set_raw(port: *const device, pin: gpio_pin_t, value: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set logical level of an output pin.\n\n Set logical level of an output pin taking into account GPIO_ACTIVE_LOW flag.\n Value 0 sets the pin in logical 0 / inactive state. Any value other than 0\n sets the pin in logical 1 / active state. If pin is configured as Active\n High, the default, setting it in inactive state will force the pin to a low\n physical level. If pin is configured as Active Low, setting it in inactive\n state will force the pin to a high physical level.\n\n Note: If pin is configured as Active High, gpio_pin_set() function is\n       equivalent to gpio_pin_set_raw().\n\n @param port Pointer to the device structure for the driver instance.\n @param pin Pin number.\n @param value Value assigned to the pin.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_set__extern"]
    pub fn gpio_pin_set(port: *const device, pin: gpio_pin_t, value: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set logical level of a output pin from a @p gpio_dt_spec.\n\n This is equivalent to:\n\n     gpio_pin_set(spec->port, spec->pin, value);\n\n @param spec GPIO specification from devicetree\n @param value Value assigned to the pin.\n @return a value from gpio_pin_set()"]
    #[link_name = "gpio_pin_set_dt__extern"]
    pub fn gpio_pin_set_dt(spec: *const gpio_dt_spec, value: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Toggle pin level.\n\n @param port Pointer to the device structure for the driver instance.\n @param pin Pin number.\n\n @retval 0 If successful.\n @retval -EIO I/O error when accessing an external GPIO chip.\n @retval -EWOULDBLOCK if operation would block."]
    #[link_name = "gpio_pin_toggle__extern"]
    pub fn gpio_pin_toggle(port: *const device, pin: gpio_pin_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Toggle pin level from a @p gpio_dt_spec.\n\n This is equivalent to:\n\n     gpio_pin_toggle(spec->port, spec->pin);\n\n @param spec GPIO specification from devicetree\n @return a value from gpio_pin_toggle()"]
    #[link_name = "gpio_pin_toggle_dt__extern"]
    pub fn gpio_pin_toggle_dt(spec: *const gpio_dt_spec) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Helper to initialize a struct gpio_callback properly\n @param callback A valid Application's callback structure pointer.\n @param handler A valid handler function pointer.\n @param pin_mask A bit mask of relevant pins for the handler"]
    #[link_name = "gpio_init_callback__extern"]
    pub fn gpio_init_callback(
        callback: *mut gpio_callback,
        handler: gpio_callback_handler_t,
        pin_mask: gpio_port_pins_t,
    );
}
extern "C" {
    #[doc = " @brief Add an application callback.\n @param port Pointer to the device structure for the driver instance.\n @param callback A valid Application's callback structure pointer.\n @retval 0 If successful\n @retval -ENOSYS If driver does not implement the operation\n @retval -errno Other negative errno code on failure.\n\n @note Callbacks may be added to the device from within a callback\n handler invocation, but whether they are invoked for the current\n GPIO event is not specified.\n\n Note: enables to add as many callback as needed on the same port."]
    #[link_name = "gpio_add_callback__extern"]
    pub fn gpio_add_callback(port: *const device, callback: *mut gpio_callback) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Add an application callback.\n\n This is equivalent to:\n\n     gpio_add_callback(spec->port, callback);\n\n @param spec GPIO specification from devicetree.\n @param callback A valid application's callback structure pointer.\n @return a value from gpio_add_callback()."]
    #[link_name = "gpio_add_callback_dt__extern"]
    pub fn gpio_add_callback_dt(
        spec: *const gpio_dt_spec,
        callback: *mut gpio_callback,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Remove an application callback.\n @param port Pointer to the device structure for the driver instance.\n @param callback A valid application's callback structure pointer.\n @retval 0 If successful\n @retval -ENOSYS If driver does not implement the operation\n @retval -errno Other negative errno code on failure.\n\n @warning It is explicitly permitted, within a callback handler, to\n remove the registration for the callback that is running, i.e. @p\n callback.  Attempts to remove other registrations on the same\n device may result in undefined behavior, including failure to\n invoke callbacks that remain registered and unintended invocation\n of removed callbacks.\n\n Note: enables to remove as many callbacks as added through\n       gpio_add_callback()."]
    #[link_name = "gpio_remove_callback__extern"]
    pub fn gpio_remove_callback(port: *const device, callback: *mut gpio_callback) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Remove an application callback.\n\n This is equivalent to:\n\n     gpio_remove_callback(spec->port, callback);\n\n @param spec GPIO specification from devicetree.\n @param callback A valid application's callback structure pointer.\n @return a value from gpio_remove_callback()."]
    #[link_name = "gpio_remove_callback_dt__extern"]
    pub fn gpio_remove_callback_dt(
        spec: *const gpio_dt_spec,
        callback: *mut gpio_callback,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Function to get pending interrupts\n\n The purpose of this function is to return the interrupt\n status register for the device.\n This is especially useful when waking up from\n low power states to check the wake up source.\n\n @param dev Pointer to the device structure for the driver instance.\n\n @retval status != 0 if at least one gpio interrupt is pending.\n @retval 0 if no gpio interrupt is pending.\n @retval -ENOSYS If driver does not implement the operation"]
    #[link_name = "gpio_get_pending_int__extern"]
    pub fn gpio_get_pending_int(dev: *const device) -> cty::c_int;
}
extern "C" {
    #[link_name = "z_impl_gpio_get_pending_int__extern"]
    pub fn z_impl_gpio_get_pending_int(dev: *const device) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_gpio_port_get_direction(
        port: *const device,
        map: gpio_port_pins_t,
        inputs: *mut gpio_port_pins_t,
        outputs: *mut gpio_port_pins_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn z_impl_gpio_pin_get_config(
        port: *const device,
        pin: gpio_pin_t,
        flags: *mut gpio_flags_t,
    ) -> cty::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: cty::c_uint,
    pub fp_offset: cty::c_uint,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__va_list_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_heap {
    pub _address: u8,
}
